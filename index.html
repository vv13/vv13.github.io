<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><title>vv13</title><link rel="stylesheet" href="/style/index.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_438575_w9o3rescwyp919k9.css"><link rel="icon" href="/undefined"></head><body><div id="content-outer"><div class="recent-posts"><div class="recent-post-item"><div><a class="post-title" href="/2018/02/06/css_adapt/">移动端适配</a><div class="post-excerpt"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸即屏幕对角线之间的距离，单位为英寸(inch)。单位换算如下：</p>
<ul>
<li>1 inch = 2.54 cm</li>
<li>1 cm = 0.3937inch</li>
</ul>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3></div><div class="title-info"><time class="post-time" datetime="2018-02-05T16:50:00.000Z">2.6, 2018</time><div class="title-item"><a href="/tags/web/"><i class="iconfont icon-tag">web</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/24/d3-intro/">d3-intro</a><div class="post-excerpt"><p>D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。</p>
<p>D3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。</p>
<p>例如原dom有操作方式如下：</p></div><div class="title-info"><time class="post-time" datetime="2017-10-24T14:13:18.000Z">10.24, 2017</time><div class="title-item"><a href="/tags/web/"><i class="iconfont icon-tag">web</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/23/bfc-intro/">css的BFC特性</a><div class="post-excerpt"><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p><strong>毗邻元素</strong></p>
<p>只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素</p>
<p><strong>普通流(normal flow)</strong></p>
<p>在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。</p></div><div class="title-info"><time class="post-time" datetime="2017-10-23T15:29:05.000Z">10.23, 2017</time><div class="title-item"><a href="/tags/web/"><i class="iconfont icon-tag">web</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/18/jenkins-deploy/">jenkins部署</a><div class="post-excerpt"><p>Jenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。</p>
<p>典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。</p>
<h2 id="Jenkins部署步骤"><a href="#Jenkins部署步骤" class="headerlink" title="Jenkins部署步骤"></a>Jenkins部署步骤</h2><p>准备工作如下：</p>
<ol>
<li>服务器安装docker</li>
<li>拉取镜像：<code>docker pull jenkins/jenkins</code></li>
<li>创建一个文件夹<code>jenkins_home</code>用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：<code>chown 1000 ./jenkins_home</code></li>
</ol></div><div class="title-info"><time class="post-time" datetime="2017-10-18T15:59:52.000Z">10.18, 2017</time><div class="title-item"></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/17/js-event-trigger/">js事件触发机制</a><div class="post-excerpt"><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>事件捕获</strong></p>
<p>由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。</p>
<p><strong>事件冒泡</strong></p>
<p>由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。</p></div><div class="title-info"><time class="post-time" datetime="2017-10-17T15:27:11.000Z">10.17, 2017</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/14/throttle/">什么是函数节流</a><div class="post-excerpt"><h2 id="什么是函数节流"><a href="#什么是函数节流" class="headerlink" title="什么是函数节流"></a>什么是函数节流</h2><p>避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function throttle(fn, delay, ...args) &#123;</div><div class="line">  let timer = null</div><div class="line">  return function() &#123;</div><div class="line">  	clearTimeout(timer)</div><div class="line">  	timer = setTimeout(() =&gt; fn.apply(this, args), delay)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2017-10-14T09:28:24.000Z">10.14, 2017</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/10/08/简历中的STAR原则/">简历中的STAR原则</a><div class="post-excerpt"><h2 id="STAR概念"><a href="#STAR概念" class="headerlink" title="STAR概念"></a>STAR概念</h2><ul>
<li>Situation：事情是在什么情况下发生的</li>
<li>Task：主要的任务目标是什么</li>
<li>Action：朝向目标的具体行动方式</li>
<li>Result：结果如何，有哪些成长</li>
</ul>
<p>Star法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><p>举一个示例：获得省比赛跨栏季军。</p></div><div class="title-info"><time class="post-time" datetime="2017-10-08T13:53:25.000Z">10.8, 2017</time><div class="title-item"><a href="/tags/tricks/"><i class="iconfont icon-tag">tricks</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/08/23/异步编程中的thunk函数/">异步编程中的thunk函数</a><div class="post-excerpt"><h2 id="什么是Thunk"><a href="#什么是Thunk" class="headerlink" title="什么是Thunk"></a>什么是Thunk</h2><p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>
<p>写一个简单的函数，用于读取package.json的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;package.json&apos;, (err, data) =&gt; &#123;</div><div class="line">    if (err) throw err;</div><div class="line">    console.log(data.toString())</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p></div><div class="title-info"><time class="post-time" datetime="2017-08-22T17:16:14.000Z">8.23, 2017</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/03/31/vue中如何自定义v-model/">vue中如何自定义v-model</a><div class="post-excerpt"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。</p>
<p>基本的v-model用法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>其实它是以下用法的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input :value=&quot;something&quot; @input=&quot;something = $event.target.value&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>因此，自己封装组件的话，可以这样来定义：</p></div><div class="title-info"><time class="post-time" datetime="2017-03-30T17:36:00.000Z">3.31, 2017</time><div class="title-item"><a href="/tags/vue/"><i class="iconfont icon-tag">vue</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2017/02/09/深入理解javascript线程/">理解javascript线程</a><div class="post-excerpt"><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li>进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间</li>
<li>线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)</li>
</ul>
<p>线程的作用：</p>
<ol>
<li>大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型</li>
<li>线程很轻量，创建与销毁消耗的资源小</li>
<li>线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作</li>
</ol>
<p>根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</p></div><div class="title-info"><time class="post-time" datetime="2017-02-09T09:30:24.000Z">2.9, 2017</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div></div><div id="pagination"><a class="next" href="/page/2/"><i class="iconfont icon-xiayiyeqianjinchakangengduo" aria-hidden="true"></i></a></div><div id="footer"><div>vv13 &copy; 2017<a class="ama" href="https://github.com/vv13/ama" target="_blank">Ask Me Anything</a></div><div class="shortcut"><a href="/atom.xml"><i class="iconfont icon-rss" aria-hidden="true"></i></a><a href="https://github.com/vv13"><i class="iconfont icon-github" aria-hidden="true"></i></a></div></div><div class="side-menu"><div class="shortcut" id="goHome"><a href="/"><i class="icon-home iconfont" aria-hidden="true"></i></a></div><div class="shortcut" id="goTop"><i class="icon-yijiantisheng iconfont" aria-hidden="true"></i></div></div></div><script src="/js/vv13.js"></script><div id="container"></div></body></html>