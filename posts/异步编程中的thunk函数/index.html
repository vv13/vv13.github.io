<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>vv13&#39;s blog  | 异步编程中的thunk函数</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.36" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="异步编程中的thunk函数" />
<meta property="og:description" content="什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&#39;package.json&#39;, (err, data) =&gt; { if (err) throw err; console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/" />



<meta property="article:published_time" content="2017-08-23T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2017-08-23T00:00:00&#43;00:00"/>











<meta itemprop="name" content="异步编程中的thunk函数">
<meta itemprop="description" content="什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&#39;package.json&#39;, (err, data) =&gt; { if (err) throw err; console.">


<meta itemprop="datePublished" content="2017-08-23T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-08-23T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="194">



<meta itemprop="keywords" content="js," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="异步编程中的thunk函数"/>
<meta name="twitter:description" content="什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&#39;package.json&#39;, (err, data) =&gt; { if (err) throw err; console."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="" class="f3 fw2 hover-white no-underline white-90 dib">
      vv13&#39;s blog
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          POSTS
        </p>
        <h1 class="f1">
          异步编程中的thunk函数
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        

<h2 id="什么是thunk">什么是Thunk</h2>

<p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>

<p>写一个简单的函数，用于读取package.json的信息：</p>

<pre><code>fs.readFile('package.json', (err, data) =&gt; {
    if (err) throw err;
    console.log(data.toString())
})
</code></pre>

<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>

<pre><code>const app = new Koa()

app.use(function*(next) {
    const data = yield readFileThunk('package.json')
    console.log(data)
    yield next
})

function readFileThunk(path, cb) {
    return function(cb) {
        fs.readFile(path, (err, data) =&gt; {
            if (err) throw err
            cb(null, data.toString())
        })
    }
}
app.listen(3000)
</code></pre>

<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>

<pre><code>app.use(async(ctx, next) =&gt; {
    const data = await readFileWrap('package.json')
    console.log(data)
    await next()
})

function readFileWrap(path, cb) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(path, (err, data) =&gt; {
            if (err) throw reject(error)
            resolve(data.toString())
        })
    })
}
</code></pre>

<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>

<ol>
<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>
<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>
<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>
</ol>

<pre><code>function thunkit(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments) 
        return function(cb) {
            args.push(cb)
            return fn.apply(this, args)
        }
    }
}
</code></pre>

<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>

<h2 id="thunkify源码解析">thunkify源码解析</h2>

<pre><code>function thunkify(fn){
  assert('function' == typeof fn, 'function required'); // 是否为函数

  return function(){
    var args = new Array(arguments.length); 
    var ctx = this; // 绑定函数的上下文对象
	
	// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组
    for(var i = 0; i &lt; args.length; ++i) {
      args[i] = arguments[i];
    }

    return function(done){
      var called; // 记录是否执行回调，只允许执行一次

      args.push(function(){
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });

      try {
        fn.apply(ctx, args); // 调用参数列表
      } catch (err) {
        done(err); // 返回错误
      }
    }
  }
};
</code></pre>

<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
<li><p><a href="https://github.com/tj/node-thunkify">node-thunkify</a></p></li>

<li><p><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">阮一峰-Thunk 函数的含义和用法</a></p></li>

<li><p><a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">experiments-with-koa-and-javascript-generators</a></p></li>
</ul>

      </div>
    </article>
    <aside class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        20 More Posts
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/css_adapt/" class="link ph2 pv2 db black">
            去他妈的适配
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/d3-intro/" class="link ph2 pv2 db black">
            d3-intro
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bfc-intro/" class="link ph2 pv2 db black">
            css的BFC特性
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/jenkins-deploy/" class="link ph2 pv2 db black">
            jenkins部署
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js-event-trigger/" class="link ph2 pv2 db black">
            js事件触发机制
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/throttle/" class="link ph2 pv2 db black">
            什么是函数节流
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84star%E5%8E%9F%E5%88%99/" class="link ph2 pv2 db black">
            简历中的STAR原则
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/" class="link ph2 pv2 db black o-50">
            异步编程中的thunk函数
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89v-model/" class="link ph2 pv2 db black">
            vue中如何自定义v-model
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/" class="link ph2 pv2 db black">
            理解javascript线程
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/flex%E5%B8%83%E5%B1%80/" class="link ph2 pv2 db black">
            flex布局
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bem%E8%A7%84%E8%8C%83/" class="link ph2 pv2 db black">
            BEM规范
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="link ph2 pv2 db black">
            python求质数的几种方法
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="link ph2 pv2 db black">
            几个简单的排序-js描述
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/nodejs%E4%B8%ADexports%E4%B8%8Emodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/" class="link ph2 pv2 db black">
            nodejs中exports与module.exports的区别
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="link ph2 pv2 db black">
            python变量作用域
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/" class="link ph2 pv2 db black">
            BOM对象的应用
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/git-tricks/" class="link ph2 pv2 db black">
            git实用命令技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/" class="link ph2 pv2 db black">
            js代理函数技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/" class="link ph2 pv2 db black">
            js变量申明解析
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="link ph2 pv2 db black">
            js变量作用域与垃圾回收
          </a>
        </li>
      
    </ul>
  </div>


    </aside>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="" >
    &copy; 2018 vv13&#39;s blog
  </a>
  








  </div>
</footer>

    <script src="dist/app.bundle.js" async></script>

  </body>
</html>
