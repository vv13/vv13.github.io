<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>vv13&#39;s blog  | js事件触发机制</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.36" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="js事件触发机制" />
<meta property="og:description" content="原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/js-event-trigger/" />



<meta property="article:published_time" content="2017-10-17T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2017-10-17T00:00:00&#43;00:00"/>











<meta itemprop="name" content="js事件触发机制">
<meta itemprop="description" content="原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：">


<meta itemprop="datePublished" content="2017-10-17T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-10-17T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="93">



<meta itemprop="keywords" content="js," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="js事件触发机制"/>
<meta name="twitter:description" content="原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码："/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="" class="f3 fw2 hover-white no-underline white-90 dib">
      vv13&#39;s blog
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          POSTS
        </p>
        <h1 class="f1">
          js事件触发机制
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        

<h2 id="原理">原理</h2>

<p><strong>事件捕获</strong></p>

<p>由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。</p>

<p><strong>事件冒泡</strong></p>

<p>由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。</p>

<p>这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。</p>

<hr />

<p><img src="http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg" alt="" /></p>

<p><code>addEventListen(event, function, useCapture)</code>添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</p>

<pre><code>container.addEventListener('click', () =&gt; console.log('container'), true)
child.addEventListener('click', () =&gt; console.log('child'), true)
// 点击child, 输出: container，child

container.addEventListener('click', () =&gt; console.log('container'))
child.addEventListener('click', () =&gt; console.log('child'))
// 点击child, 输出: child，container
</code></pre>

<p>假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到<strong>阻止冒泡</strong>的方式：<code>stopPropagation</code>，改写child的方法：</p>

<pre><code>child.addEventListener('click', e =&gt; {
  console.log('child')
  e.stopPropagation()
});
</code></pre>

<p>说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是<strong>阻止浏览器默认行为</strong>，如a标签跳转，submit提交等。</p>

<p>还有一种方式称为<strong>事件委托</strong>，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：</p>

<pre><code>container.addEventListener(&quot;click&quot;, e =&gt; {
  if (e.target.id === 'child') {
    console.log('child')
  }
});
</code></pre>

<p>可见，当点击子元素依然会输出<code>child</code>，在某些特定场景利用事件委托可节省大量的性能。</p>

<p>明白了上述事件关系，target与currentTarget也就易于理解了，简言之，<strong>target指引发出发事件的元素，currentTarget则指事件绑定的元素</strong>，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。</p>

<h2 id="示例">示例</h2>

<p>在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：</p>

<ul>
<li>mouseenter：鼠标进入时触发，不响应子元素冒泡事件</li>
<li>mouseover：鼠标进入时触发，响应子元素冒泡事件</li>
<li>mouseleave：鼠标离开时触发，不响应子元素冒泡事件</li>
<li>mouseout：鼠标离开时触发，响应子元素冒泡事件</li>
</ul>

<p>让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：</p>

<p><img src="http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg" alt="" /></p>

<p>场景如下：</p>

<ul>
<li>鼠标移入每一行，显示编辑按钮，移出则取消</li>
<li>点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态</li>
</ul>

<p>其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。</p>

<p>单看页面，其实就是ul&gt;li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：<code>&lt;div class=&quot;schedule-input-wrap&quot; v-show=&quot;isEdit || hovering&quot;&gt;</code>，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。</p>

<p>有了思路，首先考虑<strong>事件捕获机制</strong>，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为<code>pointer-events:none;</code>，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。</p>

<p>后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：</p>

<pre><code>                &lt;ul @mouseleave=&quot;hoverId=''&quot;&gt;
                    &lt;li v-for=&quot;(item, itemIndex) in record.schedulings&quot;
                        @mouseenter=&quot;hoverId=`item${itemIndex}`&quot;
                        ....
                        &lt;schedule-input :hovering=&quot;isHovering(itemIndex)&quot;
                        &gt;&lt;/schedule-input&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
</code></pre>

<p>其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。</p>

      </div>
    </article>
    <aside class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        20 More Posts
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/css_adapt/" class="link ph2 pv2 db black">
            去他妈的适配
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/d3-intro/" class="link ph2 pv2 db black">
            d3-intro
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bfc-intro/" class="link ph2 pv2 db black">
            css的BFC特性
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/jenkins-deploy/" class="link ph2 pv2 db black">
            jenkins部署
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js-event-trigger/" class="link ph2 pv2 db black o-50">
            js事件触发机制
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/throttle/" class="link ph2 pv2 db black">
            什么是函数节流
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84star%E5%8E%9F%E5%88%99/" class="link ph2 pv2 db black">
            简历中的STAR原则
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/" class="link ph2 pv2 db black">
            异步编程中的thunk函数
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89v-model/" class="link ph2 pv2 db black">
            vue中如何自定义v-model
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/" class="link ph2 pv2 db black">
            理解javascript线程
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/flex%E5%B8%83%E5%B1%80/" class="link ph2 pv2 db black">
            flex布局
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bem%E8%A7%84%E8%8C%83/" class="link ph2 pv2 db black">
            BEM规范
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="link ph2 pv2 db black">
            python求质数的几种方法
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="link ph2 pv2 db black">
            几个简单的排序-js描述
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/nodejs%E4%B8%ADexports%E4%B8%8Emodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/" class="link ph2 pv2 db black">
            nodejs中exports与module.exports的区别
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="link ph2 pv2 db black">
            python变量作用域
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/" class="link ph2 pv2 db black">
            BOM对象的应用
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/git-tricks/" class="link ph2 pv2 db black">
            git实用命令技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/" class="link ph2 pv2 db black">
            js代理函数技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/" class="link ph2 pv2 db black">
            js变量申明解析
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="link ph2 pv2 db black">
            js变量作用域与垃圾回收
          </a>
        </li>
      
    </ul>
  </div>


    </aside>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="" >
    &copy; 2018 vv13&#39;s blog
  </a>
  








  </div>
</footer>

    <script src="dist/app.bundle.js" async></script>

  </body>
</html>
