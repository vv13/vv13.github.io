<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>vv13&#39;s blog  | js变量作用域与垃圾回收</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.36" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="js变量作用域与垃圾回收" />
<meta property="og:description" content="栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &#39;某某某&#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj;  它们在内存中的结构如图：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" />



<meta property="article:published_time" content="2016-11-21T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2016-11-21T00:00:00&#43;00:00"/>











<meta itemprop="name" content="js变量作用域与垃圾回收">
<meta itemprop="description" content="栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &#39;某某某&#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj;  它们在内存中的结构如图：">


<meta itemprop="datePublished" content="2016-11-21T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-11-21T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="340">



<meta itemprop="keywords" content="js," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="js变量作用域与垃圾回收"/>
<meta name="twitter:description" content="栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &#39;某某某&#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj;  它们在内存中的结构如图："/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="" class="f3 fw2 hover-white no-underline white-90 dib">
      vv13&#39;s blog
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          POSTS
        </p>
        <h1 class="f1">
          js变量作用域与垃圾回收
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        

<h2 id="栈内存与堆内存">栈内存与堆内存</h2>

<p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>

<pre><code class="language-javascript">const name = '某某某';
const age = 22;
const hasGf = false;
const obj = {
  test: 123,
}
const anotherObj = obj;
</code></pre>

<p>它们在内存中的结构如图：</p>

<p><img src="/static/imgs/js变量的内存管理.jpg" alt="" /></p>

<ul>
<li>栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间</li>
<li>堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用</li>
</ul>

<p>由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:</p>

<ul>
<li>基本类型直接在栈内存中进行复制值</li>
<li>引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象</li>
</ul>

<p>既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:</p>

<pre><code>
function test(n) {
  if (n === 1) {
    return 1;
  }
  return n + test(n - 1);
}
test(10000); // 50005000
test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)
</code></pre>

<p>正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</p>

<pre><code>test(5)
5 + test(4)
5 + (4 + test(3))
5 + (4 + (3 + test(2)))
5 + (4 + (3 + (2 + test(1))))
5 + (4 + (3 + (2 + 1)))
5 + (4 + (3 + 3))
5 + (4 + 6)
5 + 10
15
</code></pre>

<p>正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:</p>

<pre><code>function test(n, count) {
  if (n === 0) {
    return count;
  }
  return test(n - 1, count + n);
}
test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)
</code></pre>

<p>上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：</p>

<pre><code>Temporarily Removed in Babel 6
Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.
</code></pre>

<p>那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:</p>

<pre><code>function trampoline(f) {
    while (f &amp;&amp; f instanceof Function) {
        f = f();
    }
    return f;
}

function test(x, count) {
    function recur(x, count) {
        if (x &gt; 0) {
          return recur.bind(null, x - 1, count + x);
        } else {
          return count;
        }
    }
    return trampoline(recur.bind(null, x, count));
}

console.log(test(100000, 0)); // 5000050000
</code></pre>

<h2 id="内存泄漏">内存泄漏</h2>

<p>javascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：</p>

<ol>
<li>遍历所有可访问的对象。</li>
<li>回收已不可访问的对象。</li>
</ol>

<p>因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.</p>

<h4 id="闭包拾遗">闭包拾遗</h4>

<p>通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:</p>

<pre><code>function outerFn() {
  var a = 0;
  function innerFn() {
    console.log(a++);
  }
  return innerFn;
}

var fn = outerFn();
fn(); // 0
fn(); // 1
</code></pre>

<h4 id="在函数内创建全局变量">在函数内创建全局变量</h4>

<p>若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:</p>

<pre><code>function Test() {
  hehe = 123;
  this.a = 1;
}
Test();
console.log(hehe, a); // 123, 1
</code></pre>

<h4 id="循环引用">循环引用</h4>

<p>如果dom元素操作不当, 很容易造成非常规的内存占用:</p>

<pre><code>function assignHandler () {
  var element = document.getElementById('someElement');
  element.onclick = function () {
    alert(element.id);
  };
}
</code></pre>

<p>由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:</p>

<pre><code>function assignHandler () {
  var element = document.getElementById('someElement');
  var id = element.id;
  element.onclick = function () {
    alert(id);
  };
  element = null;
}
</code></pre>

      </div>
    </article>
    <aside class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        20 More Posts
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/css_adapt/" class="link ph2 pv2 db black">
            去他妈的适配
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/d3-intro/" class="link ph2 pv2 db black">
            d3-intro
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bfc-intro/" class="link ph2 pv2 db black">
            css的BFC特性
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/jenkins-deploy/" class="link ph2 pv2 db black">
            jenkins部署
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js-event-trigger/" class="link ph2 pv2 db black">
            js事件触发机制
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/throttle/" class="link ph2 pv2 db black">
            什么是函数节流
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84star%E5%8E%9F%E5%88%99/" class="link ph2 pv2 db black">
            简历中的STAR原则
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/" class="link ph2 pv2 db black">
            异步编程中的thunk函数
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89v-model/" class="link ph2 pv2 db black">
            vue中如何自定义v-model
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/" class="link ph2 pv2 db black">
            理解javascript线程
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/flex%E5%B8%83%E5%B1%80/" class="link ph2 pv2 db black">
            flex布局
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bem%E8%A7%84%E8%8C%83/" class="link ph2 pv2 db black">
            BEM规范
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="link ph2 pv2 db black">
            python求质数的几种方法
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="link ph2 pv2 db black">
            几个简单的排序-js描述
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/nodejs%E4%B8%ADexports%E4%B8%8Emodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/" class="link ph2 pv2 db black">
            nodejs中exports与module.exports的区别
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="link ph2 pv2 db black">
            python变量作用域
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/" class="link ph2 pv2 db black">
            BOM对象的应用
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/git-tricks/" class="link ph2 pv2 db black">
            git实用命令技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/" class="link ph2 pv2 db black">
            js代理函数技巧
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/" class="link ph2 pv2 db black">
            js变量申明解析
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="link ph2 pv2 db black o-50">
            js变量作用域与垃圾回收
          </a>
        </li>
      
    </ul>
  </div>


    </aside>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="" >
    &copy; 2018 vv13&#39;s blog
  </a>
  








  </div>
</footer>

    <script src="dist/app.bundle.js" async></script>

  </body>
</html>
