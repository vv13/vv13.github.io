<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><title>vv13</title><link rel="stylesheet" href="/css/vv13.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_438575_w9o3rescwyp919k9.css"><link rel="icon" href="/undefined"></head><body><div id="content-outer"><div class="recent-posts"><div class="recent-post-item"><div><a class="post-title" href="/2017/01/09/BEM规范/">BEM规范</a><div class="post-excerpt"><h2 id="什么是BEM？"><a href="#什么是BEM？" class="headerlink" title="什么是BEM？"></a>什么是BEM？</h2><p>block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.block &#123;&#125; // 块</div><div class="line">.block__element &#123;&#125; // 块所属元素</div><div class="line">.block__element--modifier &#123;&#125; // 块所属元素的状态</div></pre></td></tr></table></figure>
<h2 id="与sass结合"><a href="#与sass结合" class="headerlink" title="与sass结合"></a>与sass结合</h2></div><div class="title-info"><time class="post-time" datetime="2017-01-09T14:27:27.000Z">1.9, 2017</time><div class="title-item"><a href="/tags/tricks/"><i class="iconfont icon-tag">tricks</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/26/冒泡、选择与插入排序/">几个简单的排序-js描述</a><div class="post-excerpt"><p>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。</p>
<h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><p>冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/imgs/冒泡、选择与插入排序-1.jpg" alt=""></p></div><div class="title-info"><time class="post-time" datetime="2016-12-26T07:02:51.000Z">12.26, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/26/求质数的几种方法/">python求质数的几种方法</a><div class="post-excerpt"><p>今天偶然在博客上上看到有人提<a href="http://blog.csdn.net/program_think/article/details/7032600/" target="_blank" rel="external">求质素的几种境界</a>,在此用python进行实现代码,并进行简单的说明.</p>
<p>我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.</p>
<h3 id="境界1"><a href="#境界1" class="headerlink" title="境界1"></a>境界1</h3><p>我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取<code>2~N/2</code>.<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def f1(num):</div><div class="line">    # 2也是质数,之后程序从3开始判断</div><div class="line">    count = 1</div><div class="line">    for i in range(3, num):</div><div class="line">        b = True</div><div class="line">        for j in range(2, i/2 + 1):</div><div class="line">            if i % j == 0:</div><div class="line">                b = False</div><div class="line">                break</div><div class="line">        if b:</div><div class="line">            count += 1</div><div class="line">    return count</div><div class="line"></div><div class="line">f1(100000)</div><div class="line"># 耗时35.1589805796秒, 个数9592</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2016-12-25T16:02:23.000Z">12.26, 2016</time><div class="title-item"><a href="/tags/python/"><i class="iconfont icon-tag">python</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/25/nodejs中exports与module-exports的区别/">nodejs中exports与module.exports的区别</a><div class="post-excerpt"><p>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。</p>
<h3 id="require-的返回值"><a href="#require-的返回值" class="headerlink" title="require()的返回值"></a>require()的返回值</h3><p>require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：</p>
<p>test.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = function()&#123;</div><div class="line">    console.log(&apos;I\&apos;m module.exports&apos;)</div><div class="line">&#125;</div><div class="line">exports = function()&#123;</div><div class="line">    console.log(&apos;I\&apos;m exports&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2016-12-25T15:52:57.000Z">12.25, 2016</time><div class="title-item"><a href="/tags/nodejs/"><i class="iconfont icon-tag">nodejs</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/25/python变量作用域/">python变量作用域</a><div class="post-excerpt"><p>class比作整个屋子，def为卧室，class外面的部分就是小区环境。</p>
<h4 id="首先测试房子-class-与公共设施变量-globals-之间的关系"><a href="#首先测试房子-class-与公共设施变量-globals-之间的关系" class="headerlink" title="首先测试房子(class)与公共设施变量(globals)之间的关系"></a>首先测试房子(class)与公共设施变量(globals)之间的关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line"></div><div class="line">PUBLIC_FACILITIES = u&quot;公共厕所&quot;</div><div class="line"></div><div class="line">class House():</div><div class="line">    print PUBLIC_FACILITIES</div><div class="line">    PUBLIC_FACILITIES = &apos;改造&apos;</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    test = House()</div><div class="line">    print PUBLIC_FACILITIES</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">公共厕所</div><div class="line">公共厕所</div><div class="line"></div><div class="line">***Repl Closed***</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2016-12-25T15:43:05.000Z">12.25, 2016</time><div class="title-item"><a href="/tags/python/"><i class="iconfont icon-tag">python</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/18/BOM对象的应用/">BOM对象的应用</a><div class="post-excerpt"><p>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：</p>
<ul>
<li>跳转到新的网址：<code>window.location.href = &#39;http://www.google.com&#39;;</code></li>
<li>打开新的窗体：<code>window.open(&#39;http://www.google.com&#39;);</code></li>
<li>刷新页面：<code>window.location.reload();</code></li>
<li>后退：<code>window.history.back();</code></li>
<li>前进：<code>window.history.forward();</code></li>
</ul>
<h4 id="子窗体与父窗体对象的引用"><a href="#子窗体与父窗体对象的引用" class="headerlink" title="子窗体与父窗体对象的引用"></a>子窗体与父窗体对象的引用</h4><p>考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function dealOk() &#123;</div><div class="line">  window.opener.location.reload();</div><div class="line">  window.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2016-12-18T12:24:59.000Z">12.18, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/11/git-tricks/">git实用命令技巧</a><div class="post-excerpt"><h2 id="git-pull-–rebase"><a href="#git-pull-–rebase" class="headerlink" title="git pull –rebase"></a>git pull –rebase</h2><p>从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：</p>
<p><img src="/imgs/git实用命令技巧-1.png" alt=""></p>
<p>我们期望的分支图也许时这样的：</p>
<p><img src="/imgs/git实用命令技巧-2.png" alt=""></p></div><div class="title-info"><time class="post-time" datetime="2016-12-11T15:59:21.000Z">12.11, 2016</time><div class="title-item"><a href="/tags/tricks/"><i class="iconfont icon-tag">tricks</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/09/js变量申明解析/">js变量申明解析</a><div class="post-excerpt"><p>var属性有多种需要注意的特性：</p>
<ol>
<li>无块级作用域</li>
<li>不带申明类型默认为全局变量</li>
<li>变量提升</li>
<li>运行重新申明变量</li>
</ol>
<h4 id="一、块级作用域"><a href="#一、块级作用域" class="headerlink" title="一、块级作用域"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 100; i++)&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">console.log(i); // 输入100</div></pre></td></tr></table></figure></div><div class="title-info"><time class="post-time" datetime="2016-12-09T09:30:24.000Z">12.9, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/12/09/js代理函数技巧/">js代理函数技巧</a><div class="post-excerpt"><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function splice(arrs, start, length) &#123;</div><div class="line">  arrs.splice(start, length);</div><div class="line">  return arrs;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const arrs = [1,2,3];</div><div class="line">splice(arrs, 1, 1); // 返回为：[1,3]</div></pre></td></tr></table></figure></p>
<p>如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：</p></div><div class="title-info"><time class="post-time" datetime="2016-12-08T17:06:48.000Z">12.9, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div><div class="recent-post-item"><div><a class="post-title" href="/2016/11/21/js变量的内存管理/">js变量作用域与垃圾回收</a><div class="post-excerpt"><h2 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h2><p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = <span class="string">'某某某'</span>;</div><div class="line"><span class="keyword">const</span> age = <span class="number">22</span>;</div><div class="line"><span class="keyword">const</span> hasGf = <span class="literal">false</span>;</div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  test: <span class="number">123</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> anotherObj = obj;</div></pre></td></tr></table></figure>
<p>它们在内存中的结构如图：</p>
<p><img src="/imgs/js变量的内存管理.jpg" alt=""></p></div><div class="title-info"><time class="post-time" datetime="2016-11-20T16:26:18.000Z">11.21, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div></div></div></div><div id="pagination"><a class="prev" href="/"><i class="iconfont icon-shangyiyehoutuifanhui" aria-hidden="true"></i></a></div><div id="footer"><div>vv13 &copy; 2017</div><div class="shortcut"><a href="/atom.xml"><i class="iconfont icon-rss" aria-hidden="true"></i></a><a href="https://github.com/vv13"><i class="iconfont icon-github" aria-hidden="true"></i></a></div></div><div class="side-menu"><div class="shortcut" id="goHome"><a href="/"><i class="icon-home iconfont" aria-hidden="true"></i></a></div><div class="shortcut" id="goTop"><i class="icon-yijiantisheng iconfont" aria-hidden="true"></i></div></div></div><script src="/js/vv13.js"></script><div id="container"></div></body></html>