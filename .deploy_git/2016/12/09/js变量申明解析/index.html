<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><title>vv13</title><link rel="stylesheet" href="/css/vv13.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_438575_w9o3rescwyp919k9.css"><link rel="icon" href="/undefined"></head><body><div id="content-outer"><link rel="stylesheet" href="/css/github-markdown.css"><article class="markdown-body" id="post"><h1 class="article-title">js变量申明解析</h1><div class="title-info"><time class="post-time" datetime="2016-12-09T09:30:24.000Z">12.9, 2016</time><div class="title-item"><a href="/tags/js/"><i class="iconfont icon-tag">js</i></a></div></div><p>var属性有多种需要注意的特性：</p>
<ol>
<li>无块级作用域</li>
<li>不带申明类型默认为全局变量</li>
<li>变量提升</li>
<li>运行重新申明变量</li>
</ol>
<h4 id="一、块级作用域"><a href="#一、块级作用域" class="headerlink" title="一、块级作用域"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 100; i++)&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">console.log(i); // 输入100</div></pre></td></tr></table></figure>
<p>若我们使用es6的let与const，就不会出现这种问题。</p>
<h4 id="二、影响全局"><a href="#二、影响全局" class="headerlink" title="二、影响全局"></a>二、影响全局</h4><p>若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;</div><div class="line">  a: &apos;a&apos;,</div><div class="line">  b: &apos;b&apos;,</div><div class="line">&#125;;</div><div class="line">with (obj) &#123;</div><div class="line">  console.log(a, b); // a b</div><div class="line">  b = 3;</div><div class="line">  c = 1;</div><div class="line">&#125;</div><div class="line">console.log(obj.b, c); // 3 1</div></pre></td></tr></table></figure>
<p>在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const testobj = &#123; foo: &apos;bar&apos; &#125;;</div><div class="line">let value;</div><div class="line">let starttime;</div><div class="line">let endtime;</div><div class="line">const times = 1000000;</div><div class="line"></div><div class="line">starttime = new Date().getTime();</div><div class="line">for (let n = 0; n &lt; times; n++) &#123;</div><div class="line">  value = testobj.foo;</div><div class="line">&#125;</div><div class="line">endtime = new Date().getTime();</div><div class="line">console.log(`正常赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class="line"></div><div class="line">starttime = new Date().getTime();</div><div class="line">with (testobj) &#123;</div><div class="line">  for (let n = 0; n &lt; times; n++) &#123;</div><div class="line">    value = foo;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">endtime = new Date().getTime();</div><div class="line">console.log(`with赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class="line"></div><div class="line">*****输出结果</div><div class="line">正常赋值操作:25ms</div><div class="line">with赋值操作:415ms</div></pre></td></tr></table></figure>
<p>造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。</p>
<h4 id="三、变量提升"><a href="#三、变量提升" class="headerlink" title="三、变量提升"></a>三、变量提升</h4><p>大家肯定熟悉函数提升，可将函数定义放在调用代码之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a(); // haha</div><div class="line">function a() &#123;</div><div class="line">    console.log(&apos;haha&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。</p>
<p>在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a); // undefined</div><div class="line">var a = &apos;1&apos;;</div></pre></td></tr></table></figure>
<p>其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。</p>
<p>只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：<code>暂时性死区</code>。</p>
<blockquote>
<p>暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。</p>
</blockquote>
<p>这里有一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">if(true)&#123;</div><div class="line">    console.log(a) //ReferenceError</div><div class="line">    let a = 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var tmp = new Date();</div><div class="line"></div><div class="line">function f() &#123;</div><div class="line">  console.log(tmp);</div><div class="line">  if (false) &#123;</div><div class="line">    var tmp = &quot;hello world&quot;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); // undefined</div></pre></td></tr></table></figure>
<h4 id="四、全局对象属性"><a href="#四、全局对象属性" class="headerlink" title="四、全局对象属性"></a>四、全局对象属性</h4><p>全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  a = 3</div><div class="line">&#125;)()</div><div class="line">var b = 2</div><div class="line">console.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性</div><div class="line"></div><div class="line">let c = 123</div><div class="line">const d = 456</div><div class="line">console.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。</p>
</article><div id="commenter"></div><link rel="stylesheet" href="/css/dark.css"><script src="/js/gitment.js"></script><script>var gitment = new Gitment({
owner: 'vv13',
repo: 'vv13.github.io',
oauth: {
    client_id: 'fc26f0c5db6ee176856d',
    client_secret: 'adaddc022d70102d2f037f675d0b29a13d5283dd',
},
})
gitment.render('commenter')</script><div id="footer"><div>vv13 &copy; 2017</div><div class="shortcut"><a href="/atom.xml"><i class="iconfont icon-rss" aria-hidden="true"></i></a><a href="https://github.com/vv13"><i class="iconfont icon-github" aria-hidden="true"></i></a></div></div><div class="side-menu"><div class="shortcut" id="goHome"><a href="/"><i class="icon-home iconfont" aria-hidden="true"></i></a></div><div class="shortcut" id="goTop"><i class="icon-yijiantisheng iconfont" aria-hidden="true"></i></div></div></div><script src="/js/vv13.js"></script><div id="container"></div></body></html>