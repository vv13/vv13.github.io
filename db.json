{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/imgs/flex布局.png","path":"imgs/flex布局.png","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-1.jpg","path":"imgs/冒泡、选择与插入排序-1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/git实用命令技巧-2.png","path":"imgs/git实用命令技巧-2.png","modified":0,"renderable":0},{"_id":"source/imgs/js变量的内存管理.jpg","path":"imgs/js变量的内存管理.jpg","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-3.jpg","path":"imgs/冒泡、选择与插入排序-3.jpg","modified":0,"renderable":0},{"_id":"themes/13/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"source/imgs/git实用命令技巧-1.png","path":"imgs/git实用命令技巧-1.png","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-2.jpg","path":"imgs/冒泡、选择与插入排序-2.jpg","modified":0,"renderable":0},{"_id":"themes/13/source/js/disqus.js","path":"js/disqus.js","modified":0,"renderable":1},{"_id":"themes/13/source/css/const.less","path":"css/const.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/vv13.less","path":"css/vv13.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"themes/13/source/js/vv13.js","path":"js/vv13.js","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/pagination.less","path":"css/partials/pagination.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/post.less","path":"css/partials/post.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/sidemenu.less","path":"css/partials/sidemenu.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/title-info.less","path":"css/partials/title-info.less","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"93955c44e7cac842838d66493ebc88848c60bdaa","modified":1511676323316},{"_id":"source/CNAME","hash":"f48d71d79d74551ad16105e080a5acbfec1bef79","modified":1502129735000},{"_id":"source/favicon.ico","hash":"77804a0523be198ceeea245b69aef92019fa0716","modified":1502385637000},{"_id":"themes/13/.gitignore","hash":"fadea9edd29e83c1866d8ff5246d38b9e4254801","modified":1502389260000},{"_id":"themes/13/.DS_Store","hash":"82821d28cd6299b5430ce52717126ad20a6b6c2a","modified":1501088584000},{"_id":"themes/13/README.md","hash":"8c7ad0f02624f12a048902aa2f74ee60165ae404","modified":1513079814000},{"_id":"themes/13/_config.yml","hash":"05d462c411812c92e5e980d1d2cc155f2bfbd758","modified":1513078940845},{"_id":"source/_posts/.DS_Store","hash":"b7b4ea54547ed9e42523f53b84de4e001bdde038","modified":1511632885706},{"_id":"source/_posts/BEM规范.md","hash":"7200ac096a390acf0e84c61c6d54c00c8a4f4a38","modified":1507471088988},{"_id":"source/_posts/flex布局.md","hash":"38fd063d60b2fd71692ca61fde2473d5de69e14b","modified":1507471084607},{"_id":"source/_posts/BOM对象的应用.md","hash":"672e2e5cf4885023ffe28d23b8b0d99d9181f6d3","modified":1507471117266},{"_id":"source/_posts/git-tricks.md","hash":"d9aa7cb4884bc62d832cb9bd618aa0cdc14bea41","modified":1517467409783},{"_id":"source/_posts/bfc-intro.md","hash":"3a9e403328e35542f7bd5e1c748721813fbad9b5","modified":1508772615887},{"_id":"source/_posts/d3-intro.md","hash":"32aebbb8e3d52db738f0ac3266066bfc9b094e2a","modified":1508854417634},{"_id":"source/_posts/js-event-trigger.md","hash":"57bd1e098fdfd27f3db91d288828f4618cdd7f17","modified":1515322793467},{"_id":"source/_posts/js代理函数技巧.md","hash":"00e3eaf4a44fe1c952085eeb5afc3ca08885c268","modified":1507471131467},{"_id":"source/_posts/js变量申明解析.md","hash":"53f7ef06b02cad52d9b351ab20f13a2ce8da5afe","modified":1507471127308},{"_id":"source/_posts/jenkins-deploy.md","hash":"9f716af0fdf8b22011d5f098e58660ddb94eae5d","modified":1508342452984},{"_id":"source/_posts/nodejs中exports与module-exports的区别.md","hash":"705f7c402008ad8e09f6e89bca4fdf38b2ce2a21","modified":1507471112077},{"_id":"source/_posts/js变量的内存管理.md","hash":"b4e91c5c70b4a5a43bfdaa9a3bb47b796f24cf9b","modified":1507471135406},{"_id":"source/_posts/python变量作用域.md","hash":"7fd0a57311185de5b79e470634d04608e5171339","modified":1507471105166},{"_id":"source/_posts/vue中如何自定义v-model.md","hash":"4e598e72da061d163111640c2d1085c0cef536fb","modified":1507471072004},{"_id":"source/_posts/冒泡、选择与插入排序.markdown","hash":"97b31395c753fa4813651c2397d4c3ad76b7d045","modified":1507471100279},{"_id":"source/_posts/throttle.md","hash":"a009610cf6149ceb1483c4362af7e4b327b17e63","modified":1507973428794},{"_id":"source/_posts/求质数的几种方法.md","hash":"96111dd03ffbe2fa5f84f27bc017a3ead78c7370","modified":1507471094261},{"_id":"source/_posts/深入理解javascript线程.md","hash":"e1c9addf0c2cde3dd3bba5f27d903473641b2a29","modified":1507471077462},{"_id":"source/_posts/异步编程中的thunk函数.md","hash":"579c0aa876ffa159bb95022a885c5b3bdad0a95a","modified":1507471065444},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1511623795130},{"_id":"source/_posts/简历中的STAR原则.md","hash":"04ffa69767c5ce9cff8b38bd290d6ee87e1653aa","modified":1507526052636},{"_id":"source/imgs/flex布局.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1502129038000},{"_id":"source/imgs/冒泡、选择与插入排序-1.jpg","hash":"9ab13dd7666249f0e7364a8cc8b7ef6da268d0ee","modified":1502129038000},{"_id":"source/imgs/git实用命令技巧-2.png","hash":"ce3db35ad9792984e3f543ddd13841a10bcf4a88","modified":1502129038000},{"_id":"source/imgs/js变量的内存管理.jpg","hash":"0eb4c720b8b5e9759f7bf066e6353a0d0feae7ca","modified":1502129038000},{"_id":"themes/13/.git/COMMIT_EDITMSG","hash":"ed79d493a818ca087729ba51cf9f0a1fcfb5a948","modified":1513079924880},{"_id":"source/imgs/冒泡、选择与插入排序-3.jpg","hash":"2943a4f2ffc2f5fec69edecc54e9607c715f72b7","modified":1502129038000},{"_id":"themes/13/.git/FETCH_HEAD","hash":"61ea6f9c2f4d11c217fea5648a5399f4dd2ddc96","modified":1507739330137},{"_id":"themes/13/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1502671744000},{"_id":"themes/13/.git/config","hash":"c137b33534412f14639d0f20dc1ae5da61084088","modified":1502389392000},{"_id":"themes/13/.git/index","hash":"9b8d9fcbb99a5d13f82268e81110b52d7320721f","modified":1513079924878},{"_id":"themes/13/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1502389230000},{"_id":"themes/13/.git/ORIG_HEAD","hash":"034d3350c73079c57eb4900f73d4737d8abade7a","modified":1507734415925},{"_id":"themes/13/layout/archive.pug","hash":"d8a9ca1a38bfbe264314267e1646c6dc53b16806","modified":1498494263000},{"_id":"themes/13/layout/post.pug","hash":"c54b55e81cc8aa61ba5b0ad2d5316690955d3474","modified":1513078808000},{"_id":"themes/13/layout/index.pug","hash":"b8007c441d4b86435a8751d38bd2477e890f9f3d","modified":1502117975000},{"_id":"themes/13/layout/page.pug","hash":"4696a806523bf60fcfae96982ea1194afc631e63","modified":1502199967000},{"_id":"themes/13/layout/tag.pug","hash":"612f8e8cc48e8180615fab79b1e94a5236136987","modified":1507733917638},{"_id":"themes/13/source/.DS_Store","hash":"c58599eba8cc806344e95807f87b76fbf05d14e6","modified":1501088584000},{"_id":"themes/13/source/favicon.ico","hash":"77804a0523be198ceeea245b69aef92019fa0716","modified":1502385808000},{"_id":"source/imgs/git实用命令技巧-1.png","hash":"73d8e732cd22b30e4aab60e894af9619bc4a4473","modified":1502129038000},{"_id":"source/imgs/冒泡、选择与插入排序-2.jpg","hash":"b7a7bdf51ea8bf16be33aff322472bbc1ccbd13f","modified":1502129038000},{"_id":"themes/13/source/js/disqus.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1501006821000},{"_id":"themes/13/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1502389230000},{"_id":"themes/13/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1502389230000},{"_id":"themes/13/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1502389230000},{"_id":"themes/13/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1502389230000},{"_id":"themes/13/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1502389230000},{"_id":"themes/13/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1502389230000},{"_id":"themes/13/.git/logs/HEAD","hash":"bcc6eb0b7e69bac1358d5f25b12d7cc1b653eb8d","modified":1513079924882},{"_id":"themes/13/layout/includes/article-categories.pug","hash":"8ed9aaa5d32950dcde8b91d29b3649da92bfb6bd","modified":1500996621000},{"_id":"themes/13/layout/includes/article-tags.pug","hash":"b50d1beb77a7300681e0618e71414cfb724b6448","modified":1500996413000},{"_id":"themes/13/layout/includes/disqus.pug","hash":"7c01484a808ce30a947807e2456fd8c838608c10","modified":1502387063000},{"_id":"themes/13/layout/includes/layout.pug","hash":"7c67ea7c0f99c559090e035f8425de39b8cc8d69","modified":1511626206587},{"_id":"themes/13/layout/includes/footer.pug","hash":"6605bd720221ca4911c353d07d2adf9103788ab8","modified":1513079065979},{"_id":"themes/13/layout/includes/recent-posts.pug","hash":"53440e9655a6ae8e2d3202d33f2fa83c5c00caed","modified":1502201199000},{"_id":"themes/13/layout/includes/sidemenu.pug","hash":"33726f06b9f822862494f3afe3f194dcc4019350","modified":1507733079148},{"_id":"themes/13/layout/mixins/title-info.pug","hash":"b3990b49e4d45a68bffcbc6ea4e77706b129ebfc","modified":1507733490000},{"_id":"themes/13/layout/includes/pagination.pug","hash":"a867e83b982e1282a953343925fd88ee9e83f4ca","modified":1507732587839},{"_id":"themes/13/source/css/dark.css","hash":"93925c9706301bb2d42f89941344bec4fc957642","modified":1511682143954},{"_id":"themes/13/source/css/.DS_Store","hash":"70955943c87c488c8d9dacae0664351d5d4b9e0a","modified":1501119361000},{"_id":"themes/13/source/css/const.less","hash":"01b817b66aa691d642e109187cf4c85183ffdb35","modified":1507734054373},{"_id":"themes/13/source/css/vv13.less","hash":"0560563899c8b96ae9f76ecd955073eeb9a658eb","modified":1513078990137},{"_id":"themes/13/source/css/github-markdown.css","hash":"8b477ead44febb2a429ea3a2121ace53ac5297fb","modified":1508255253419},{"_id":"themes/13/source/js/vv13.js","hash":"053e02adb02291fc984421ac78d507b52a7114ad","modified":1508651850247},{"_id":"themes/13/.git/refs/heads/master","hash":"fb7ae17b1fcade052664a4a9e40b358e7a9e0108","modified":1513079924882},{"_id":"themes/13/.git/objects/02/ccde4dce95f9a4716c5599279eb921d297e1bf","hash":"ad7e11dafe1785a325555694344f8c6a6db87a25","modified":1507734405570},{"_id":"themes/13/.git/objects/02/86c7275f976c17aa9fd5dc312f793498ab6146","hash":"d6992a51974edd9fdc74ef75b0aaf1e60e3ae7de","modified":1502389340000},{"_id":"themes/13/.git/objects/01/37f8da3d39f4bfcd2e88e5a0bfa4ec8ad770d7","hash":"702a316f306bfd8aaee056eafc6d58c93721a656","modified":1502389313000},{"_id":"themes/13/.git/objects/02/a0266761ab68ba4633160b909b37a68fbdd338","hash":"98d77d4e4562000acae41aa5eea8a7eb920573d0","modified":1507734405538},{"_id":"themes/13/.git/objects/00/1a647776affc49705381ade2e72c4c39a7d846","hash":"29198f4d006e909613f2da2aac8e2531fd93fd48","modified":1502671744000},{"_id":"themes/13/.git/objects/0a/0704a420bb16c2c258ee3a74baf479d15d8762","hash":"f6e226b1a8f8003f66ed71a652b2f8bd858f0ce7","modified":1502389319000},{"_id":"themes/13/.git/objects/0a/ee68387542f657b8663c73b2d388bdff6f2851","hash":"5dc2fff55e763b4ee809768ccc3c2219f092473e","modified":1507391854736},{"_id":"themes/13/.git/objects/00/b613fff7af31ebfde3d3a6e99d61c43f7ceb09","hash":"72a2c8b7c61e46a606fe8a63f633edd1279e3315","modified":1502389313000},{"_id":"themes/13/.git/objects/08/094668e3b7a4c051015d695f70c130dd5a19d9","hash":"4dc08ecfbddf332b2bdf606fe909dcbe4a5c3713","modified":1502389313000},{"_id":"themes/13/.git/objects/0c/00abd154053357cf10c3863c0252d2edb48a59","hash":"17497e09287eb04d82a13873595b2c1d49c49ccb","modified":1502389313000},{"_id":"themes/13/.git/objects/0b/440382f61f0bb1683e5b15c2a00e4e398f9980","hash":"44808c3eb62e6ee72c611183b3bfb5f4f84a750b","modified":1502389313000},{"_id":"themes/13/.git/objects/0f/b713aa2fa2f4ff694befc191177ff0e7dffd63","hash":"225736aad20ed42af64969ffd5d15e5efd3559c9","modified":1507734405568},{"_id":"themes/13/.git/objects/10/de2c5bae38eb467255d3e47573edc84581515f","hash":"e2a6e9f204e866dc711beef900fd0873dbc97f40","modified":1502671744000},{"_id":"themes/13/.git/objects/13/41f3e370a18688f064745bcc3de4b86a760447","hash":"625232771687889bf455f02dacdbbc91ede79bfd","modified":1502389313000},{"_id":"themes/13/.git/objects/1f/ba460b43891c1ca17ef10c4050e05ca0a6efd3","hash":"d6ba10ce9be05a3c47b2429f849e48f91f2dc773","modified":1502389313000},{"_id":"themes/13/.git/objects/15/9d600425c73c282be34f94af12179f091a16d2","hash":"c92d9ab9e9ccd8493957d1de655bdaf5c38e291e","modified":1502389313000},{"_id":"themes/13/.git/objects/11/0289f2f4b5260ce04dd035408961f1e4f2785b","hash":"9ab545e4728997f085078383f8835a939a46c346","modified":1502389313000},{"_id":"themes/13/.git/objects/11/c188196d5ade55930b7b94fc5a1dd0f6d1a800","hash":"8ae1b6fed8a3837d32ee9cf782c09767cd5e462d","modified":1502389313000},{"_id":"themes/13/.git/objects/39/bf10f676f23262b821b3902ef1b0c8e54f4e10","hash":"d2d2719a63adedcf19b3ca17b3dfffa8c2f030a7","modified":1502671744000},{"_id":"themes/13/.git/objects/30/b740202906c9d0dafe0dd3927740149a615b4c","hash":"b3ac255b9a67dc25746f391ac22a2cf822183e2d","modified":1507734405530},{"_id":"themes/13/.git/objects/33/3ce4820cf4e03192edcd6c5a41755c4dc97bad","hash":"045ba86b369b7f78bebdb444153d6aa57f63e8fb","modified":1502671725000},{"_id":"themes/13/.git/objects/2e/d1a54c957082d7f7336e57a4ae83d817ab9b63","hash":"d5cb8ce5885ec7a4bcc3a49ebae173d2b7f58990","modified":1502389313000},{"_id":"themes/13/.git/objects/45/f5380fbc8743ce7d6067d0c4c30d034c69c317","hash":"7eb5b03f95fba5c385104283368046c21509ef66","modified":1502671744000},{"_id":"themes/13/.git/objects/4a/b0f264d1057fe30fa849917baf94babcfd0938","hash":"0d5ffc50aae8e2f0524ff8dab67f74cebf8e62ff","modified":1508255700144},{"_id":"themes/13/.git/objects/4a/bcb157b236afbc87775e5f8e14b10b41034a40","hash":"fa18109c6a3696ae98d81b9a342b59e76b9cdabc","modified":1507734405566},{"_id":"themes/13/.git/objects/41/e9a8184aa287c5970cc8415e3c5a6310dc9f79","hash":"4f3ea7778b43c1eb583e5d69d37a738ce07f7a57","modified":1502389313000},{"_id":"themes/13/.git/objects/4d/519bfec3b04a13b1584ad6bf9532f8c10f24ee","hash":"7cd4123002c953bffb92b8e48d8f5ad52c0e25f5","modified":1502671744000},{"_id":"themes/13/.git/objects/35/21b0ef2971a96024ebd988c7e0cfafc7f5553b","hash":"1f2a6b7ec5b86f890277d1fa797722f54c7325d8","modified":1502671744000},{"_id":"themes/13/.git/objects/4b/032312f841032fe9ab96a9626b4f026247e1e4","hash":"18c05c6f768995b2dccca5b4fba0d48c509b5cb7","modified":1502389313000},{"_id":"themes/13/.git/objects/45/59bd123243eb4b090a25b133d50ba53089dbf2","hash":"388d2944984001c78221b0114bbc346b4cf7667f","modified":1507391854737},{"_id":"themes/13/.git/objects/44/3fa060fab51d5a32c14061e3793a8348471803","hash":"59ab8903ae12bb848550ff04082b72dc3ca1abca","modified":1502671744000},{"_id":"themes/13/.git/objects/47/9e9af6aefb124c5cb258f24636a1b225dbc9e0","hash":"2998bafb1c21ad100b25847b28e9a3dc2191ed12","modified":1507734405546},{"_id":"themes/13/.git/objects/54/c3c7ce724fcfb84edd50b1f42596b517ae1f59","hash":"2a54ed7c0321426a8fcc987e4691ad1b871d159d","modified":1507391873698},{"_id":"themes/13/.git/objects/5c/24831e3b4e4f4f7431fb9c4f0dadd60f124e7f","hash":"8257ebe9ce73f5b03360d75e802543f5f07f409f","modified":1502671744000},{"_id":"themes/13/.git/objects/52/704e47b853d6619780ca285f58e90da13f22f5","hash":"2163ebdc7a7f543582f2e877094ca0b279a83750","modified":1502389340000},{"_id":"themes/13/.git/objects/49/49bad47d3e22994594660484de0c73042a8744","hash":"327d0f1c8bd5d9932f754ed4773d1475a7130d52","modified":1502389313000},{"_id":"themes/13/.git/objects/60/c80574019f3ce4ac21e254b85537400e55cb4e","hash":"446a8bd595135f714cf48adadd44c5625c5ee659","modified":1511634772278},{"_id":"themes/13/.git/objects/49/a817e6dd851f23efb04dee99910e5a16cbbd92","hash":"9a2daaa22f2db1d055b11cd9bc4de4f4310947c4","modified":1502389313000},{"_id":"themes/13/.git/objects/49/8fc4a087c614614166df2e9f08bb5e0071daf4","hash":"5c1fcc2fea8a027202db52ef389ac142e19c559f","modified":1502389313000},{"_id":"themes/13/.git/objects/68/17f827b3f3ffd3ab75b30e455c576013f1206d","hash":"4057804b82c4e121a9145c93506f021282fafc8a","modified":1502389313000},{"_id":"themes/13/.git/objects/5b/aca9215a1c5491c68f9a041cc51947951fe1a2","hash":"11d96587cd37630f59231344b02dc8299e4506be","modified":1507391854731},{"_id":"themes/13/.git/objects/67/538247cc31f9b5c2958da9d5334fb43f02975f","hash":"e2f8da1a0553bea14293cf548b82fd296129c96d","modified":1508255690925},{"_id":"themes/13/.git/objects/6f/03595f1bca080f23d93034328451ac4c0b67cc","hash":"0ad82cd0105196310edf5338ba96580b2b467570","modified":1507734405578},{"_id":"themes/13/.git/objects/64/3d848fb4b22902bf95c5f9ce6dd1df06779f94","hash":"7e8b37475f442084368ce7c6f97739aac4a108d4","modified":1507734405572},{"_id":"themes/13/.git/objects/5c/cf7e2d961c08bd7146ae8dac24acca3d8cc1a4","hash":"145d1e3e4d314c8776941f672d5e618ddd36abb0","modified":1502389313000},{"_id":"themes/13/.git/objects/73/fcca51987be1454cf2f7a880a333b7d80326bb","hash":"7d8e7a07041a3a7a8e7ddc89a9e1a3cfcca54c20","modified":1511634772275},{"_id":"themes/13/.git/objects/54/0440ce89f2a408aa699b65100e18f15e0f09ca","hash":"2e363893fc6ce9c409347af769daffb3d335096f","modified":1502389313000},{"_id":"themes/13/.git/objects/71/8732773d8c5b076b316c0221a19af638190aa1","hash":"af510bcfeca3331d92ffc140f2b98245c63f56a2","modified":1507734405532},{"_id":"themes/13/.git/objects/72/1acdb78e26cf746a5d80970e7d8e621a9189bc","hash":"56b2af973447a20bfd16f425c4390895ff4106bc","modified":1502389340000},{"_id":"themes/13/.git/objects/66/ad52a5ba052ced428dcc7ec7016bc25438a2ca","hash":"125699e87e53eb0815637a9c803f21f50233351e","modified":1502389313000},{"_id":"themes/13/.git/objects/63/7426f0da6dcef3602d764d9e359dabb4a5a862","hash":"78f8bd636e97c6f5c9f6e1428294a28440b774f9","modified":1502389313000},{"_id":"themes/13/.git/objects/75/cc0637c8dcbe68bec98467659933c969dee4b7","hash":"90b6659bb12897f4676cf365c91bb2223d09ba20","modified":1502389340000},{"_id":"themes/13/.git/objects/7e/92f34a1a51eb86f437760a78187b34558362ec","hash":"b88ed315e43766dc345b51c0503e9f07b185eddc","modified":1502671744000},{"_id":"themes/13/.git/objects/76/11c8decbd6039b49e8c984b853cd7c95d6a4c9","hash":"e8ecb25c62b01e27a5a278dd11b012f960017e85","modified":1502389313000},{"_id":"themes/13/.git/objects/74/25ef85fc80ce6b035065906fc27490715e3733","hash":"16078521b931191896047cb1c3d24dde1a4a6232","modified":1502389313000},{"_id":"themes/13/.git/objects/6e/ec7c5901d8ca4d2ad528f31cb6d82b4fea6635","hash":"284990de5861e0d74c93ec7e683cebbf606b16a0","modified":1502389313000},{"_id":"themes/13/.git/objects/75/0629be544ee7068455a840aa6404e4f48f017c","hash":"66b40af9b38d4d9a6a6d88582348b17df9658789","modified":1507734405542},{"_id":"themes/13/.git/objects/7d/1e4d54d6c293333eb638aa56feba7b62e15564","hash":"7824a66652e35f7aae1d285ba8467bf798ab0a9c","modified":1502389313000},{"_id":"themes/13/.git/objects/84/e6131fa9e14e0ac4e109ae0c7a44cb6c2b6e07","hash":"8bbc51133bc3d18bb123d0a8fbe933a4eeb922e3","modified":1502389478000},{"_id":"themes/13/.git/objects/7d/dbbc0115f5b017bae9f401651f00d824a396b2","hash":"5d27a4a3bd5d82b3ced49ab99f11f23fcc98db17","modified":1502389313000},{"_id":"themes/13/.git/objects/7e/d8b6c3fe4dd27ab61cdfa9ded76e003f888e1e","hash":"000382bbbe00454f6aa1f6a6bdecd3de36801e77","modified":1507734405536},{"_id":"themes/13/.git/objects/85/29e12901e8907d88b5b94ef0566655a6e39976","hash":"e7cbfe66148bfe9c0375ec86f8d5b25c61054b27","modified":1507734405563},{"_id":"themes/13/.git/objects/86/28acbae0a72b856d3978d8b2ea44805caa683c","hash":"82822cb81722ef5a446eb342fa5c0651ef28506e","modified":1507391873695},{"_id":"themes/13/.git/objects/83/5be41f8151b6439f799be29ec7921af1b72593","hash":"9f7fe3876d9088f5f2aeefe42cfde1f644462656","modified":1502389313000},{"_id":"themes/13/.git/objects/83/d083dd770c94ee238774e2df508094ff5cc3a1","hash":"dc212df6983111482746a310bf37147cdcfa142b","modified":1502389313000},{"_id":"themes/13/.git/objects/83/2a1286ff3c7d14880a0d05b4443a37747ded59","hash":"48ef245b802554c429d5fd6c30cefe8d6b5bdfad","modified":1502671744000},{"_id":"themes/13/.git/objects/8a/020dbfff7822bf57c7217eafdaa4884b8aa943","hash":"59fe9b30355730fa043876ad245193537e250657","modified":1502389313000},{"_id":"themes/13/.git/objects/8c/527152dd7424d028fc6480a23ec8756ee3014e","hash":"bb7c7793766ea0f247238e1c41bbf73d4cc75188","modified":1507391873697},{"_id":"themes/13/.git/objects/8b/ec76a63edbae2c4a52a5cabc52bc02c46857e9","hash":"b377fa9b442aa3e2a727abf8a6d143567a297b20","modified":1507734405573},{"_id":"themes/13/.git/objects/8e/b365063e6eecbb468b545345d21239c5cd8847","hash":"21f7339450f0857e0a1d5818c7ef1dc1acfbfb99","modified":1502671744000},{"_id":"themes/13/.git/objects/8b/7183964dff83e1d857ef0af3f83df414aabfdd","hash":"d98897df3fa3faedb0ccda569a4c4a3435308cd6","modified":1507391873697},{"_id":"themes/13/.git/objects/9b/fccf414c8281f030c123d79660ab4a349c648c","hash":"7fbd88869e82b8f03b8082035de8d3c9ad770fdb","modified":1507734405547},{"_id":"themes/13/.git/objects/a3/213d120684b0f8f31eef05bb97c39a710ff945","hash":"dbec61f6a5331037478a9c46134963754d20412f","modified":1507734405534},{"_id":"themes/13/.git/objects/89/c11feae6b6fa1f710f9101fcd9c06ad71f0c31","hash":"f25467d676b7bf235f43fcd96db02fa114417138","modified":1502671744000},{"_id":"themes/13/.git/objects/8a/30cdc378f472e0ae1fc662f96d1df32b5c1ed7","hash":"b425237691402f035d90bf3917cfb3e27480c750","modified":1507391873696},{"_id":"themes/13/.git/objects/a3/558fd09ca7cb968166d5445f4df1a0bc2d5a7e","hash":"4cdd8d9f35bdab170357eecf24d3eebfb9632569","modified":1502389313000},{"_id":"themes/13/.git/objects/a5/4827a99078b7ca2ae2b73a5ea157ef0e946b4a","hash":"3f4eee1171d46459b452a0188f58bef35c76c3b1","modified":1502389340000},{"_id":"themes/13/.git/objects/8c/69792959fbaba96e11c941a8aea6cb84006ad1","hash":"00a73ad1356049d524e0dd9f0b2a2d51cb3451dd","modified":1502671744000},{"_id":"themes/13/.git/objects/9a/56baf6256108c11b6913a62547bcb1ae5fe5da","hash":"b8bfd4e307c87dabefbc1a13966193a7f53ee51d","modified":1502389313000},{"_id":"themes/13/.git/objects/ac/ce9e25d879e3d7a2d712664aa72803b51e9e9a","hash":"b13b7a24c436087a8a2f65a41559dd6995a7a546","modified":1502389474000},{"_id":"themes/13/.git/objects/a0/e54f0498656465f6f91b0d3647b84ff9bc5086","hash":"7d98f3c1dd9c7aeb12ddb6438eeae7d0427bc5d5","modified":1502671744000},{"_id":"themes/13/.git/objects/a3/7777fc3ab49a8db202fdd4851a61c568abcea6","hash":"0a6b9413eb089789e1709e7eaf630cac8e88c56b","modified":1502389313000},{"_id":"themes/13/.git/objects/a9/3a0472ab99eb7839bd06eae17f8ff7b1e8faa3","hash":"f8d96d9e409a2fb8634ad9f242e2382c181a936c","modified":1502389313000},{"_id":"themes/13/.git/objects/a6/14cc84ea37b6bb80f1d0b09ccd784a3bb1694b","hash":"925b7098621a7be65ba15d6e8fd770b758db8557","modified":1502389313000},{"_id":"themes/13/.git/objects/b4/9ce7e9fc60c1e73aad975ef6db580b8c77bb01","hash":"01e8a9639d31329b7eed377911bf657ab164a4e1","modified":1502671744000},{"_id":"themes/13/.git/objects/91/cd8dd4735769aa06ccbb3d74afaa7cb971484c","hash":"0e6984eb5c781e012122292dd0aa9c02c5ebb0e4","modified":1502671744000},{"_id":"themes/13/.git/objects/ae/f7403660c9a2ccc02a264c62c6b105f7d8d532","hash":"783ebd8a3937e86dba3edab4ff97b15523ec01bf","modified":1502389313000},{"_id":"themes/13/.git/objects/a8/b18558d0df8609f0f419d449f4d36540057aef","hash":"b9fe72c253ba4caf943aca0d548b7993746b6a6b","modified":1502671744000},{"_id":"themes/13/.git/objects/b9/35f79e964f533bb2bf3ac5f49da6247e97189c","hash":"2eb1bd2794cf56496627d865d672547732324d65","modified":1511634772279},{"_id":"themes/13/.git/objects/b7/897863631db139de44dc349115dbacaede7e90","hash":"bbdf2a1ad1aace6b8552015b1462a537eb5fda79","modified":1511634772284},{"_id":"themes/13/.git/objects/b1/f0ff347ff69c80dc4448958f17f34cffe35061","hash":"1545dbbe5cb42e6449763514db1f7c2ca669989c","modified":1507391854734},{"_id":"themes/13/.git/objects/b2/21c98133a4d4a8449c848ccb69bf631d1c3e5d","hash":"751c186cfa88415702760ce22b994c8f98798792","modified":1502389313000},{"_id":"themes/13/.git/objects/be/ef231d0e176a47375d93fb7365270eea52f7b4","hash":"b43dd0a75e7fb84e19775280f5f5efc737cc81a7","modified":1502389313000},{"_id":"themes/13/.git/objects/bf/b66701d82bcd213f8b0772c969ee4840677c17","hash":"bdbb1136452394191a27fdf2ff886de05ec36d84","modified":1507734405539},{"_id":"themes/13/.git/objects/bf/c1b4432f0cb993ad81dfdb507136077b93178a","hash":"a123d6d0e8d3ec4c99e6959ed152e909b6984d6b","modified":1502389340000},{"_id":"themes/13/.git/objects/c0/19d7e29eb481027e651e181ecd01a27969d085","hash":"ca0e54f17c809875a1b27e50b929bbacd6d39b26","modified":1502389340000},{"_id":"themes/13/.git/objects/b6/e466f788d8741e51941f04faa48c79b1875aa3","hash":"07b9945d0c0a8e1a2e938f10ab2137120441ec97","modified":1507391854734},{"_id":"themes/13/.git/objects/b3/dea3d67c9b576fe0a1a1168e0bd3aa9298e2e0","hash":"65e3803546c6f6ff37393cb414707d778a73cb94","modified":1507734405544},{"_id":"themes/13/.git/objects/c3/677def3131af54af2a87d9cd2bb737a321e97e","hash":"8b1371ad440b89b7dafe4285deda5bf45c57ccf3","modified":1502389313000},{"_id":"themes/13/.git/objects/bb/457c23a8e4e0688ebd9383e34ab9f2b3acecab","hash":"daeeabb744f3cfddaa97423bddf0188b1f8394c3","modified":1502389313000},{"_id":"themes/13/.git/objects/c3/22899b59a477f4db56af6373ca49a059b96252","hash":"70731ca26ca8777e5205fb485edc3f167ad3ad49","modified":1502389340000},{"_id":"themes/13/.git/objects/c3/bbd5745d35bebda3e16ce18aeff7a4a0ce5ae1","hash":"c25b1e146f0d797128c37f546af173785cce156a","modified":1502389313000},{"_id":"themes/13/.git/objects/c8/38eebaab3764e5b59225da24ef6bc26941b403","hash":"65b637520a3c0bfb3dc19a11b9cb5bea5ae87941","modified":1502671744000},{"_id":"themes/13/.git/objects/c9/682a34b88a5684182619c24e74c5a08d27407e","hash":"464ec5e701d0f1e468486b0d1f32a41536dc2fca","modified":1502389313000},{"_id":"themes/13/.git/objects/cb/2f15921e23b384eae6e5a8c6cf38164fe4711d","hash":"68694ef7c22048d0c0fc86630bb93d5496f9ec27","modified":1511634772273},{"_id":"themes/13/.git/objects/c9/d646770e2186c73632cbe042d82d1d1acaa25b","hash":"0b444b6b4aadb2bd684c7fe3c5f064bf556436a2","modified":1502389313000},{"_id":"themes/13/.git/objects/c5/77ac84a6a55ef39ff7f4e25d60c3977a902ed1","hash":"17863cbe8bfb1776e230138dc2aae3a6553c1195","modified":1502389313000},{"_id":"themes/13/.git/objects/ce/de52e5b81e45c4a0a2c9aa4a0775f7c9040356","hash":"eac3300e35635daf0c3d67de7ce584bef620756f","modified":1502389340000},{"_id":"themes/13/.git/objects/d2/a69f7f6438247b013461d6db908c1901c7007d","hash":"e07290b15e04e362d246db9ee0499d69135408c2","modified":1502389340000},{"_id":"themes/13/.git/objects/d2/b157d0a408274279a0b579b68de52119666def","hash":"6c038efb796a33d147404ff799457ad2a87cd7ef","modified":1502671744000},{"_id":"themes/13/.git/objects/c6/3a617c36f52f644f558183d39546e91519de7b","hash":"ea2ccc3f40644fb057002c58f5c2d11e82d2775b","modified":1502389340000},{"_id":"themes/13/.git/objects/cb/1f02e87da49cdcd189c7417f14cd2caf8651f5","hash":"f44329fe9b4a97d9c84ba0d61454befb945c799c","modified":1502389313000},{"_id":"themes/13/.git/objects/db/6893b33b5397a4825ce3afc56f720f58eca160","hash":"f0b05be288caef6171c35c28a0db1373b6c20731","modified":1507391873705},{"_id":"themes/13/.git/objects/c6/c2ff901473d1599493b79cf8b40400ef9f0b29","hash":"fc05c1002d59e5f25593a70e5c7b0acf8382883d","modified":1507734405537},{"_id":"themes/13/.git/objects/da/417bec0c6921f0df0fb32b4fef367a788174e1","hash":"85f43901ce4b71a5aff58ab708b23aedc59d7204","modified":1502389313000},{"_id":"themes/13/.git/objects/df/32403839a495cdb23de89ce6a7100d52ee564a","hash":"d25503084f8669508ce5b8ba9c78a6b5da4e2790","modified":1502389340000},{"_id":"themes/13/.git/objects/d4/5469da1de1079606b6ce5827f2a72c86cc484f","hash":"e6cc52b2ece73aef281083aa980d0fc9e47cb1f9","modified":1507391854729},{"_id":"themes/13/.git/objects/e5/484e88ea419badc1412cf8b24e7ed02d0709a0","hash":"11daeb0284f7f11b813ac0c8f9cf9de60bba4d6f","modified":1508255700143},{"_id":"themes/13/.git/objects/d3/cfa2ef8af33b33458b703f5441b052925254b8","hash":"ed1f0e349dbe0a651a300ca01614675441062ee1","modified":1502389313000},{"_id":"themes/13/.git/objects/e4/2d230d74e311d7071ca6e7f7ff106f5f240a7b","hash":"f3da819fad2ff5160cb274b84a2967fcaae99692","modified":1507734405541},{"_id":"themes/13/.git/objects/d4/b85a02f24adad8890ad69f7a1db6c7e3ec8a7d","hash":"1dd2dd1cb0c57a3c630ffb82917a8271aa893aef","modified":1502389313000},{"_id":"themes/13/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391","hash":"c2baae88d6364d878fd67e778c6a5d8306ad4ab0","modified":1502389313000},{"_id":"themes/13/.git/objects/e7/df7a0273206883008dce8cef7bfdeebe558365","hash":"c42851e5c1026bf952dbc0e219ec880a00616768","modified":1502389313000},{"_id":"themes/13/.git/objects/ec/852a51888ec9d8a27df373f0a0c912b464868f","hash":"a4ba5b77d9e208dbb27c5433a28091324eeef72a","modified":1508255700139},{"_id":"themes/13/.git/objects/e8/91463d54be6b5408157fd124f46b5bb0b84f07","hash":"5816e30b0b28993a0377f50887a74a99d5f2a5ad","modified":1508255700165},{"_id":"themes/13/.git/objects/e6/3e702c4d9c28fb78922cefa5daf91858b12c9a","hash":"8aaeb94dfaf17e86bce9816322d5f909f7ec133a","modified":1502389313000},{"_id":"themes/13/.git/objects/dd/3c3f42aa1515fe4842746b9ee18d05445c9309","hash":"ce6872a4b33099e816328801f824fa83fb764392","modified":1502389340000},{"_id":"themes/13/.git/objects/f0/095f2d7691bcd8bc80de618e5d1997351504c4","hash":"5a3d010796f3bc82c556b288ea1dce9cbc2eff9f","modified":1507734405544},{"_id":"themes/13/.git/objects/e2/e7ca4f8e7f839a70a49b61441fa09b6beb6158","hash":"8f99567efc865260628de351693090fca5b68571","modified":1502671744000},{"_id":"themes/13/.git/objects/f3/db70e8ef2029c1f486c529c03099051f296ea1","hash":"0f02eceb9e17105cbca3cd2af5eaa2f3ec670421","modified":1511634772276},{"_id":"themes/13/.git/objects/f1/c83aaa5d24da542d81b09677307f47f374401e","hash":"dd32fddf559b48d74a95cf4a8d7e70b08214bd8f","modified":1502389313000},{"_id":"themes/13/.git/objects/ec/3f2aec4b234edab2b76c0ded261e747dd34f74","hash":"d0e9cc7a1609881e4526afa502353cedc9be9b03","modified":1502389313000},{"_id":"themes/13/.git/objects/ef/d7ef7653239aa935a99ba806ac2515f7f0fc00","hash":"9c45f1cbfde2152d0fe731c7e82d34ad6e29137b","modified":1502389469000},{"_id":"themes/13/.git/objects/f1/c8ad75f52bbc6c84a6dc3a341fe39e8d3edfd4","hash":"b8e5a32495a9333b1488805253160f360f4bedda","modified":1502389313000},{"_id":"themes/13/.git/objects/ea/4bc425e6029b82774806fa0535ae90293db270","hash":"94e39d382f67d0f942abde07a63d7b373004e9e0","modified":1502671725000},{"_id":"themes/13/.git/objects/f8/6aae6bb2f043769312861aa759579746cda0bd","hash":"b20d1c6ccba9a184d4d058792e6ce261fe965fef","modified":1502389313000},{"_id":"themes/13/.git/objects/f9/91c69c90e8ce8e0889b523f32dafc028a29408","hash":"12939beb2bae8c4921464e88efb315d5dfab3a1a","modified":1507734405569},{"_id":"themes/13/.git/objects/f9/318c0f223d834110c841e7ff188ae3a21c286d","hash":"d28e975b49ef970ea138e7be36742fd7146e617d","modified":1507734405564},{"_id":"themes/13/.git/objects/ee/906a8196d0fbd581c27a9d5615db4c250860f2","hash":"befed115d962d2da4b6346309224f5d7d521fd37","modified":1502389313000},{"_id":"themes/13/.git/objects/fd/865ec4ce5d0161aa1800bc9af3053752818f54","hash":"1a11a356d8283a38244e1f28a8c5650575592572","modified":1502389340000},{"_id":"themes/13/.git/objects/fb/c3844807bd939a0224171cdfad04689a71cb92","hash":"2e472f536a139d81bfc16c89f9885485ecd2b8be","modified":1508255690926},{"_id":"themes/13/.git/objects/f6/ba81475b92355723f0dc12767f715995a34162","hash":"c1b8cf40e123397d1243bfaaf642eb8ed01dd75a","modified":1502389313000},{"_id":"themes/13/.git/objects/fc/53fb0e7ab49594e1eac97208c32a290558efeb","hash":"285032d48cef23838c362de9cba272fcfbdf7c17","modified":1502389313000},{"_id":"themes/13/source/css/partials/pagination.less","hash":"0f279bc295be2a90af09194b2d37b6867b573ad7","modified":1508651933000},{"_id":"themes/13/source/css/partials/post.less","hash":"39f6293829232b4e213862372b0966e08f9638c0","modified":1507386698785},{"_id":"themes/13/source/css/partials/sidemenu.less","hash":"63b407d0779252db6deae0f038ace7ba72588019","modified":1508651896200},{"_id":"themes/13/source/css/partials/title-info.less","hash":"e7867650c2762db472a9dd89e4b5931e6aad24f8","modified":1507733578330},{"_id":"themes/13/source/js/gitment.js","hash":"34a4d2039b4a142dc36d49f20f1c87b91088a245","modified":1511633982687},{"_id":"themes/13/source/js/gitment.browser.js","hash":"317c8f869ae18cb1ceb6eb25674da8fc4b77ebe6","modified":1511682119388},{"_id":"themes/13/.git/objects/35/acda2fa1196aad98c2adf4378a7611dd713aa3","hash":"c57681ba2ea020d954be3f1723d4626187e66b1f","modified":1502389313000},{"_id":"themes/13/.git/objects/40/0014a4b06eee3d0c0d54402a47ab2601b2862b","hash":"c145ad3ab1a3efcb1c3df4a470813b1b74ea43b8","modified":1502389313000},{"_id":"themes/13/.git/objects/40/1ec0f36e4f73b8efa40bd6f604fe80d286db70","hash":"0688cfde8cff71150bbccd59c4da4aa5f3597a08","modified":1502389313000},{"_id":"themes/13/.git/objects/4d/13fc60404b91e398a37200c4a77b645cfd9586","hash":"213ccde6a68f47c08264f135847ea5a8c3c05905","modified":1502389313000},{"_id":"themes/13/.git/objects/e9/f60ca953f93e35eab4108bd414bc02ddcf3928","hash":"797a4014c9739ab8a1f5bb96e18b7062a53e2f8e","modified":1502389313000},{"_id":"themes/13/.git/logs/refs/heads/master","hash":"45d62c011fb9966c6170668f540101ec67312d70","modified":1513079924883},{"_id":"themes/13/.git/refs/remotes/origin/master","hash":"813124fd31dd311200e552f4e6e7c519aa423917","modified":1508255707358},{"_id":"themes/13/.git/objects/85/5c845e538b65548118279537a04eab2ec6ef0d","hash":"cab9b55bf59bf50fe5d95610e0b53f20a7e5c1bf","modified":1502389313000},{"_id":"themes/13/source/js/gitment.browser.js.map","hash":"3528a36dee76f8e458cfcd593d9459e449a1c213","modified":1511682119437},{"_id":"themes/13/.git/logs/refs/remotes/origin/master","hash":"3533447d4745e894de71a5cb68b0fc89d7a32b0d","modified":1508255707360},{"_id":"public/atom.xml","hash":"3a8d8982400650236ca5d3b430bc654683ffa226","modified":1517467438981},{"_id":"public/about/index.html","hash":"34d5b40fe178a646f37d41fce86c4840b2b7dc26","modified":1513079979023},{"_id":"public/2017/10/24/d3-intro/index.html","hash":"53edb213127729a609e19f3de74e7dedb739442d","modified":1513079979023},{"_id":"public/2017/10/23/bfc-intro/index.html","hash":"2c4b8fbbc7a92fccefce88c5aae6fea9a82d12a4","modified":1513079979024},{"_id":"public/2017/10/18/jenkins-deploy/index.html","hash":"448333ddfbff11946071b2c78dc16043cd807d0c","modified":1513079979024},{"_id":"public/2017/10/17/js-event-trigger/index.html","hash":"92b436d03e6e1f0ba6f21d9e4e960c824b65a4e2","modified":1517467439809},{"_id":"public/2017/10/14/throttle/index.html","hash":"fc604151ed4119df2bd5d520d10c145c7a28f804","modified":1513079979024},{"_id":"public/2017/10/08/简历中的STAR原则/index.html","hash":"a476dfc83fc35a3b77428e8259a4609aa5e0f0e2","modified":1513079979025},{"_id":"public/2017/03/31/vue中如何自定义v-model/index.html","hash":"7831a62643272a0ecce927c9420a37f485ebcb8c","modified":1513079979025},{"_id":"public/2017/08/23/异步编程中的thunk函数/index.html","hash":"0108190cce6fc385aafbc4a90266ba18ddda3657","modified":1513079979025},{"_id":"public/2017/02/09/深入理解javascript线程/index.html","hash":"a02350790b751632a37d08f68d5a7bb49694f4f3","modified":1513079979025},{"_id":"public/2017/01/21/flex布局/index.html","hash":"03230f5cd035e7cce6d4231c14f9f314ebeaff0a","modified":1513079979025},{"_id":"public/2017/01/09/BEM规范/index.html","hash":"ae2633f020dc5b6f4790660f90a3e108a55c9e27","modified":1513079979025},{"_id":"public/2016/12/26/冒泡、选择与插入排序/index.html","hash":"6ce4f300c5c8868c7103981f4d26c65243d15442","modified":1513079979025},{"_id":"public/2016/12/26/求质数的几种方法/index.html","hash":"cc5fa8ce6c6d979ae0f76cb6b126b83250ab6671","modified":1513079979025},{"_id":"public/2016/12/25/nodejs中exports与module-exports的区别/index.html","hash":"4db32e815eaec5d0a42d871ea565b4ecfe6cc70c","modified":1513079979025},{"_id":"public/2016/12/25/python变量作用域/index.html","hash":"345052e4f69b2d40ac03876e545196455301b637","modified":1513079979025},{"_id":"public/2016/12/18/BOM对象的应用/index.html","hash":"555931b8fe81b91f63aee40bf2ecd7ff74813ad5","modified":1513079979025},{"_id":"public/2016/12/11/git-tricks/index.html","hash":"ff5dbbab2dd126e83b33d74b837003bb7cc39be6","modified":1517467439842},{"_id":"public/2016/12/09/js变量申明解析/index.html","hash":"e4461b15c1df5a44ecaa0b43561966fe2eeb98c6","modified":1513079979025},{"_id":"public/2016/12/09/js代理函数技巧/index.html","hash":"388f9a28ad337ef17739f3b30923a7dc3a8feb80","modified":1513079979025},{"_id":"public/2016/11/21/js变量的内存管理/index.html","hash":"1aa9017104de9873ee245b014184af3235454225","modified":1513079979025},{"_id":"public/archives/index.html","hash":"4c7c222e689ba8825a2b5c79d9c2da9728dda0e5","modified":1513079979026},{"_id":"public/archives/page/2/index.html","hash":"77414cfb3973f135c6b96ebd8240f21998560f1b","modified":1513079979026},{"_id":"public/archives/2016/index.html","hash":"3c0ef7cd13c01755344dde37703dfd67c6eb45a0","modified":1513079979026},{"_id":"public/archives/2016/11/index.html","hash":"4d6327dfcaa6e11c5f9e7bff7f2c2cd3ac4c2c46","modified":1513079979026},{"_id":"public/archives/2016/12/index.html","hash":"c07537bd2b8e335f348747075fc6787f12bbf71f","modified":1513079979026},{"_id":"public/archives/2017/index.html","hash":"09e33544b8ff838207984ad74c2f6a1d21a30479","modified":1513079979026},{"_id":"public/archives/2017/page/2/index.html","hash":"24651cfc4a3c28b56702d4b33a1e05a05034fa7c","modified":1513079979026},{"_id":"public/archives/2017/01/index.html","hash":"b1dbe5d7de0663543a61aaa90bca2d15bc0c55e3","modified":1513079979026},{"_id":"public/archives/2017/02/index.html","hash":"33bbfec6f4d5a16680b7c555e95d570e9ebdccb0","modified":1513079979026},{"_id":"public/archives/2017/03/index.html","hash":"66c5b529d3959944377b8e1b35adad7675589952","modified":1513079979026},{"_id":"public/archives/2017/08/index.html","hash":"44e02f9f43fa22c2e0caf3924740b4d5a3537d1c","modified":1513079979026},{"_id":"public/archives/2017/10/index.html","hash":"e6cee9a77b9acd7bc32f7036bdc1762a2cec00e3","modified":1513079979026},{"_id":"public/tags/web/index.html","hash":"a7ff763e513c896329ad6a25a8f8d138ba31884c","modified":1513079979026},{"_id":"public/tags/tricks/index.html","hash":"6ad9976d25903c4660cda9d6d2358c000d58867d","modified":1513079979026},{"_id":"public/tags/js/index.html","hash":"e79d7c3fda9c747e1de5d4733fb9a945877a02e9","modified":1513079979026},{"_id":"public/tags/nodejs/index.html","hash":"886b2050502fb7b1cb0484079e5c6e138845a9a5","modified":1513079979026},{"_id":"public/tags/python/index.html","hash":"3d526664a2548a7c6ff59903c4d170774ccb9ca7","modified":1513079979026},{"_id":"public/tags/vue/index.html","hash":"4a65c8f39fc7efeb13e4f1ef3f9dbe4bddafc4c8","modified":1513079979026},{"_id":"public/index.html","hash":"c761998a8653974e647ea5d493f344cce16e47f1","modified":1517467439842},{"_id":"public/page/2/index.html","hash":"28e9a691d5e4b8a856c464f90bfb6f5b507c6675","modified":1513079979027},{"_id":"public/js/gitment.browser.js","hash":"cde494afe6f90d112489c80386ac9d2c48a446d0","modified":1511682222435},{"_id":"public/js/gitment.browser.js.map","hash":"3528a36dee76f8e458cfcd593d9459e449a1c213","modified":1511682222442},{"_id":"themes/13/.git/objects/0c/c1f7cd3e0a620896fe0c8f9de2f9db0c2a2ee6","hash":"f1a30062005ab5f44385cdfbfa6af104f0aacbce","modified":1513079924870},{"_id":"themes/13/.git/objects/0f/2ace5b799414409cfb2d4afd41835ea6cd6ac8","hash":"98d2ea17711e0e8006996ab0912f91d7a8059fe9","modified":1513079877568},{"_id":"themes/13/.git/objects/2f/5b67016a95ec13fc5f90513bb0a3a18e987755","hash":"933a56a0f24ef328ddf14583f6e16a739a2c0e0d","modified":1513079877565},{"_id":"themes/13/.git/objects/2f/f01c44556bf9861f1c6b15eac80746b5d54df4","hash":"85ae464e4b2ce1b9c5d93b5391f346a9fb16081f","modified":1513079924876},{"_id":"themes/13/.git/objects/31/d83f7da4b6680c625005985e905addd15dec6c","hash":"eac6d48f2f498870c37368a2484ee1ae371d836c","modified":1513079924881},{"_id":"themes/13/.git/objects/36/a04a08b8f234b934fb898e5dcdd3c12833af7b","hash":"d39491c727a91f6a1003b0dfbf86b7a2c9fad5c5","modified":1513079924872},{"_id":"themes/13/.git/objects/64/14cd970fef33578e0b10307a71ada2ee765f1f","hash":"f99631d1586e4dd8c7c68738fc43c7f2f9ec9c64","modified":1513079924877},{"_id":"themes/13/.git/objects/82/7fae6030778f22866d32022baabcc0b84c53cd","hash":"7e08eaca7820aaded59906f88ff8bd194c6f85d4","modified":1513079877570},{"_id":"themes/13/.git/objects/b3/512130fdbfca68acf92325491ca7d63d7a628f","hash":"175d5bc838e0014c852e29a7fb19ecd5aa9d3ad3","modified":1513079924872},{"_id":"themes/13/.git/objects/b8/2b0d3e6c23a16340ba40380e61cff51a9b4718","hash":"8c4dbacd86e8db1c0d658abe04102f18b52caa67","modified":1513079924874},{"_id":"themes/13/.git/objects/c1/4457ca0d8d89a3ca8d611f24c850c4c38671ea","hash":"9db0f2d9450fc234025713a584605c2707c8bd5f","modified":1513079924875},{"_id":"themes/13/.git/objects/db/ae55c8aa2b8426fe500ffb5a372e1dc02dbca3","hash":"2e122fea9fcd0b2d24bd9975d040d33550a734da","modified":1513079877572},{"_id":"themes/13/.git/objects/e4/4e2ba5b3676319746ca2d52f5cf20bed04c035","hash":"00de8997c464c78a1da840a873d9e846bb28b5ea","modified":1513079877583},{"_id":"themes/13/.git/objects/ea/d2951d6892b14cb614a6fa9d38b309af5cf6f5","hash":"1c2bcc446b0c58e9c4600816d2807b8b36f91a21","modified":1513079877574},{"_id":"themes/13/.git/objects/37/3dabd18df3b673fbb327f8346f6e57063b9b18","hash":"2a2d48bd1b8a2847e38bcac99128687668460d30","modified":1513079877596},{"_id":"public/css/vv13.css","hash":"890d610a08704e16daaae15411d22bf1ffbbab95","modified":1513079979107}],"Category":[],"Data":[],"Page":[{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2017-11-25T15:29:55.130Z","updated":"2017-11-25T15:29:55.130Z","path":"about/index.html","comments":1,"_id":"cjaggj8ap0001nuc3ec4tskdh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"flex布局","date":"2017-01-21T11:50:00.000Z","_content":"\n## 简介\nflex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。\n\n它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。\n\n设置容器为flex布局，只需要设置`display: flex`即可。它将具有以下特性：\n1. 子元素float、clear、vertical-align将失效。\n2. 存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。\n\n## 概念\n![](/imgs/flex布局.png)\n#### 轴线\n+ 主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。\n+ 交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。\n\n#### flex 属性：\n+ flex-direction，设置主轴的方向\n+ flex-wrap，项目是否多行显示\n+ flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap\n+ justify-content，项目在主轴上的对齐方式\n+ align-items，项目在交叉轴上的对齐方式\n+ align-content，多根轴线的对其方式，对只有一根轴线的无效\n\n#### flex item属性：\n+ order，项目的权重，数值越小排列越靠前\n+ flex-grow，项目的放大比例，默认为0不放大\n+ flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小\n+ flex-basis，项目本身的大小，和width、height类似\n+ flex，flex-grow、flex-shrink和flex-basis属性的简写\n+ align-self，设置项目自身的对其方式，覆盖align-items属性\n\n各项详细配置，请参照阮老师的[语法文章](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n## Usage\n> [vv13.cn/flex-demo](http://vv13.cn/flex-demo)\n\n文字不便描述，直接访问在线app示例吧，这里是[github地址](https://github.com/vv13/flex-demo.git)～\n","source":"_posts/flex布局.md","raw":"---\nlayout: post\ntitle: flex布局\ndate: 2017/01/21 19:50:00\ntags: web\n---\n\n## 简介\nflex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。\n\n它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。\n\n设置容器为flex布局，只需要设置`display: flex`即可。它将具有以下特性：\n1. 子元素float、clear、vertical-align将失效。\n2. 存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。\n\n## 概念\n![](/imgs/flex布局.png)\n#### 轴线\n+ 主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。\n+ 交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。\n\n#### flex 属性：\n+ flex-direction，设置主轴的方向\n+ flex-wrap，项目是否多行显示\n+ flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap\n+ justify-content，项目在主轴上的对齐方式\n+ align-items，项目在交叉轴上的对齐方式\n+ align-content，多根轴线的对其方式，对只有一根轴线的无效\n\n#### flex item属性：\n+ order，项目的权重，数值越小排列越靠前\n+ flex-grow，项目的放大比例，默认为0不放大\n+ flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小\n+ flex-basis，项目本身的大小，和width、height类似\n+ flex，flex-grow、flex-shrink和flex-basis属性的简写\n+ align-self，设置项目自身的对其方式，覆盖align-items属性\n\n各项详细配置，请参照阮老师的[语法文章](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n## Usage\n> [vv13.cn/flex-demo](http://vv13.cn/flex-demo)\n\n文字不便描述，直接访问在线app示例吧，这里是[github地址](https://github.com/vv13/flex-demo.git)～\n","slug":"flex布局","published":1,"updated":"2017-10-08T13:58:04.607Z","comments":1,"photos":[],"link":"","_id":"cjaggj8ah0000nuc3l5n535t5","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>flex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。</p>\n<p>它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。</p>\n<p>设置容器为flex布局，只需要设置<code>display: flex</code>即可。它将具有以下特性：</p>\n<ol>\n<li>子元素float、clear、vertical-align将失效。</li>\n<li>存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。</li>\n</ol>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><img src=\"/imgs/flex布局.png\" alt=\"\"></p>\n<h4 id=\"轴线\"><a href=\"#轴线\" class=\"headerlink\" title=\"轴线\"></a>轴线</h4><ul>\n<li>主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。</li>\n<li>交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。</li>\n</ul>\n<h4 id=\"flex-属性：\"><a href=\"#flex-属性：\" class=\"headerlink\" title=\"flex 属性：\"></a>flex 属性：</h4><ul>\n<li>flex-direction，设置主轴的方向</li>\n<li>flex-wrap，项目是否多行显示</li>\n<li>flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap</li>\n<li>justify-content，项目在主轴上的对齐方式</li>\n<li>align-items，项目在交叉轴上的对齐方式</li>\n<li>align-content，多根轴线的对其方式，对只有一根轴线的无效</li>\n</ul>\n<h4 id=\"flex-item属性：\"><a href=\"#flex-item属性：\" class=\"headerlink\" title=\"flex item属性：\"></a>flex item属性：</h4><ul>\n<li>order，项目的权重，数值越小排列越靠前</li>\n<li>flex-grow，项目的放大比例，默认为0不放大</li>\n<li>flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小</li>\n<li>flex-basis，项目本身的大小，和width、height类似</li>\n<li>flex，flex-grow、flex-shrink和flex-basis属性的简写</li>\n<li>align-self，设置项目自身的对其方式，覆盖align-items属性</li>\n</ul>\n<p>各项详细配置，请参照阮老师的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"external\">语法文章</a>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p><a href=\"http://vv13.cn/flex-demo\" target=\"_blank\" rel=\"external\">vv13.cn/flex-demo</a></p>\n</blockquote>\n<p>文字不便描述，直接访问在线app示例吧，这里是<a href=\"https://github.com/vv13/flex-demo.git\" target=\"_blank\" rel=\"external\">github地址</a>～</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>flex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。</p>\n<p>它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。</p>\n<p>设置容器为flex布局，只需要设置<code>display: flex</code>即可。它将具有以下特性：</p>\n<ol>\n<li>子元素float、clear、vertical-align将失效。</li>\n<li>存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。</li>\n</ol>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><img src=\"/imgs/flex布局.png\" alt=\"\"></p>\n<h4 id=\"轴线\"><a href=\"#轴线\" class=\"headerlink\" title=\"轴线\"></a>轴线</h4><ul>\n<li>主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。</li>\n<li>交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。</li>\n</ul>\n<h4 id=\"flex-属性：\"><a href=\"#flex-属性：\" class=\"headerlink\" title=\"flex 属性：\"></a>flex 属性：</h4><ul>\n<li>flex-direction，设置主轴的方向</li>\n<li>flex-wrap，项目是否多行显示</li>\n<li>flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap</li>\n<li>justify-content，项目在主轴上的对齐方式</li>\n<li>align-items，项目在交叉轴上的对齐方式</li>\n<li>align-content，多根轴线的对其方式，对只有一根轴线的无效</li>\n</ul>\n<h4 id=\"flex-item属性：\"><a href=\"#flex-item属性：\" class=\"headerlink\" title=\"flex item属性：\"></a>flex item属性：</h4><ul>\n<li>order，项目的权重，数值越小排列越靠前</li>\n<li>flex-grow，项目的放大比例，默认为0不放大</li>\n<li>flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小</li>\n<li>flex-basis，项目本身的大小，和width、height类似</li>\n<li>flex，flex-grow、flex-shrink和flex-basis属性的简写</li>\n<li>align-self，设置项目自身的对其方式，覆盖align-items属性</li>\n</ul>\n<p>各项详细配置，请参照阮老师的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"external\">语法文章</a>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p><a href=\"http://vv13.cn/flex-demo\" target=\"_blank\" rel=\"external\">vv13.cn/flex-demo</a></p>\n</blockquote>\n<p>文字不便描述，直接访问在线app示例吧，这里是<a href=\"https://github.com/vv13/flex-demo.git\" target=\"_blank\" rel=\"external\">github地址</a>～</p>\n"},{"layout":"post","title":"BEM规范","date":"2017-01-09T14:27:27.000Z","_content":"\n## 什么是BEM？\nblock(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。\n\n\n## 语法\n```\n.block {} // 块\n.block__element {} // 块所属元素\n.block__element--modifier {} // 块所属元素的状态\n```\n\n\n## 与sass结合\n### &\n通过&会直接引用父元素，嵌套使用&可以增强可读性：\n```\n.block {\n  &__element1 {}\n  &__element2 {}\n}\n```\n\n### extend\n如下html：\n```\n<ul>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item--active\"></li> <!-- 梦想 -->\n  <li class=\"nav__item nav__item--active\"></li> <!-- 现实 -->\n</ul>\n```\n\nextend可以继承类的所有定义，于是可以这样消除冗余：\n```\n.nav {\n  ...\n  &__item {\n    ...\n    &--active {\n      @extend .nav__item;\n      ...\n    }\n  }\n}\n```\n\n## css module...\ncss module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：\n### 书写麻烦\n使用css module引入的标签：\n```\n<div className={classnames(style['class1__child'], style['class2']}></div>\n```\n\n而使用import导入bem类会是这样的：\n```\n<div className=\"class1__child class2\"></div>\n```\n\n### 测试\n写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～\n\n### 编译工具\nsass、less我是不想舍弃～\n\n\n## TODO\n1. BEM的优点\n2. 补充说明\n","source":"_posts/BEM规范.md","raw":"---\nlayout: post\ntitle: BEM规范\ndate: 2017/01/09 22:27:27\ntags: tricks\n---\n\n## 什么是BEM？\nblock(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。\n\n\n## 语法\n```\n.block {} // 块\n.block__element {} // 块所属元素\n.block__element--modifier {} // 块所属元素的状态\n```\n\n\n## 与sass结合\n### &\n通过&会直接引用父元素，嵌套使用&可以增强可读性：\n```\n.block {\n  &__element1 {}\n  &__element2 {}\n}\n```\n\n### extend\n如下html：\n```\n<ul>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item--active\"></li> <!-- 梦想 -->\n  <li class=\"nav__item nav__item--active\"></li> <!-- 现实 -->\n</ul>\n```\n\nextend可以继承类的所有定义，于是可以这样消除冗余：\n```\n.nav {\n  ...\n  &__item {\n    ...\n    &--active {\n      @extend .nav__item;\n      ...\n    }\n  }\n}\n```\n\n## css module...\ncss module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：\n### 书写麻烦\n使用css module引入的标签：\n```\n<div className={classnames(style['class1__child'], style['class2']}></div>\n```\n\n而使用import导入bem类会是这样的：\n```\n<div className=\"class1__child class2\"></div>\n```\n\n### 测试\n写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～\n\n### 编译工具\nsass、less我是不想舍弃～\n\n\n## TODO\n1. BEM的优点\n2. 补充说明\n","slug":"BEM规范","published":1,"updated":"2017-10-08T13:58:08.988Z","comments":1,"photos":[],"link":"","_id":"cjaggj8at0002nuc3dm7cenc7","content":"<h2 id=\"什么是BEM？\"><a href=\"#什么是BEM？\" class=\"headerlink\" title=\"什么是BEM？\"></a>什么是BEM？</h2><p>block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;&#125; // 块</div><div class=\"line\">.block__element &#123;&#125; // 块所属元素</div><div class=\"line\">.block__element--modifier &#123;&#125; // 块所属元素的状态</div></pre></td></tr></table></figure>\n<h2 id=\"与sass结合\"><a href=\"#与sass结合\" class=\"headerlink\" title=\"与sass结合\"></a>与sass结合</h2><h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>通过&amp;会直接引用父元素，嵌套使用&amp;可以增强可读性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;</div><div class=\"line\">  &amp;__element1 &#123;&#125;</div><div class=\"line\">  &amp;__element2 &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h3><p>如下html：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 梦想 --&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 现实 --&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>extend可以继承类的所有定义，于是可以这样消除冗余：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.nav &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &amp;__item &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    &amp;--active &#123;</div><div class=\"line\">      @extend .nav__item;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"css-module…\"><a href=\"#css-module…\" class=\"headerlink\" title=\"css module…\"></a>css module…</h2><p>css module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：</p>\n<h3 id=\"书写麻烦\"><a href=\"#书写麻烦\" class=\"headerlink\" title=\"书写麻烦\"></a>书写麻烦</h3><p>使用css module引入的标签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&#123;classnames(style[&apos;class1__child&apos;], style[&apos;class2&apos;]&#125;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>而使用import导入bem类会是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&quot;class1__child class2&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～</p>\n<h3 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h3><p>sass、less我是不想舍弃～</p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ol>\n<li>BEM的优点</li>\n<li>补充说明</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是BEM？\"><a href=\"#什么是BEM？\" class=\"headerlink\" title=\"什么是BEM？\"></a>什么是BEM？</h2><p>block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;&#125; // 块</div><div class=\"line\">.block__element &#123;&#125; // 块所属元素</div><div class=\"line\">.block__element--modifier &#123;&#125; // 块所属元素的状态</div></pre></td></tr></table></figure>\n<h2 id=\"与sass结合\"><a href=\"#与sass结合\" class=\"headerlink\" title=\"与sass结合\"></a>与sass结合</h2><h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>通过&amp;会直接引用父元素，嵌套使用&amp;可以增强可读性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;</div><div class=\"line\">  &amp;__element1 &#123;&#125;</div><div class=\"line\">  &amp;__element2 &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h3><p>如下html：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 梦想 --&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 现实 --&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>extend可以继承类的所有定义，于是可以这样消除冗余：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.nav &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &amp;__item &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    &amp;--active &#123;</div><div class=\"line\">      @extend .nav__item;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"css-module…\"><a href=\"#css-module…\" class=\"headerlink\" title=\"css module…\"></a>css module…</h2><p>css module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：</p>\n<h3 id=\"书写麻烦\"><a href=\"#书写麻烦\" class=\"headerlink\" title=\"书写麻烦\"></a>书写麻烦</h3><p>使用css module引入的标签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&#123;classnames(style[&apos;class1__child&apos;], style[&apos;class2&apos;]&#125;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>而使用import导入bem类会是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&quot;class1__child class2&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～</p>\n<h3 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h3><p>sass、less我是不想舍弃～</p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ol>\n<li>BEM的优点</li>\n<li>补充说明</li>\n</ol>\n"},{"layout":"post","title":"BOM对象的应用","date":"2016-12-18T12:24:59.000Z","_content":"\nBOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：\n+ 跳转到新的网址：`window.location.href = 'http://www.google.com';`\n+ 打开新的窗体：`window.open('http://www.google.com');`\n+ 刷新页面：`window.location.reload();`\n+ 后退：`window.history.back();`\n+ 前进：`window.history.forward();`\n\n#### 子窗体与父窗体对象的引用\n考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：\n\n```\nfunction dealOk() {\n  window.opener.location.reload();\n  window.close();\n}\n```\n\n若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：\n\n```\n\n// showPopup会返回window对象，原理是window.open()方法的调用\nconst childrenWindow = QC.Login.showPopup({\n  appId: APPID,\n  redirectURI: REDIRECT_URI,\n});\n\nconst timer = setInterval(() => {\n\n  // 查看窗体是否被关闭\n  if (childrenWindow.closed) {\n    clearInterval(timer); // 清除轮询\n    window.location.reload(); // 刷新页面\n  }\n},500);\n```\n\n#### a标签阻止其跳转\n将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行`;`直接返回undefined：\n\n+ `<a href=\"javascript:void(0);\">点击不会进行跳转</a>`\n+ `<a href=\"javascript:;\">点击不会进行跳转</a>`\n","source":"_posts/BOM对象的应用.md","raw":"---\nlayout: post\ntitle: BOM对象的应用\ndate: 2016/12/18 20:24:59\ntags: js\n---\n\nBOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：\n+ 跳转到新的网址：`window.location.href = 'http://www.google.com';`\n+ 打开新的窗体：`window.open('http://www.google.com');`\n+ 刷新页面：`window.location.reload();`\n+ 后退：`window.history.back();`\n+ 前进：`window.history.forward();`\n\n#### 子窗体与父窗体对象的引用\n考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：\n\n```\nfunction dealOk() {\n  window.opener.location.reload();\n  window.close();\n}\n```\n\n若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：\n\n```\n\n// showPopup会返回window对象，原理是window.open()方法的调用\nconst childrenWindow = QC.Login.showPopup({\n  appId: APPID,\n  redirectURI: REDIRECT_URI,\n});\n\nconst timer = setInterval(() => {\n\n  // 查看窗体是否被关闭\n  if (childrenWindow.closed) {\n    clearInterval(timer); // 清除轮询\n    window.location.reload(); // 刷新页面\n  }\n},500);\n```\n\n#### a标签阻止其跳转\n将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行`;`直接返回undefined：\n\n+ `<a href=\"javascript:void(0);\">点击不会进行跳转</a>`\n+ `<a href=\"javascript:;\">点击不会进行跳转</a>`\n","slug":"BOM对象的应用","published":1,"updated":"2017-10-08T13:58:37.266Z","comments":1,"photos":[],"link":"","_id":"cjaggj8b50004nuc39ylb76uc","content":"<p>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：</p>\n<ul>\n<li>跳转到新的网址：<code>window.location.href = &#39;http://www.google.com&#39;;</code></li>\n<li>打开新的窗体：<code>window.open(&#39;http://www.google.com&#39;);</code></li>\n<li>刷新页面：<code>window.location.reload();</code></li>\n<li>后退：<code>window.history.back();</code></li>\n<li>前进：<code>window.history.forward();</code></li>\n</ul>\n<h4 id=\"子窗体与父窗体对象的引用\"><a href=\"#子窗体与父窗体对象的引用\" class=\"headerlink\" title=\"子窗体与父窗体对象的引用\"></a>子窗体与父窗体对象的引用</h4><p>考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function dealOk() &#123;</div><div class=\"line\">  window.opener.location.reload();</div><div class=\"line\">  window.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// showPopup会返回window对象，原理是window.open()方法的调用</div><div class=\"line\">const childrenWindow = QC.Login.showPopup(&#123;</div><div class=\"line\">  appId: APPID,</div><div class=\"line\">  redirectURI: REDIRECT_URI,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">const timer = setInterval(() =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">  // 查看窗体是否被关闭</div><div class=\"line\">  if (childrenWindow.closed) &#123;</div><div class=\"line\">    clearInterval(timer); // 清除轮询</div><div class=\"line\">    window.location.reload(); // 刷新页面</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,500);</div></pre></td></tr></table></figure>\n<h4 id=\"a标签阻止其跳转\"><a href=\"#a标签阻止其跳转\" class=\"headerlink\" title=\"a标签阻止其跳转\"></a>a标签阻止其跳转</h4><p>将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行<code>;</code>直接返回undefined：</p>\n<ul>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n<li><code>&lt;a href=&quot;javascript:;&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：</p>\n<ul>\n<li>跳转到新的网址：<code>window.location.href = &#39;http://www.google.com&#39;;</code></li>\n<li>打开新的窗体：<code>window.open(&#39;http://www.google.com&#39;);</code></li>\n<li>刷新页面：<code>window.location.reload();</code></li>\n<li>后退：<code>window.history.back();</code></li>\n<li>前进：<code>window.history.forward();</code></li>\n</ul>\n<h4 id=\"子窗体与父窗体对象的引用\"><a href=\"#子窗体与父窗体对象的引用\" class=\"headerlink\" title=\"子窗体与父窗体对象的引用\"></a>子窗体与父窗体对象的引用</h4><p>考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function dealOk() &#123;</div><div class=\"line\">  window.opener.location.reload();</div><div class=\"line\">  window.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// showPopup会返回window对象，原理是window.open()方法的调用</div><div class=\"line\">const childrenWindow = QC.Login.showPopup(&#123;</div><div class=\"line\">  appId: APPID,</div><div class=\"line\">  redirectURI: REDIRECT_URI,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">const timer = setInterval(() =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">  // 查看窗体是否被关闭</div><div class=\"line\">  if (childrenWindow.closed) &#123;</div><div class=\"line\">    clearInterval(timer); // 清除轮询</div><div class=\"line\">    window.location.reload(); // 刷新页面</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,500);</div></pre></td></tr></table></figure>\n<h4 id=\"a标签阻止其跳转\"><a href=\"#a标签阻止其跳转\" class=\"headerlink\" title=\"a标签阻止其跳转\"></a>a标签阻止其跳转</h4><p>将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行<code>;</code>直接返回undefined：</p>\n<ul>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n<li><code>&lt;a href=&quot;javascript:;&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n</ul>\n"},{"layout":"post","title":"git实用命令技巧","date":"2016-12-11T15:59:21.000Z","_content":"\n## git pull --rebase\n从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：\n\n![](/imgs/git实用命令技巧-1.png)\n\n我们期望的分支图也许时这样的：\n\n![](/imgs/git实用命令技巧-2.png)\n\n只需要将git pull -> git pull --rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:\n```\n合并前：\n        D---E master\n      /\nA---B---C---F origin/master\n\nmerge合并：\n    D--------E  \n  /           \\\nA---B---C---F---G   master, origin/master\n\nrebase合并：\nA---B---C---F---D---E   master, origin/master\n```\n\n如果遇到冲突，请将冲突解决后执行: `git rebase --continue`。它也有两面性，至于谁好谁坏，慎用就行了。\n\n## git commit --amend\n有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。\n\n## 获取远程库的更新\n普通的工作流程一般是先folk整个工程到本地，再添加上游分支：\n```\ngit remote add upstream https://xxx.git\n```\n\n这样一来，我们就可以获取远程的更新到当前分支：\n```\ngit pull upstream master\n```\n\n若拉取本地不存在的分支，则可以使用这条命令：\n```\ngit checkout -b new_branch upstream/new_branch\n```\n\n## 推送多个远程库\n用法：\n\n```\n$ vim ~/.git/config\n\n[remote \"upstream\"]\n        url = git@gitlab.main.com:project.git\n        url = git@github.main.com:project.git\n\n$ git push upstream\n```\n\n解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。\n\n## 合并多个提交\n有些时候，本地会做多个commit提交，但是在push之前，合并为1个提交会显得更清晰，此时就需要借助`git rebase -i HEAD~N`了，其中N代表的是最近几次提交，执行后将需要合并的commit从pick改为squash，再重写提交记录即可。\n\n## 更改提交人\n在有一次和小伙伴协作代码时，由于需要伪造成同一个身份，让代码管理者看commit历史以为是同一个人做的，因此就用到了--author参数，提交的格式为：`name<mail>`，比如：`git commit -m 'feat: something' --author=\"TJ<mail@gmail.com>\"`，这是通过git log即可看到作者信息发生了变化。\n\n## Tag\n通常发布版本时，会为当前的时间线打上标签，这样可以快速对不同的版本进行查看。\n#### 创建标签\n1. git tag TAG_NAME，列出标签\n2. git tag -a  TAG_NAME -m 'DESC'，添加附注标签，若不需要信息则去掉-a -m\b参数\n3. git tag TAG_NAME COMMIT_VERSIONT，给某条提交记录打Tag\n\n#### 查看标签\n1. git tag，列出所有标签名称\n2. git show TAG_NAME，显示tag信息\n\n#### 推送标签\n默认情况，标签信息是存在本地的，若要推送到服务器，则需使用`git push origin --tags`。\n\n#### 检出标签\nGit的Tag只是一个标记，若要切换到标签对应commit，可以通过`git show TAG_NAME`找到对用的提交信息，再执行相关操作。也可checkout出一个分支与tag对应分支同步：\n```\n$ git checkout -b [branchname] [tagname]\nSwitched to a new branch 'branchname'\n```\n","source":"_posts/git-tricks.md","raw":"---\nlayout: post\ntitle: git实用命令技巧\ndate: 2016/12/11 23:59:21\ntags: tricks\n---\n\n## git pull --rebase\n从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：\n\n![](/imgs/git实用命令技巧-1.png)\n\n我们期望的分支图也许时这样的：\n\n![](/imgs/git实用命令技巧-2.png)\n\n只需要将git pull -> git pull --rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:\n```\n合并前：\n        D---E master\n      /\nA---B---C---F origin/master\n\nmerge合并：\n    D--------E  \n  /           \\\nA---B---C---F---G   master, origin/master\n\nrebase合并：\nA---B---C---F---D---E   master, origin/master\n```\n\n如果遇到冲突，请将冲突解决后执行: `git rebase --continue`。它也有两面性，至于谁好谁坏，慎用就行了。\n\n## git commit --amend\n有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。\n\n## 获取远程库的更新\n普通的工作流程一般是先folk整个工程到本地，再添加上游分支：\n```\ngit remote add upstream https://xxx.git\n```\n\n这样一来，我们就可以获取远程的更新到当前分支：\n```\ngit pull upstream master\n```\n\n若拉取本地不存在的分支，则可以使用这条命令：\n```\ngit checkout -b new_branch upstream/new_branch\n```\n\n## 推送多个远程库\n用法：\n\n```\n$ vim ~/.git/config\n\n[remote \"upstream\"]\n        url = git@gitlab.main.com:project.git\n        url = git@github.main.com:project.git\n\n$ git push upstream\n```\n\n解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。\n\n## 合并多个提交\n有些时候，本地会做多个commit提交，但是在push之前，合并为1个提交会显得更清晰，此时就需要借助`git rebase -i HEAD~N`了，其中N代表的是最近几次提交，执行后将需要合并的commit从pick改为squash，再重写提交记录即可。\n\n## 更改提交人\n在有一次和小伙伴协作代码时，由于需要伪造成同一个身份，让代码管理者看commit历史以为是同一个人做的，因此就用到了--author参数，提交的格式为：`name<mail>`，比如：`git commit -m 'feat: something' --author=\"TJ<mail@gmail.com>\"`，这是通过git log即可看到作者信息发生了变化。\n\n## Tag\n通常发布版本时，会为当前的时间线打上标签，这样可以快速对不同的版本进行查看。\n#### 创建标签\n1. git tag TAG_NAME，列出标签\n2. git tag -a  TAG_NAME -m 'DESC'，添加附注标签，若不需要信息则去掉-a -m\b参数\n3. git tag TAG_NAME COMMIT_VERSIONT，给某条提交记录打Tag\n\n#### 查看标签\n1. git tag，列出所有标签名称\n2. git show TAG_NAME，显示tag信息\n\n#### 推送标签\n默认情况，标签信息是存在本地的，若要推送到服务器，则需使用`git push origin --tags`。\n\n#### 检出标签\nGit的Tag只是一个标记，若要切换到标签对应commit，可以通过`git show TAG_NAME`找到对用的提交信息，再执行相关操作。也可checkout出一个分支与tag对应分支同步：\n```\n$ git checkout -b [branchname] [tagname]\nSwitched to a new branch 'branchname'\n```\n","slug":"git-tricks","published":1,"updated":"2018-02-01T06:43:29.783Z","_id":"cjaggj8b70005nuc3olf1vkgf","comments":1,"photos":[],"link":"","content":"<h2 id=\"git-pull-–rebase\"><a href=\"#git-pull-–rebase\" class=\"headerlink\" title=\"git pull –rebase\"></a>git pull –rebase</h2><p>从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：</p>\n<p><img src=\"/imgs/git实用命令技巧-1.png\" alt=\"\"></p>\n<p>我们期望的分支图也许时这样的：</p>\n<p><img src=\"/imgs/git实用命令技巧-2.png\" alt=\"\"></p>\n<p>只需要将git pull -&gt; git pull –rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">合并前：</div><div class=\"line\">        D---E master</div><div class=\"line\">      /</div><div class=\"line\">A---B---C---F origin/master</div><div class=\"line\"></div><div class=\"line\">merge合并：</div><div class=\"line\">    D--------E  </div><div class=\"line\">  /           \\</div><div class=\"line\">A---B---C---F---G   master, origin/master</div><div class=\"line\"></div><div class=\"line\">rebase合并：</div><div class=\"line\">A---B---C---F---D---E   master, origin/master</div></pre></td></tr></table></figure></p>\n<p>如果遇到冲突，请将冲突解决后执行: <code>git rebase --continue</code>。它也有两面性，至于谁好谁坏，慎用就行了。</p>\n<h2 id=\"git-commit-–amend\"><a href=\"#git-commit-–amend\" class=\"headerlink\" title=\"git commit –amend\"></a>git commit –amend</h2><p>有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。</p>\n<h2 id=\"获取远程库的更新\"><a href=\"#获取远程库的更新\" class=\"headerlink\" title=\"获取远程库的更新\"></a>获取远程库的更新</h2><p>普通的工作流程一般是先folk整个工程到本地，再添加上游分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add upstream https://xxx.git</div></pre></td></tr></table></figure></p>\n<p>这样一来，我们就可以获取远程的更新到当前分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull upstream master</div></pre></td></tr></table></figure></p>\n<p>若拉取本地不存在的分支，则可以使用这条命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b new_branch upstream/new_branch</div></pre></td></tr></table></figure></p>\n<h2 id=\"推送多个远程库\"><a href=\"#推送多个远程库\" class=\"headerlink\" title=\"推送多个远程库\"></a>推送多个远程库</h2><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim ~/.git/config</div><div class=\"line\"></div><div class=\"line\">[remote &quot;upstream&quot;]</div><div class=\"line\">        url = git@gitlab.main.com:project.git</div><div class=\"line\">        url = git@github.main.com:project.git</div><div class=\"line\"></div><div class=\"line\">$ git push upstream</div></pre></td></tr></table></figure>\n<p>解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。</p>\n<h2 id=\"合并多个提交\"><a href=\"#合并多个提交\" class=\"headerlink\" title=\"合并多个提交\"></a>合并多个提交</h2><p>有些时候，本地会做多个commit提交，但是在push之前，合并为1个提交会显得更清晰，此时就需要借助<code>git rebase -i HEAD~N</code>了，其中N代表的是最近几次提交，执行后将需要合并的commit从pick改为squash，再重写提交记录即可。</p>\n<h2 id=\"更改提交人\"><a href=\"#更改提交人\" class=\"headerlink\" title=\"更改提交人\"></a>更改提交人</h2><p>在有一次和小伙伴协作代码时，由于需要伪造成同一个身份，让代码管理者看commit历史以为是同一个人做的，因此就用到了–author参数，提交的格式为：<code>name&lt;mail&gt;</code>，比如：<code>git commit -m &#39;feat: something&#39; --author=&quot;TJ&lt;mail@gmail.com&gt;&quot;</code>，这是通过git log即可看到作者信息发生了变化。</p>\n<h2 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h2><p>通常发布版本时，会为当前的时间线打上标签，这样可以快速对不同的版本进行查看。</p>\n<h4 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h4><ol>\n<li>git tag TAG_NAME，列出标签</li>\n<li>git tag -a  TAG_NAME -m ‘DESC’，添加附注标签，若不需要信息则去掉-a -m\b参数</li>\n<li>git tag TAG_NAME COMMIT_VERSIONT，给某条提交记录打Tag</li>\n</ol>\n<h4 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h4><ol>\n<li>git tag，列出所有标签名称</li>\n<li>git show TAG_NAME，显示tag信息</li>\n</ol>\n<h4 id=\"推送标签\"><a href=\"#推送标签\" class=\"headerlink\" title=\"推送标签\"></a>推送标签</h4><p>默认情况，标签信息是存在本地的，若要推送到服务器，则需使用<code>git push origin --tags</code>。</p>\n<h4 id=\"检出标签\"><a href=\"#检出标签\" class=\"headerlink\" title=\"检出标签\"></a>检出标签</h4><p>Git的Tag只是一个标记，若要切换到标签对应commit，可以通过<code>git show TAG_NAME</code>找到对用的提交信息，再执行相关操作。也可checkout出一个分支与tag对应分支同步：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout -b [branchname] [tagname]</div><div class=\"line\">Switched to a new branch &apos;branchname&apos;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"git-pull-–rebase\"><a href=\"#git-pull-–rebase\" class=\"headerlink\" title=\"git pull –rebase\"></a>git pull –rebase</h2><p>从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：</p>\n<p><img src=\"/imgs/git实用命令技巧-1.png\" alt=\"\"></p>\n<p>我们期望的分支图也许时这样的：</p>\n<p><img src=\"/imgs/git实用命令技巧-2.png\" alt=\"\"></p>\n<p>只需要将git pull -&gt; git pull –rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">合并前：</div><div class=\"line\">        D---E master</div><div class=\"line\">      /</div><div class=\"line\">A---B---C---F origin/master</div><div class=\"line\"></div><div class=\"line\">merge合并：</div><div class=\"line\">    D--------E  </div><div class=\"line\">  /           \\</div><div class=\"line\">A---B---C---F---G   master, origin/master</div><div class=\"line\"></div><div class=\"line\">rebase合并：</div><div class=\"line\">A---B---C---F---D---E   master, origin/master</div></pre></td></tr></table></figure></p>\n<p>如果遇到冲突，请将冲突解决后执行: <code>git rebase --continue</code>。它也有两面性，至于谁好谁坏，慎用就行了。</p>\n<h2 id=\"git-commit-–amend\"><a href=\"#git-commit-–amend\" class=\"headerlink\" title=\"git commit –amend\"></a>git commit –amend</h2><p>有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。</p>\n<h2 id=\"获取远程库的更新\"><a href=\"#获取远程库的更新\" class=\"headerlink\" title=\"获取远程库的更新\"></a>获取远程库的更新</h2><p>普通的工作流程一般是先folk整个工程到本地，再添加上游分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add upstream https://xxx.git</div></pre></td></tr></table></figure></p>\n<p>这样一来，我们就可以获取远程的更新到当前分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull upstream master</div></pre></td></tr></table></figure></p>\n<p>若拉取本地不存在的分支，则可以使用这条命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b new_branch upstream/new_branch</div></pre></td></tr></table></figure></p>\n<h2 id=\"推送多个远程库\"><a href=\"#推送多个远程库\" class=\"headerlink\" title=\"推送多个远程库\"></a>推送多个远程库</h2><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim ~/.git/config</div><div class=\"line\"></div><div class=\"line\">[remote &quot;upstream&quot;]</div><div class=\"line\">        url = git@gitlab.main.com:project.git</div><div class=\"line\">        url = git@github.main.com:project.git</div><div class=\"line\"></div><div class=\"line\">$ git push upstream</div></pre></td></tr></table></figure>\n<p>解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。</p>\n<h2 id=\"合并多个提交\"><a href=\"#合并多个提交\" class=\"headerlink\" title=\"合并多个提交\"></a>合并多个提交</h2><p>有些时候，本地会做多个commit提交，但是在push之前，合并为1个提交会显得更清晰，此时就需要借助<code>git rebase -i HEAD~N</code>了，其中N代表的是最近几次提交，执行后将需要合并的commit从pick改为squash，再重写提交记录即可。</p>\n<h2 id=\"更改提交人\"><a href=\"#更改提交人\" class=\"headerlink\" title=\"更改提交人\"></a>更改提交人</h2><p>在有一次和小伙伴协作代码时，由于需要伪造成同一个身份，让代码管理者看commit历史以为是同一个人做的，因此就用到了–author参数，提交的格式为：<code>name&lt;mail&gt;</code>，比如：<code>git commit -m &#39;feat: something&#39; --author=&quot;TJ&lt;mail@gmail.com&gt;&quot;</code>，这是通过git log即可看到作者信息发生了变化。</p>\n<h2 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h2><p>通常发布版本时，会为当前的时间线打上标签，这样可以快速对不同的版本进行查看。</p>\n<h4 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h4><ol>\n<li>git tag TAG_NAME，列出标签</li>\n<li>git tag -a  TAG_NAME -m ‘DESC’，添加附注标签，若不需要信息则去掉-a -m\b参数</li>\n<li>git tag TAG_NAME COMMIT_VERSIONT，给某条提交记录打Tag</li>\n</ol>\n<h4 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h4><ol>\n<li>git tag，列出所有标签名称</li>\n<li>git show TAG_NAME，显示tag信息</li>\n</ol>\n<h4 id=\"推送标签\"><a href=\"#推送标签\" class=\"headerlink\" title=\"推送标签\"></a>推送标签</h4><p>默认情况，标签信息是存在本地的，若要推送到服务器，则需使用<code>git push origin --tags</code>。</p>\n<h4 id=\"检出标签\"><a href=\"#检出标签\" class=\"headerlink\" title=\"检出标签\"></a>检出标签</h4><p>Git的Tag只是一个标记，若要切换到标签对应commit，可以通过<code>git show TAG_NAME</code>找到对用的提交信息，再执行相关操作。也可checkout出一个分支与tag对应分支同步：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout -b [branchname] [tagname]</div><div class=\"line\">Switched to a new branch &apos;branchname&apos;</div></pre></td></tr></table></figure></p>\n"},{"title":"css的BFC特性","date":"2017-10-23T15:29:05.000Z","_content":"\n### 预备知识\n\n**毗邻元素**\n\n只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素\n\n**普通流(normal flow)**\n\n在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。\n\n以下情况会脱离文档流而存在，分别是：`float: left`、`position: absolute`、`position: fixed`\n\n\n### 什么是BFC\n\nBlock Formatting Context，块格式化上下文，拥有一套渲染规则来决定子元素将如何布局，以及和其他子元素的相互关系。\n\nBFC可通过如下条件形成：\n\n- 浮动元素、绝对定位元素\n- 非块级盒子的块级容器(inline-blocks、table-cells、table-captions)\n- overflow不为默认值visible\n\nBFC的特性如下：\n\n- 内部的Box会在垂直方向，从顶部开始一个接一个地放置\n- Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box会发生叠加\n- 在BFC中，每一个Box的左外边缘，会触碰到容器的左边缘，右边也依然，即使存在浮动也如此\n- 形成了BFC的区域不会与float box重叠\n- 它是一个隔离的容器，容器内的子元素不会影响到外面的元素\n- 计算BFC的高度时，浮动元素也参与计算\n\n利用BFC的特性，我们可以用来解决诸如以下等问题。\n\n### 消除外边距塌陷(margin collapsing)\n\n在同一个BFC中，两个或多个毗邻的普通流中的块元素垂直方向上的margin会发生叠加，相邻块的外边距有时会被合并为单个外边距，取其中更大的值，这种行为称为外边距塌陷，发生此情况有一下几种情况：\n\n**1. 相邻的兄弟姐妹元素**\n\n```\n<p style=\"margin-bottom: 30px;\">这个段落的下外边距被合并...</p>\n<p style=\"margin-top: 20px;\">...这个段落的上外边距被合并。</p>\n```\n\n此时p的距离为30px，而不是预想的50px，在布局时需要注意。\n\n**2. 父子元素**\n\n```\n<div class=\"parent\" style=\"margin-top: 20px;\">\n  <p class=\"child\" style=\"margin-top: 10px;\">p的margin会被父元素的margin合并</p>\n</div>\n```\n\n产生这种影响必须满足两个条件：\n\n1. 第一个子元素的上边距和父元素的上边距会进行合并\n2. 最后一个子元素的下边距会和父元素的下边距进行合并\n\n当父元素的margin-top为0时，而子元素不为0，则整个区域都会具有子元素的外边距，这种情况称之为**子元素劫持**。给父元素设置`overflow: hidden`或是其他，触发了BFC特性即可解决。\n\n**3. 空元素**\n\n它的上下边距会自动合并为一个外边距，这作为外边距塌陷的一种特殊情况。\n\n### 解决父元素塌陷\n\n父元素塌陷指的是当子元素全为float，父元素高度为0这种情况，因为float元素不占据文档流(normal flow)空间，所以产生了塌陷，只需触发父元素的BFC特性即可解决，BFC会根据子元素的情况自动适应高度，包含浮动的子元素。\n\n### 解决元素被浮动元素覆盖\n\n浮动元素的毗邻节点会无视浮动的元素，尽量占满一行，这样就会被浮动元素所覆盖到，因此只需要把非浮动元素触发BFC，则会形成两列布局，从而不会被浮动元素覆盖。\n","source":"_posts/bfc-intro.md","raw":"---\ntitle: css的BFC特性\ndate: 2017-10-23 23:29:05\ntags: web\n---\n\n### 预备知识\n\n**毗邻元素**\n\n只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素\n\n**普通流(normal flow)**\n\n在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。\n\n以下情况会脱离文档流而存在，分别是：`float: left`、`position: absolute`、`position: fixed`\n\n\n### 什么是BFC\n\nBlock Formatting Context，块格式化上下文，拥有一套渲染规则来决定子元素将如何布局，以及和其他子元素的相互关系。\n\nBFC可通过如下条件形成：\n\n- 浮动元素、绝对定位元素\n- 非块级盒子的块级容器(inline-blocks、table-cells、table-captions)\n- overflow不为默认值visible\n\nBFC的特性如下：\n\n- 内部的Box会在垂直方向，从顶部开始一个接一个地放置\n- Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box会发生叠加\n- 在BFC中，每一个Box的左外边缘，会触碰到容器的左边缘，右边也依然，即使存在浮动也如此\n- 形成了BFC的区域不会与float box重叠\n- 它是一个隔离的容器，容器内的子元素不会影响到外面的元素\n- 计算BFC的高度时，浮动元素也参与计算\n\n利用BFC的特性，我们可以用来解决诸如以下等问题。\n\n### 消除外边距塌陷(margin collapsing)\n\n在同一个BFC中，两个或多个毗邻的普通流中的块元素垂直方向上的margin会发生叠加，相邻块的外边距有时会被合并为单个外边距，取其中更大的值，这种行为称为外边距塌陷，发生此情况有一下几种情况：\n\n**1. 相邻的兄弟姐妹元素**\n\n```\n<p style=\"margin-bottom: 30px;\">这个段落的下外边距被合并...</p>\n<p style=\"margin-top: 20px;\">...这个段落的上外边距被合并。</p>\n```\n\n此时p的距离为30px，而不是预想的50px，在布局时需要注意。\n\n**2. 父子元素**\n\n```\n<div class=\"parent\" style=\"margin-top: 20px;\">\n  <p class=\"child\" style=\"margin-top: 10px;\">p的margin会被父元素的margin合并</p>\n</div>\n```\n\n产生这种影响必须满足两个条件：\n\n1. 第一个子元素的上边距和父元素的上边距会进行合并\n2. 最后一个子元素的下边距会和父元素的下边距进行合并\n\n当父元素的margin-top为0时，而子元素不为0，则整个区域都会具有子元素的外边距，这种情况称之为**子元素劫持**。给父元素设置`overflow: hidden`或是其他，触发了BFC特性即可解决。\n\n**3. 空元素**\n\n它的上下边距会自动合并为一个外边距，这作为外边距塌陷的一种特殊情况。\n\n### 解决父元素塌陷\n\n父元素塌陷指的是当子元素全为float，父元素高度为0这种情况，因为float元素不占据文档流(normal flow)空间，所以产生了塌陷，只需触发父元素的BFC特性即可解决，BFC会根据子元素的情况自动适应高度，包含浮动的子元素。\n\n### 解决元素被浮动元素覆盖\n\n浮动元素的毗邻节点会无视浮动的元素，尽量占满一行，这样就会被浮动元素所覆盖到，因此只需要把非浮动元素触发BFC，则会形成两列布局，从而不会被浮动元素覆盖。\n","slug":"bfc-intro","published":1,"updated":"2017-10-23T15:30:15.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8ba0006nuc3ugxtnf1f","content":"<h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p><strong>毗邻元素</strong></p>\n<p>只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素</p>\n<p><strong>普通流(normal flow)</strong></p>\n<p>在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。</p>\n<p>以下情况会脱离文档流而存在，分别是：<code>float: left</code>、<code>position: absolute</code>、<code>position: fixed</code></p>\n<h3 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h3><p>Block Formatting Context，块格式化上下文，拥有一套渲染规则来决定子元素将如何布局，以及和其他子元素的相互关系。</p>\n<p>BFC可通过如下条件形成：</p>\n<ul>\n<li>浮动元素、绝对定位元素</li>\n<li>非块级盒子的块级容器(inline-blocks、table-cells、table-captions)</li>\n<li>overflow不为默认值visible</li>\n</ul>\n<p>BFC的特性如下：</p>\n<ul>\n<li>内部的Box会在垂直方向，从顶部开始一个接一个地放置</li>\n<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box会发生叠加</li>\n<li>在BFC中，每一个Box的左外边缘，会触碰到容器的左边缘，右边也依然，即使存在浮动也如此</li>\n<li>形成了BFC的区域不会与float box重叠</li>\n<li>它是一个隔离的容器，容器内的子元素不会影响到外面的元素</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ul>\n<p>利用BFC的特性，我们可以用来解决诸如以下等问题。</p>\n<h3 id=\"消除外边距塌陷-margin-collapsing\"><a href=\"#消除外边距塌陷-margin-collapsing\" class=\"headerlink\" title=\"消除外边距塌陷(margin collapsing)\"></a>消除外边距塌陷(margin collapsing)</h3><p>在同一个BFC中，两个或多个毗邻的普通流中的块元素垂直方向上的margin会发生叠加，相邻块的外边距有时会被合并为单个外边距，取其中更大的值，这种行为称为外边距塌陷，发生此情况有一下几种情况：</p>\n<p><strong>1. 相邻的兄弟姐妹元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot;margin-bottom: 30px;&quot;&gt;这个段落的下外边距被合并...&lt;/p&gt;</div><div class=\"line\">&lt;p style=&quot;margin-top: 20px;&quot;&gt;...这个段落的上外边距被合并。&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p>此时p的距离为30px，而不是预想的50px，在布局时需要注意。</p>\n<p><strong>2. 父子元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;parent&quot; style=&quot;margin-top: 20px;&quot;&gt;</div><div class=\"line\">  &lt;p class=&quot;child&quot; style=&quot;margin-top: 10px;&quot;&gt;p的margin会被父元素的margin合并&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>产生这种影响必须满足两个条件：</p>\n<ol>\n<li>第一个子元素的上边距和父元素的上边距会进行合并</li>\n<li>最后一个子元素的下边距会和父元素的下边距进行合并</li>\n</ol>\n<p>当父元素的margin-top为0时，而子元素不为0，则整个区域都会具有子元素的外边距，这种情况称之为<strong>子元素劫持</strong>。给父元素设置<code>overflow: hidden</code>或是其他，触发了BFC特性即可解决。</p>\n<p><strong>3. 空元素</strong></p>\n<p>它的上下边距会自动合并为一个外边距，这作为外边距塌陷的一种特殊情况。</p>\n<h3 id=\"解决父元素塌陷\"><a href=\"#解决父元素塌陷\" class=\"headerlink\" title=\"解决父元素塌陷\"></a>解决父元素塌陷</h3><p>父元素塌陷指的是当子元素全为float，父元素高度为0这种情况，因为float元素不占据文档流(normal flow)空间，所以产生了塌陷，只需触发父元素的BFC特性即可解决，BFC会根据子元素的情况自动适应高度，包含浮动的子元素。</p>\n<h3 id=\"解决元素被浮动元素覆盖\"><a href=\"#解决元素被浮动元素覆盖\" class=\"headerlink\" title=\"解决元素被浮动元素覆盖\"></a>解决元素被浮动元素覆盖</h3><p>浮动元素的毗邻节点会无视浮动的元素，尽量占满一行，这样就会被浮动元素所覆盖到，因此只需要把非浮动元素触发BFC，则会形成两列布局，从而不会被浮动元素覆盖。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p><strong>毗邻元素</strong></p>\n<p>只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素</p>\n<p><strong>普通流(normal flow)</strong></p>\n<p>在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。</p>\n<p>以下情况会脱离文档流而存在，分别是：<code>float: left</code>、<code>position: absolute</code>、<code>position: fixed</code></p>\n<h3 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h3><p>Block Formatting Context，块格式化上下文，拥有一套渲染规则来决定子元素将如何布局，以及和其他子元素的相互关系。</p>\n<p>BFC可通过如下条件形成：</p>\n<ul>\n<li>浮动元素、绝对定位元素</li>\n<li>非块级盒子的块级容器(inline-blocks、table-cells、table-captions)</li>\n<li>overflow不为默认值visible</li>\n</ul>\n<p>BFC的特性如下：</p>\n<ul>\n<li>内部的Box会在垂直方向，从顶部开始一个接一个地放置</li>\n<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box会发生叠加</li>\n<li>在BFC中，每一个Box的左外边缘，会触碰到容器的左边缘，右边也依然，即使存在浮动也如此</li>\n<li>形成了BFC的区域不会与float box重叠</li>\n<li>它是一个隔离的容器，容器内的子元素不会影响到外面的元素</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ul>\n<p>利用BFC的特性，我们可以用来解决诸如以下等问题。</p>\n<h3 id=\"消除外边距塌陷-margin-collapsing\"><a href=\"#消除外边距塌陷-margin-collapsing\" class=\"headerlink\" title=\"消除外边距塌陷(margin collapsing)\"></a>消除外边距塌陷(margin collapsing)</h3><p>在同一个BFC中，两个或多个毗邻的普通流中的块元素垂直方向上的margin会发生叠加，相邻块的外边距有时会被合并为单个外边距，取其中更大的值，这种行为称为外边距塌陷，发生此情况有一下几种情况：</p>\n<p><strong>1. 相邻的兄弟姐妹元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot;margin-bottom: 30px;&quot;&gt;这个段落的下外边距被合并...&lt;/p&gt;</div><div class=\"line\">&lt;p style=&quot;margin-top: 20px;&quot;&gt;...这个段落的上外边距被合并。&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p>此时p的距离为30px，而不是预想的50px，在布局时需要注意。</p>\n<p><strong>2. 父子元素</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;parent&quot; style=&quot;margin-top: 20px;&quot;&gt;</div><div class=\"line\">  &lt;p class=&quot;child&quot; style=&quot;margin-top: 10px;&quot;&gt;p的margin会被父元素的margin合并&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>产生这种影响必须满足两个条件：</p>\n<ol>\n<li>第一个子元素的上边距和父元素的上边距会进行合并</li>\n<li>最后一个子元素的下边距会和父元素的下边距进行合并</li>\n</ol>\n<p>当父元素的margin-top为0时，而子元素不为0，则整个区域都会具有子元素的外边距，这种情况称之为<strong>子元素劫持</strong>。给父元素设置<code>overflow: hidden</code>或是其他，触发了BFC特性即可解决。</p>\n<p><strong>3. 空元素</strong></p>\n<p>它的上下边距会自动合并为一个外边距，这作为外边距塌陷的一种特殊情况。</p>\n<h3 id=\"解决父元素塌陷\"><a href=\"#解决父元素塌陷\" class=\"headerlink\" title=\"解决父元素塌陷\"></a>解决父元素塌陷</h3><p>父元素塌陷指的是当子元素全为float，父元素高度为0这种情况，因为float元素不占据文档流(normal flow)空间，所以产生了塌陷，只需触发父元素的BFC特性即可解决，BFC会根据子元素的情况自动适应高度，包含浮动的子元素。</p>\n<h3 id=\"解决元素被浮动元素覆盖\"><a href=\"#解决元素被浮动元素覆盖\" class=\"headerlink\" title=\"解决元素被浮动元素覆盖\"></a>解决元素被浮动元素覆盖</h3><p>浮动元素的毗邻节点会无视浮动的元素，尽量占满一行，这样就会被浮动元素所覆盖到，因此只需要把非浮动元素触发BFC，则会形成两列布局，从而不会被浮动元素覆盖。</p>\n"},{"title":"d3-intro","date":"2017-10-24T14:13:18.000Z","_content":"D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。\n\nD3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。\n\n## 选择器\n\n使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。\n\n例如原dom有操作方式如下：\n\n```\nvar paragraphs = document.getElementsByTagName(\"p\");\nfor (var i = 0; i < paragraphs.length; i++) {\n  var paragraph = paragraphs.item(i);\n  paragraph.style.setProperty(\"color\", \"white\", null);\n}\n```\n\n使用d3的方式来重写：\n\n```\nd3.selectAll(\"p\").style(\"color\", \"white\");\nd3.select(\"body\").style(\"background-color\", \"black\")\n```\n\n打开调试的页面，即可看到效果。d3的选择器也是由标准[W3C Selectors API](https://www.w3.org/TR/selectors-api/)构建的，因此在各种现代浏览器中原生支持。d3提供了丰富的方法来改变节点：设置属性、样式、注册事件、删除添加节点等，这些可以满足大多的需要。\n\n## 动态特性\n\nd3就像dom的框架jquery一样，包含有许多属性、样式的函数方法，它不仅仅简化了方法，组合起来会惊人的强大。d3还提供了许多内建可复用的函数，如区域图形、线和饼图。\n\n例如，使偶数段落颜色值随机：\n\n```\nd3.selectAll('p').style('color', function (d, i) {\n  return i % 2 ? '#fff' : 'hsl(' + Math.random() * 360 + ',100%,50%)'\n})\n```\n\n计算属性通常用于绑定数据，数据规定为一个数组，每个元素都会通过第一个参数由默认顺序传递进入选择器函数，例如我们可以使用一个数组去动态设置字体大小：\n\n```\nd3.selectAll(\"p\")\n  .data([4, 8, 15, 16, 23, 42])\n    .style(\"font-size\", function(d) { return d + \"px\"; });\n```\n\n一旦数据被绑定到dom，那么在之后的操作中可以不用再一次绑定数据，d3将会检测先前绑定的数据，因此允许重新计算属性而不用重新绑定。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n## Enter 和 Exit\n\nEnter可用于为新来的数据创建新的节点，当数据绑定到了选择器上时，每个结点都会有对应的数据，如果节点少于数据，那么**额外的数据就会从enter选择器进入**，在这里面就可以进行添加等操作，而Exitremove用于。\n\n如果没有使用Enter和Exit，会自动的选择存在存在并且匹配数据的节点进行更新操作，而exit用于退出节点，remove用于删除节点。\n\nD3让你基于数据对dom进行变化，这些操作包括了添加与删除，也允许改变响应事件、动画事件或是从第三方库异步通知，甚至支持混合的方式，从服务器上渲染，然后更新到客户端上。\n\n## 转换\n\nD3不会引入新的视觉表现，而是直接来源于Web标准：HTML、SVG和CSS。因此无需考虑兼容性问题，因为所有D3使用的技术都是浏览器内置的元素与标准。\n\nD3专注于从自然到动画的转化，随着时间逐渐插入样式和属性，中间过程可以使用如“elastic”, “cubic-in-out” 和“linear”来控制补片。\n\n通过仅修改实际改变的属性，D3减少了开销，并允许在高帧速率下实现更大的图形复杂度。D3还允许通过事件对复杂过渡进行排序。而且，您仍然可以使用CSS3转换; D3不会取代浏览器的工具箱，而是以更容易使用的方式展开。\n\n\n\n## 示例\n\n代码如下：\n\n```\n// css\n.chart div {\n  font: 10px sans-serif;\n  background-color: steelblue;\n  text-align: right;\n  padding: 3px;\n  margin: 1px;\n  color: white;\n}\n\n// html\n<div class=\"chart\">\n</div>\n\n// js\nd3.select(\".chart\")\n  .selectAll(\"div\")\n  .data([30, 86, 168, 281, 303, 365])\n    .enter()\n    .append(\"div\")\n    .style(\"width\", function(d) { return d * 2 + \"px\"; })\n    .text(function(d) { return '$ ' + d; });\n\n```\n\n效果图：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-24/89023358.jpg)\n\n其中，api方法如下：\n\n- select，选中某一个元素\n- selectAll，选中其中的div元素\n- data，传入数据\n- enter，对于额外数据进行插入操作\n- append，插入div\n- style，设置宽度，回调函数d代表data对应的值\n- text，修改插入元素内的文字\n","source":"_posts/d3-intro.md","raw":"---\ntitle: d3-intro\ndate: 2017-10-24 22:13:18\ntags: web\n---\nD3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。\n\nD3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。\n\n## 选择器\n\n使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。\n\n例如原dom有操作方式如下：\n\n```\nvar paragraphs = document.getElementsByTagName(\"p\");\nfor (var i = 0; i < paragraphs.length; i++) {\n  var paragraph = paragraphs.item(i);\n  paragraph.style.setProperty(\"color\", \"white\", null);\n}\n```\n\n使用d3的方式来重写：\n\n```\nd3.selectAll(\"p\").style(\"color\", \"white\");\nd3.select(\"body\").style(\"background-color\", \"black\")\n```\n\n打开调试的页面，即可看到效果。d3的选择器也是由标准[W3C Selectors API](https://www.w3.org/TR/selectors-api/)构建的，因此在各种现代浏览器中原生支持。d3提供了丰富的方法来改变节点：设置属性、样式、注册事件、删除添加节点等，这些可以满足大多的需要。\n\n## 动态特性\n\nd3就像dom的框架jquery一样，包含有许多属性、样式的函数方法，它不仅仅简化了方法，组合起来会惊人的强大。d3还提供了许多内建可复用的函数，如区域图形、线和饼图。\n\n例如，使偶数段落颜色值随机：\n\n```\nd3.selectAll('p').style('color', function (d, i) {\n  return i % 2 ? '#fff' : 'hsl(' + Math.random() * 360 + ',100%,50%)'\n})\n```\n\n计算属性通常用于绑定数据，数据规定为一个数组，每个元素都会通过第一个参数由默认顺序传递进入选择器函数，例如我们可以使用一个数组去动态设置字体大小：\n\n```\nd3.selectAll(\"p\")\n  .data([4, 8, 15, 16, 23, 42])\n    .style(\"font-size\", function(d) { return d + \"px\"; });\n```\n\n一旦数据被绑定到dom，那么在之后的操作中可以不用再一次绑定数据，d3将会检测先前绑定的数据，因此允许重新计算属性而不用重新绑定。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n## Enter 和 Exit\n\nEnter可用于为新来的数据创建新的节点，当数据绑定到了选择器上时，每个结点都会有对应的数据，如果节点少于数据，那么**额外的数据就会从enter选择器进入**，在这里面就可以进行添加等操作，而Exitremove用于。\n\n如果没有使用Enter和Exit，会自动的选择存在存在并且匹配数据的节点进行更新操作，而exit用于退出节点，remove用于删除节点。\n\nD3让你基于数据对dom进行变化，这些操作包括了添加与删除，也允许改变响应事件、动画事件或是从第三方库异步通知，甚至支持混合的方式，从服务器上渲染，然后更新到客户端上。\n\n## 转换\n\nD3不会引入新的视觉表现，而是直接来源于Web标准：HTML、SVG和CSS。因此无需考虑兼容性问题，因为所有D3使用的技术都是浏览器内置的元素与标准。\n\nD3专注于从自然到动画的转化，随着时间逐渐插入样式和属性，中间过程可以使用如“elastic”, “cubic-in-out” 和“linear”来控制补片。\n\n通过仅修改实际改变的属性，D3减少了开销，并允许在高帧速率下实现更大的图形复杂度。D3还允许通过事件对复杂过渡进行排序。而且，您仍然可以使用CSS3转换; D3不会取代浏览器的工具箱，而是以更容易使用的方式展开。\n\n\n\n## 示例\n\n代码如下：\n\n```\n// css\n.chart div {\n  font: 10px sans-serif;\n  background-color: steelblue;\n  text-align: right;\n  padding: 3px;\n  margin: 1px;\n  color: white;\n}\n\n// html\n<div class=\"chart\">\n</div>\n\n// js\nd3.select(\".chart\")\n  .selectAll(\"div\")\n  .data([30, 86, 168, 281, 303, 365])\n    .enter()\n    .append(\"div\")\n    .style(\"width\", function(d) { return d * 2 + \"px\"; })\n    .text(function(d) { return '$ ' + d; });\n\n```\n\n效果图：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-24/89023358.jpg)\n\n其中，api方法如下：\n\n- select，选中某一个元素\n- selectAll，选中其中的div元素\n- data，传入数据\n- enter，对于额外数据进行插入操作\n- append，插入div\n- style，设置宽度，回调函数d代表data对应的值\n- text，修改插入元素内的文字\n","slug":"d3-intro","published":1,"updated":"2017-10-24T14:13:37.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8bc0009nuc3d71zpauu","content":"<p>D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。</p>\n<p>D3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><p>使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。</p>\n<p>例如原dom有操作方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var paragraphs = document.getElementsByTagName(&quot;p&quot;);</div><div class=\"line\">for (var i = 0; i &lt; paragraphs.length; i++) &#123;</div><div class=\"line\">  var paragraph = paragraphs.item(i);</div><div class=\"line\">  paragraph.style.setProperty(&quot;color&quot;, &quot;white&quot;, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用d3的方式来重写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&quot;p&quot;).style(&quot;color&quot;, &quot;white&quot;);</div><div class=\"line\">d3.select(&quot;body&quot;).style(&quot;background-color&quot;, &quot;black&quot;)</div></pre></td></tr></table></figure>\n<p>打开调试的页面，即可看到效果。d3的选择器也是由标准<a href=\"https://www.w3.org/TR/selectors-api/\" target=\"_blank\" rel=\"external\">W3C Selectors API</a>构建的，因此在各种现代浏览器中原生支持。d3提供了丰富的方法来改变节点：设置属性、样式、注册事件、删除添加节点等，这些可以满足大多的需要。</p>\n<h2 id=\"动态特性\"><a href=\"#动态特性\" class=\"headerlink\" title=\"动态特性\"></a>动态特性</h2><p>d3就像dom的框架jquery一样，包含有许多属性、样式的函数方法，它不仅仅简化了方法，组合起来会惊人的强大。d3还提供了许多内建可复用的函数，如区域图形、线和饼图。</p>\n<p>例如，使偶数段落颜色值随机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&apos;p&apos;).style(&apos;color&apos;, function (d, i) &#123;</div><div class=\"line\">  return i % 2 ? &apos;#fff&apos; : &apos;hsl(&apos; + Math.random() * 360 + &apos;,100%,50%)&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>计算属性通常用于绑定数据，数据规定为一个数组，每个元素都会通过第一个参数由默认顺序传递进入选择器函数，例如我们可以使用一个数组去动态设置字体大小：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&quot;p&quot;)</div><div class=\"line\">  .data([4, 8, 15, 16, 23, 42])</div><div class=\"line\">    .style(&quot;font-size&quot;, function(d) &#123; return d + &quot;px&quot;; &#125;);</div></pre></td></tr></table></figure>\n<p>一旦数据被绑定到dom，那么在之后的操作中可以不用再一次绑定数据，d3将会检测先前绑定的数据，因此允许重新计算属性而不用重新绑定。                                                                                                                                                                                                                                                                                                                                    </p>\n<h2 id=\"Enter-和-Exit\"><a href=\"#Enter-和-Exit\" class=\"headerlink\" title=\"Enter 和 Exit\"></a>Enter 和 Exit</h2><p>Enter可用于为新来的数据创建新的节点，当数据绑定到了选择器上时，每个结点都会有对应的数据，如果节点少于数据，那么<strong>额外的数据就会从enter选择器进入</strong>，在这里面就可以进行添加等操作，而Exitremove用于。</p>\n<p>如果没有使用Enter和Exit，会自动的选择存在存在并且匹配数据的节点进行更新操作，而exit用于退出节点，remove用于删除节点。</p>\n<p>D3让你基于数据对dom进行变化，这些操作包括了添加与删除，也允许改变响应事件、动画事件或是从第三方库异步通知，甚至支持混合的方式，从服务器上渲染，然后更新到客户端上。</p>\n<h2 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h2><p>D3不会引入新的视觉表现，而是直接来源于Web标准：HTML、SVG和CSS。因此无需考虑兼容性问题，因为所有D3使用的技术都是浏览器内置的元素与标准。</p>\n<p>D3专注于从自然到动画的转化，随着时间逐渐插入样式和属性，中间过程可以使用如“elastic”, “cubic-in-out” 和“linear”来控制补片。</p>\n<p>通过仅修改实际改变的属性，D3减少了开销，并允许在高帧速率下实现更大的图形复杂度。D3还允许通过事件对复杂过渡进行排序。而且，您仍然可以使用CSS3转换; D3不会取代浏览器的工具箱，而是以更容易使用的方式展开。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// css</div><div class=\"line\">.chart div &#123;</div><div class=\"line\">  font: 10px sans-serif;</div><div class=\"line\">  background-color: steelblue;</div><div class=\"line\">  text-align: right;</div><div class=\"line\">  padding: 3px;</div><div class=\"line\">  margin: 1px;</div><div class=\"line\">  color: white;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// html</div><div class=\"line\">&lt;div class=&quot;chart&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">// js</div><div class=\"line\">d3.select(&quot;.chart&quot;)</div><div class=\"line\">  .selectAll(&quot;div&quot;)</div><div class=\"line\">  .data([30, 86, 168, 281, 303, 365])</div><div class=\"line\">    .enter()</div><div class=\"line\">    .append(&quot;div&quot;)</div><div class=\"line\">    .style(&quot;width&quot;, function(d) &#123; return d * 2 + &quot;px&quot;; &#125;)</div><div class=\"line\">    .text(function(d) &#123; return &apos;$ &apos; + d; &#125;);</div></pre></td></tr></table></figure>\n<p>效果图：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-24/89023358.jpg\" alt=\"\"></p>\n<p>其中，api方法如下：</p>\n<ul>\n<li>select，选中某一个元素</li>\n<li>selectAll，选中其中的div元素</li>\n<li>data，传入数据</li>\n<li>enter，对于额外数据进行插入操作</li>\n<li>append，插入div</li>\n<li>style，设置宽度，回调函数d代表data对应的值</li>\n<li>text，修改插入元素内的文字</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。</p>\n<p>D3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><p>使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。</p>\n<p>例如原dom有操作方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var paragraphs = document.getElementsByTagName(&quot;p&quot;);</div><div class=\"line\">for (var i = 0; i &lt; paragraphs.length; i++) &#123;</div><div class=\"line\">  var paragraph = paragraphs.item(i);</div><div class=\"line\">  paragraph.style.setProperty(&quot;color&quot;, &quot;white&quot;, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用d3的方式来重写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&quot;p&quot;).style(&quot;color&quot;, &quot;white&quot;);</div><div class=\"line\">d3.select(&quot;body&quot;).style(&quot;background-color&quot;, &quot;black&quot;)</div></pre></td></tr></table></figure>\n<p>打开调试的页面，即可看到效果。d3的选择器也是由标准<a href=\"https://www.w3.org/TR/selectors-api/\" target=\"_blank\" rel=\"external\">W3C Selectors API</a>构建的，因此在各种现代浏览器中原生支持。d3提供了丰富的方法来改变节点：设置属性、样式、注册事件、删除添加节点等，这些可以满足大多的需要。</p>\n<h2 id=\"动态特性\"><a href=\"#动态特性\" class=\"headerlink\" title=\"动态特性\"></a>动态特性</h2><p>d3就像dom的框架jquery一样，包含有许多属性、样式的函数方法，它不仅仅简化了方法，组合起来会惊人的强大。d3还提供了许多内建可复用的函数，如区域图形、线和饼图。</p>\n<p>例如，使偶数段落颜色值随机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&apos;p&apos;).style(&apos;color&apos;, function (d, i) &#123;</div><div class=\"line\">  return i % 2 ? &apos;#fff&apos; : &apos;hsl(&apos; + Math.random() * 360 + &apos;,100%,50%)&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>计算属性通常用于绑定数据，数据规定为一个数组，每个元素都会通过第一个参数由默认顺序传递进入选择器函数，例如我们可以使用一个数组去动态设置字体大小：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">d3.selectAll(&quot;p&quot;)</div><div class=\"line\">  .data([4, 8, 15, 16, 23, 42])</div><div class=\"line\">    .style(&quot;font-size&quot;, function(d) &#123; return d + &quot;px&quot;; &#125;);</div></pre></td></tr></table></figure>\n<p>一旦数据被绑定到dom，那么在之后的操作中可以不用再一次绑定数据，d3将会检测先前绑定的数据，因此允许重新计算属性而不用重新绑定。                                                                                                                                                                                                                                                                                                                                    </p>\n<h2 id=\"Enter-和-Exit\"><a href=\"#Enter-和-Exit\" class=\"headerlink\" title=\"Enter 和 Exit\"></a>Enter 和 Exit</h2><p>Enter可用于为新来的数据创建新的节点，当数据绑定到了选择器上时，每个结点都会有对应的数据，如果节点少于数据，那么<strong>额外的数据就会从enter选择器进入</strong>，在这里面就可以进行添加等操作，而Exitremove用于。</p>\n<p>如果没有使用Enter和Exit，会自动的选择存在存在并且匹配数据的节点进行更新操作，而exit用于退出节点，remove用于删除节点。</p>\n<p>D3让你基于数据对dom进行变化，这些操作包括了添加与删除，也允许改变响应事件、动画事件或是从第三方库异步通知，甚至支持混合的方式，从服务器上渲染，然后更新到客户端上。</p>\n<h2 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h2><p>D3不会引入新的视觉表现，而是直接来源于Web标准：HTML、SVG和CSS。因此无需考虑兼容性问题，因为所有D3使用的技术都是浏览器内置的元素与标准。</p>\n<p>D3专注于从自然到动画的转化，随着时间逐渐插入样式和属性，中间过程可以使用如“elastic”, “cubic-in-out” 和“linear”来控制补片。</p>\n<p>通过仅修改实际改变的属性，D3减少了开销，并允许在高帧速率下实现更大的图形复杂度。D3还允许通过事件对复杂过渡进行排序。而且，您仍然可以使用CSS3转换; D3不会取代浏览器的工具箱，而是以更容易使用的方式展开。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// css</div><div class=\"line\">.chart div &#123;</div><div class=\"line\">  font: 10px sans-serif;</div><div class=\"line\">  background-color: steelblue;</div><div class=\"line\">  text-align: right;</div><div class=\"line\">  padding: 3px;</div><div class=\"line\">  margin: 1px;</div><div class=\"line\">  color: white;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// html</div><div class=\"line\">&lt;div class=&quot;chart&quot;&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">// js</div><div class=\"line\">d3.select(&quot;.chart&quot;)</div><div class=\"line\">  .selectAll(&quot;div&quot;)</div><div class=\"line\">  .data([30, 86, 168, 281, 303, 365])</div><div class=\"line\">    .enter()</div><div class=\"line\">    .append(&quot;div&quot;)</div><div class=\"line\">    .style(&quot;width&quot;, function(d) &#123; return d * 2 + &quot;px&quot;; &#125;)</div><div class=\"line\">    .text(function(d) &#123; return &apos;$ &apos; + d; &#125;);</div></pre></td></tr></table></figure>\n<p>效果图：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-24/89023358.jpg\" alt=\"\"></p>\n<p>其中，api方法如下：</p>\n<ul>\n<li>select，选中某一个元素</li>\n<li>selectAll，选中其中的div元素</li>\n<li>data，传入数据</li>\n<li>enter，对于额外数据进行插入操作</li>\n<li>append，插入div</li>\n<li>style，设置宽度，回调函数d代表data对应的值</li>\n<li>text，修改插入元素内的文字</li>\n</ul>\n"},{"title":"js事件触发机制","date":"2017-10-17T15:27:11.000Z","_content":"## 原理\n\n**事件捕获**\n\n由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。\n\n**事件冒泡**\n\n由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。\n\n\n\n这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。\n\n------\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg)\n\n`addEventListen(event, function, useCapture)`添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：\n\n```\ncontainer.addEventListener('click', () => console.log('container'), true)\nchild.addEventListener('click', () => console.log('child'), true)\n// 点击child, 输出: container，child\n\ncontainer.addEventListener('click', () => console.log('container'))\nchild.addEventListener('click', () => console.log('child'))\n// 点击child, 输出: child，container\n```\n\n假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到**阻止冒泡**的方式：`stopPropagation`，改写child的方法：\n\n```\nchild.addEventListener('click', e => {\n  console.log('child')\n  e.stopPropagation()\n});\n```\n\n说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是**阻止浏览器默认行为**，如a标签跳转，submit提交等。\n\n还有一种方式称为**事件委托**，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：\n\n```\ncontainer.addEventListener(\"click\", e => {\n  if (e.target.id === 'child') {\n    console.log('child')\n  }\n});\n```\n\n可见，当点击子元素依然会输出`child`，在某些特定场景利用事件委托可节省大量的性能。\n\n\n\n明白了上述事件关系，target与currentTarget也就易于理解了，简言之，**target指引发出发事件的元素，currentTarget则指事件绑定的元素**，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。\n\n\n\n## 示例\n\n在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：\n\n- mouseenter：鼠标进入时触发，不响应子元素冒泡事件\n- mouseover：鼠标进入时触发，响应子元素冒泡事件\n- mouseleave：鼠标离开时触发，不响应子元素冒泡事件\n- mouseout：鼠标离开时触发，响应子元素冒泡事件\n\n让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg)\n\n场景如下：\n\n- 鼠标移入每一行，显示编辑按钮，移出则取消\n- 点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态\n\n其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。\n\n单看页面，其实就是ul>li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：`  <div class=\"schedule-input-wrap\" v-show=\"isEdit || hovering\">`，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。\n\n有了思路，首先考虑**事件捕获机制**，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为`pointer-events:none;`，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。\n\n后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：\n\n```\n                <ul @mouseleave=\"hoverId=''\">\n                    <li v-for=\"(item, itemIndex) in record.schedulings\"\n                        @mouseenter=\"hoverId=`item${itemIndex}`\"\n                        ....\n                        <schedule-input :hovering=\"isHovering(itemIndex)\"\n                        ></schedule-input>\n                    </li>\n                </ul>\n```\n\n其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。\n","source":"_posts/js-event-trigger.md","raw":"---\ntitle: js事件触发机制\ndate: 2017-10-17 23:27:11\ntags: js\n---\n## 原理\n\n**事件捕获**\n\n由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。\n\n**事件冒泡**\n\n由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。\n\n\n\n这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。\n\n------\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg)\n\n`addEventListen(event, function, useCapture)`添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：\n\n```\ncontainer.addEventListener('click', () => console.log('container'), true)\nchild.addEventListener('click', () => console.log('child'), true)\n// 点击child, 输出: container，child\n\ncontainer.addEventListener('click', () => console.log('container'))\nchild.addEventListener('click', () => console.log('child'))\n// 点击child, 输出: child，container\n```\n\n假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到**阻止冒泡**的方式：`stopPropagation`，改写child的方法：\n\n```\nchild.addEventListener('click', e => {\n  console.log('child')\n  e.stopPropagation()\n});\n```\n\n说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是**阻止浏览器默认行为**，如a标签跳转，submit提交等。\n\n还有一种方式称为**事件委托**，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：\n\n```\ncontainer.addEventListener(\"click\", e => {\n  if (e.target.id === 'child') {\n    console.log('child')\n  }\n});\n```\n\n可见，当点击子元素依然会输出`child`，在某些特定场景利用事件委托可节省大量的性能。\n\n\n\n明白了上述事件关系，target与currentTarget也就易于理解了，简言之，**target指引发出发事件的元素，currentTarget则指事件绑定的元素**，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。\n\n\n\n## 示例\n\n在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：\n\n- mouseenter：鼠标进入时触发，不响应子元素冒泡事件\n- mouseover：鼠标进入时触发，响应子元素冒泡事件\n- mouseleave：鼠标离开时触发，不响应子元素冒泡事件\n- mouseout：鼠标离开时触发，响应子元素冒泡事件\n\n让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg)\n\n场景如下：\n\n- 鼠标移入每一行，显示编辑按钮，移出则取消\n- 点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态\n\n其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。\n\n单看页面，其实就是ul>li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：`  <div class=\"schedule-input-wrap\" v-show=\"isEdit || hovering\">`，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。\n\n有了思路，首先考虑**事件捕获机制**，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为`pointer-events:none;`，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。\n\n后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：\n\n```\n                <ul @mouseleave=\"hoverId=''\">\n                    <li v-for=\"(item, itemIndex) in record.schedulings\"\n                        @mouseenter=\"hoverId=`item${itemIndex}`\"\n                        ....\n                        <schedule-input :hovering=\"isHovering(itemIndex)\"\n                        ></schedule-input>\n                    </li>\n                </ul>\n```\n\n其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。\n","slug":"js-event-trigger","published":1,"updated":"2018-01-07T10:59:53.467Z","_id":"cjaggj8be000bnuc3y0wvhqv9","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>事件捕获</strong></p>\n<p>由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。</p>\n<p><strong>事件冒泡</strong></p>\n<p>由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。</p>\n<p>这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。</p>\n<hr>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg\" alt=\"\"></p>\n<p><code>addEventListen(event, function, useCapture)</code>添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">container.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;container&apos;), true)</div><div class=\"line\">child.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;child&apos;), true)</div><div class=\"line\">// 点击child, 输出: container，child</div><div class=\"line\"></div><div class=\"line\">container.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;container&apos;))</div><div class=\"line\">child.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;child&apos;))</div><div class=\"line\">// 点击child, 输出: child，container</div></pre></td></tr></table></figure>\n<p>假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到<strong>阻止冒泡</strong>的方式：<code>stopPropagation</code>，改写child的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">child.addEventListener(&apos;click&apos;, e =&gt; &#123;</div><div class=\"line\">  console.log(&apos;child&apos;)</div><div class=\"line\">  e.stopPropagation()</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是<strong>阻止浏览器默认行为</strong>，如a标签跳转，submit提交等。</p>\n<p>还有一种方式称为<strong>事件委托</strong>，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">container.addEventListener(&quot;click&quot;, e =&gt; &#123;</div><div class=\"line\">  if (e.target.id === &apos;child&apos;) &#123;</div><div class=\"line\">    console.log(&apos;child&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>可见，当点击子元素依然会输出<code>child</code>，在某些特定场景利用事件委托可节省大量的性能。</p>\n<p>明白了上述事件关系，target与currentTarget也就易于理解了，简言之，<strong>target指引发出发事件的元素，currentTarget则指事件绑定的元素</strong>，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：</p>\n<ul>\n<li>mouseenter：鼠标进入时触发，不响应子元素冒泡事件</li>\n<li>mouseover：鼠标进入时触发，响应子元素冒泡事件</li>\n<li>mouseleave：鼠标离开时触发，不响应子元素冒泡事件</li>\n<li>mouseout：鼠标离开时触发，响应子元素冒泡事件</li>\n</ul>\n<p>让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg\" alt=\"\"></p>\n<p>场景如下：</p>\n<ul>\n<li>鼠标移入每一行，显示编辑按钮，移出则取消</li>\n<li>点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态</li>\n</ul>\n<p>其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。</p>\n<p>单看页面，其实就是ul&gt;li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：<code>&lt;div class=&quot;schedule-input-wrap&quot; v-show=&quot;isEdit || hovering&quot;&gt;</code>，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。</p>\n<p>有了思路，首先考虑<strong>事件捕获机制</strong>，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为<code>pointer-events:none;</code>，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。</p>\n<p>后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul @mouseleave=&quot;hoverId=&apos;&apos;&quot;&gt;</div><div class=\"line\">    &lt;li v-for=&quot;(item, itemIndex) in record.schedulings&quot;</div><div class=\"line\">        @mouseenter=&quot;hoverId=`item$&#123;itemIndex&#125;`&quot;</div><div class=\"line\">        ....</div><div class=\"line\">        &lt;schedule-input :hovering=&quot;isHovering(itemIndex)&quot;</div><div class=\"line\">        &gt;&lt;/schedule-input&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<p>其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>事件捕获</strong></p>\n<p>由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。</p>\n<p><strong>事件冒泡</strong></p>\n<p>由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。</p>\n<p>这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。</p>\n<hr>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg\" alt=\"\"></p>\n<p><code>addEventListen(event, function, useCapture)</code>添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">container.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;container&apos;), true)</div><div class=\"line\">child.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;child&apos;), true)</div><div class=\"line\">// 点击child, 输出: container，child</div><div class=\"line\"></div><div class=\"line\">container.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;container&apos;))</div><div class=\"line\">child.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;child&apos;))</div><div class=\"line\">// 点击child, 输出: child，container</div></pre></td></tr></table></figure>\n<p>假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到<strong>阻止冒泡</strong>的方式：<code>stopPropagation</code>，改写child的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">child.addEventListener(&apos;click&apos;, e =&gt; &#123;</div><div class=\"line\">  console.log(&apos;child&apos;)</div><div class=\"line\">  e.stopPropagation()</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是<strong>阻止浏览器默认行为</strong>，如a标签跳转，submit提交等。</p>\n<p>还有一种方式称为<strong>事件委托</strong>，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">container.addEventListener(&quot;click&quot;, e =&gt; &#123;</div><div class=\"line\">  if (e.target.id === &apos;child&apos;) &#123;</div><div class=\"line\">    console.log(&apos;child&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>可见，当点击子元素依然会输出<code>child</code>，在某些特定场景利用事件委托可节省大量的性能。</p>\n<p>明白了上述事件关系，target与currentTarget也就易于理解了，简言之，<strong>target指引发出发事件的元素，currentTarget则指事件绑定的元素</strong>，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：</p>\n<ul>\n<li>mouseenter：鼠标进入时触发，不响应子元素冒泡事件</li>\n<li>mouseover：鼠标进入时触发，响应子元素冒泡事件</li>\n<li>mouseleave：鼠标离开时触发，不响应子元素冒泡事件</li>\n<li>mouseout：鼠标离开时触发，响应子元素冒泡事件</li>\n</ul>\n<p>让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg\" alt=\"\"></p>\n<p>场景如下：</p>\n<ul>\n<li>鼠标移入每一行，显示编辑按钮，移出则取消</li>\n<li>点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态</li>\n</ul>\n<p>其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。</p>\n<p>单看页面，其实就是ul&gt;li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：<code>&lt;div class=&quot;schedule-input-wrap&quot; v-show=&quot;isEdit || hovering&quot;&gt;</code>，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。</p>\n<p>有了思路，首先考虑<strong>事件捕获机制</strong>，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为<code>pointer-events:none;</code>，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。</p>\n<p>后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul @mouseleave=&quot;hoverId=&apos;&apos;&quot;&gt;</div><div class=\"line\">    &lt;li v-for=&quot;(item, itemIndex) in record.schedulings&quot;</div><div class=\"line\">        @mouseenter=&quot;hoverId=`item$&#123;itemIndex&#125;`&quot;</div><div class=\"line\">        ....</div><div class=\"line\">        &lt;schedule-input :hovering=&quot;isHovering(itemIndex)&quot;</div><div class=\"line\">        &gt;&lt;/schedule-input&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<p>其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。</p>\n"},{"layout":"post","title":"js代理函数技巧","date":"2016-12-08T17:06:48.000Z","_content":"\n#### 简述\n有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？\n\n#### 示例\n假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：\n```\nfunction splice(arrs, start, length) {\n  arrs.splice(start, length);\n  return arrs;\n}\n\nconst arrs = [1,2,3];\nsplice(arrs, 1, 1); // 返回为：[1,3]\n```\n\n如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：\n\n```\nfunction splice(arrs, start, length) {\n  console.log(`索引位置：${start}, 长度${length}，元素为：${arrs.splice(start, length)}`);\n  return arrs;\n}\nconst arrs = [1,2,3];\nsplice(arrs, 1, 2); // 返回为: [1]\n// 索引位置：1, 长度2，元素为：2,3\n```\n\n上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:\n\n```\nconst arrs = [1,2,3];\nconst proxy = (...args) => {\n  const cutArrs = arrs.splice.apply(arrs, args);\n  console.log(`索引位置：${args[0]}, 长度${args[1]}，元素为：${cutArrs}`);\n}\nproxy(1, 2); // 索引位置：1, 长度2，元素为：2,3\nconsole.log(arrs); // [1]\n```\n\n#### 代理做了什么\n通过proxy(...)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。\n\n原理如下\n1. 将参数通过...args传入，它会变为一个args数组\n2. 通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身\n3. 在proxy方法体中进行进一步操作，构造完毕\n4. 按原顺序传入参数，进行执行。\n\n#### 实际用例\n在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：\n```\n// reset方法通过reduxForm包装来注入：\nexport default reduxForm({\n  form: 'xxx',\n})(xxx);\n\n// 清除按钮\n<button\n  type=\"button\"\n  className={style['invoice-btn']}\n  onClick={this.props.reset}\n>\n```\n\n我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：\n```\n<button\n  type=\"button\"\n  className={style['xxx']}\n  onClick={(...args) => {\n    reset.apply(this, args);\n    this.props.hideit();\n  }}\n>\n\n```\n\n#### 结尾\n谢谢阅读。\n","source":"_posts/js代理函数技巧.md","raw":"---\nlayout: post\ntitle: js代理函数技巧\ndate: 2016/12/09 01:06:48\ntags: js\n---\n\n#### 简述\n有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？\n\n#### 示例\n假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：\n```\nfunction splice(arrs, start, length) {\n  arrs.splice(start, length);\n  return arrs;\n}\n\nconst arrs = [1,2,3];\nsplice(arrs, 1, 1); // 返回为：[1,3]\n```\n\n如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：\n\n```\nfunction splice(arrs, start, length) {\n  console.log(`索引位置：${start}, 长度${length}，元素为：${arrs.splice(start, length)}`);\n  return arrs;\n}\nconst arrs = [1,2,3];\nsplice(arrs, 1, 2); // 返回为: [1]\n// 索引位置：1, 长度2，元素为：2,3\n```\n\n上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:\n\n```\nconst arrs = [1,2,3];\nconst proxy = (...args) => {\n  const cutArrs = arrs.splice.apply(arrs, args);\n  console.log(`索引位置：${args[0]}, 长度${args[1]}，元素为：${cutArrs}`);\n}\nproxy(1, 2); // 索引位置：1, 长度2，元素为：2,3\nconsole.log(arrs); // [1]\n```\n\n#### 代理做了什么\n通过proxy(...)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。\n\n原理如下\n1. 将参数通过...args传入，它会变为一个args数组\n2. 通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身\n3. 在proxy方法体中进行进一步操作，构造完毕\n4. 按原顺序传入参数，进行执行。\n\n#### 实际用例\n在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：\n```\n// reset方法通过reduxForm包装来注入：\nexport default reduxForm({\n  form: 'xxx',\n})(xxx);\n\n// 清除按钮\n<button\n  type=\"button\"\n  className={style['invoice-btn']}\n  onClick={this.props.reset}\n>\n```\n\n我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：\n```\n<button\n  type=\"button\"\n  className={style['xxx']}\n  onClick={(...args) => {\n    reset.apply(this, args);\n    this.props.hideit();\n  }}\n>\n\n```\n\n#### 结尾\n谢谢阅读。\n","slug":"js代理函数技巧","published":1,"updated":"2017-10-08T13:58:51.467Z","comments":1,"photos":[],"link":"","_id":"cjaggj8bf000enuc3ofzijr70","content":"<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  arrs.splice(start, length);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 1); // 返回为：[1,3]</div></pre></td></tr></table></figure></p>\n<p>如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  console.log(`索引位置：$&#123;start&#125;, 长度$&#123;length&#125;，元素为：$&#123;arrs.splice(start, length)&#125;`);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 2); // 返回为: [1]</div><div class=\"line\">// 索引位置：1, 长度2，元素为：2,3</div></pre></td></tr></table></figure>\n<p>上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">const proxy = (...args) =&gt; &#123;</div><div class=\"line\">  const cutArrs = arrs.splice.apply(arrs, args);</div><div class=\"line\">  console.log(`索引位置：$&#123;args[0]&#125;, 长度$&#123;args[1]&#125;，元素为：$&#123;cutArrs&#125;`);</div><div class=\"line\">&#125;</div><div class=\"line\">proxy(1, 2); // 索引位置：1, 长度2，元素为：2,3</div><div class=\"line\">console.log(arrs); // [1]</div></pre></td></tr></table></figure>\n<h4 id=\"代理做了什么\"><a href=\"#代理做了什么\" class=\"headerlink\" title=\"代理做了什么\"></a>代理做了什么</h4><p>通过proxy(…)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。</p>\n<p>原理如下</p>\n<ol>\n<li>将参数通过…args传入，它会变为一个args数组</li>\n<li>通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身</li>\n<li>在proxy方法体中进行进一步操作，构造完毕</li>\n<li>按原顺序传入参数，进行执行。</li>\n</ol>\n<h4 id=\"实际用例\"><a href=\"#实际用例\" class=\"headerlink\" title=\"实际用例\"></a>实际用例</h4><p>在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// reset方法通过reduxForm包装来注入：</div><div class=\"line\">export default reduxForm(&#123;</div><div class=\"line\">  form: &apos;xxx&apos;,</div><div class=\"line\">&#125;)(xxx);</div><div class=\"line\"></div><div class=\"line\">// 清除按钮</div><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;invoice-btn&apos;]&#125;</div><div class=\"line\">  onClick=&#123;this.props.reset&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;xxx&apos;]&#125;</div><div class=\"line\">  onClick=&#123;(...args) =&gt; &#123;</div><div class=\"line\">    reset.apply(this, args);</div><div class=\"line\">    this.props.hideit();</div><div class=\"line\">  &#125;&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>谢谢阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  arrs.splice(start, length);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 1); // 返回为：[1,3]</div></pre></td></tr></table></figure></p>\n<p>如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  console.log(`索引位置：$&#123;start&#125;, 长度$&#123;length&#125;，元素为：$&#123;arrs.splice(start, length)&#125;`);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 2); // 返回为: [1]</div><div class=\"line\">// 索引位置：1, 长度2，元素为：2,3</div></pre></td></tr></table></figure>\n<p>上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">const proxy = (...args) =&gt; &#123;</div><div class=\"line\">  const cutArrs = arrs.splice.apply(arrs, args);</div><div class=\"line\">  console.log(`索引位置：$&#123;args[0]&#125;, 长度$&#123;args[1]&#125;，元素为：$&#123;cutArrs&#125;`);</div><div class=\"line\">&#125;</div><div class=\"line\">proxy(1, 2); // 索引位置：1, 长度2，元素为：2,3</div><div class=\"line\">console.log(arrs); // [1]</div></pre></td></tr></table></figure>\n<h4 id=\"代理做了什么\"><a href=\"#代理做了什么\" class=\"headerlink\" title=\"代理做了什么\"></a>代理做了什么</h4><p>通过proxy(…)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。</p>\n<p>原理如下</p>\n<ol>\n<li>将参数通过…args传入，它会变为一个args数组</li>\n<li>通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身</li>\n<li>在proxy方法体中进行进一步操作，构造完毕</li>\n<li>按原顺序传入参数，进行执行。</li>\n</ol>\n<h4 id=\"实际用例\"><a href=\"#实际用例\" class=\"headerlink\" title=\"实际用例\"></a>实际用例</h4><p>在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// reset方法通过reduxForm包装来注入：</div><div class=\"line\">export default reduxForm(&#123;</div><div class=\"line\">  form: &apos;xxx&apos;,</div><div class=\"line\">&#125;)(xxx);</div><div class=\"line\"></div><div class=\"line\">// 清除按钮</div><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;invoice-btn&apos;]&#125;</div><div class=\"line\">  onClick=&#123;this.props.reset&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;xxx&apos;]&#125;</div><div class=\"line\">  onClick=&#123;(...args) =&gt; &#123;</div><div class=\"line\">    reset.apply(this, args);</div><div class=\"line\">    this.props.hideit();</div><div class=\"line\">  &#125;&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>谢谢阅读。</p>\n"},{"layout":"post","title":"js变量申明解析","date":"2016-12-09T09:30:24.000Z","_content":"\n\nvar属性有多种需要注意的特性：\n1. 无块级作用域\n2. 不带申明类型默认为全局变量\n3. 变量提升\n4. 运行重新申明变量\n\n#### 一、块级作用域\n\n首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：\n\n```\nfor (var i = 0; i < 100; i++){\n  // ...\n}\nconsole.log(i); // 输入100\n```\n\n若我们使用es6的let与const，就不会出现这种问题。\n\n#### 二、影响全局\n\n若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：\n\n```\nconst obj = {\n  a: 'a',\n  b: 'b',\n};\nwith (obj) {\n  console.log(a, b); // a b\n  b = 3;\n  c = 1;\n}\nconsole.log(obj.b, c); // 3 1\n```\n\n在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:\n\n```\nconst testobj = { foo: 'bar' };\nlet value;\nlet starttime;\nlet endtime;\nconst times = 1000000;\n\nstarttime = new Date().getTime();\nfor (let n = 0; n < times; n++) {\n  value = testobj.foo;\n}\nendtime = new Date().getTime();\nconsole.log(`正常赋值操作:${endtime - starttime}ms`);\n\nstarttime = new Date().getTime();\nwith (testobj) {\n  for (let n = 0; n < times; n++) {\n    value = foo;\n  }\n}\nendtime = new Date().getTime();\nconsole.log(`with赋值操作:${endtime - starttime}ms`);\n\n*****输出结果\n正常赋值操作:25ms\nwith赋值操作:415ms\n```\n\n造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。\n\n#### 三、变量提升\n大家肯定熟悉函数提升，可将函数定义放在调用代码之后：\n\n```\na(); // haha\nfunction a() {\n    console.log('haha');\n}\n```\n\n函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。\n\n在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:\n\n```\nconsole.log(a); // undefined\nvar a = '1';\n```\n\n其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。\n\n只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：`暂时性死区`。\n\n> 暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。\n\n这里有一个例子：\n\n```\nvar a = 1\nif(true){\n    console.log(a) //ReferenceError\n    let a = 2\n}\n```\n\n变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：\n\n```\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n#### 四、全局对象属性\n全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。\n\n```\n(function(){\n  a = 3\n})()\nvar b = 2\nconsole.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性\n\nlet c = 123\nconst d = 456\nconsole.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩\n```\n\n#### 总结\n在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。\n","source":"_posts/js变量申明解析.md","raw":"---\nlayout: post\ntitle: js变量申明解析\ndate: 2016/12/09 17:30:24\ntags: js\n---\n\n\nvar属性有多种需要注意的特性：\n1. 无块级作用域\n2. 不带申明类型默认为全局变量\n3. 变量提升\n4. 运行重新申明变量\n\n#### 一、块级作用域\n\n首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：\n\n```\nfor (var i = 0; i < 100; i++){\n  // ...\n}\nconsole.log(i); // 输入100\n```\n\n若我们使用es6的let与const，就不会出现这种问题。\n\n#### 二、影响全局\n\n若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：\n\n```\nconst obj = {\n  a: 'a',\n  b: 'b',\n};\nwith (obj) {\n  console.log(a, b); // a b\n  b = 3;\n  c = 1;\n}\nconsole.log(obj.b, c); // 3 1\n```\n\n在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:\n\n```\nconst testobj = { foo: 'bar' };\nlet value;\nlet starttime;\nlet endtime;\nconst times = 1000000;\n\nstarttime = new Date().getTime();\nfor (let n = 0; n < times; n++) {\n  value = testobj.foo;\n}\nendtime = new Date().getTime();\nconsole.log(`正常赋值操作:${endtime - starttime}ms`);\n\nstarttime = new Date().getTime();\nwith (testobj) {\n  for (let n = 0; n < times; n++) {\n    value = foo;\n  }\n}\nendtime = new Date().getTime();\nconsole.log(`with赋值操作:${endtime - starttime}ms`);\n\n*****输出结果\n正常赋值操作:25ms\nwith赋值操作:415ms\n```\n\n造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。\n\n#### 三、变量提升\n大家肯定熟悉函数提升，可将函数定义放在调用代码之后：\n\n```\na(); // haha\nfunction a() {\n    console.log('haha');\n}\n```\n\n函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。\n\n在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:\n\n```\nconsole.log(a); // undefined\nvar a = '1';\n```\n\n其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。\n\n只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：`暂时性死区`。\n\n> 暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。\n\n这里有一个例子：\n\n```\nvar a = 1\nif(true){\n    console.log(a) //ReferenceError\n    let a = 2\n}\n```\n\n变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：\n\n```\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n#### 四、全局对象属性\n全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。\n\n```\n(function(){\n  a = 3\n})()\nvar b = 2\nconsole.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性\n\nlet c = 123\nconst d = 456\nconsole.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩\n```\n\n#### 总结\n在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。\n","slug":"js变量申明解析","published":1,"updated":"2017-10-08T13:58:47.308Z","comments":1,"photos":[],"link":"","_id":"cjaggj8bk000gnuc3u5gejck8","content":"<p>var属性有多种需要注意的特性：</p>\n<ol>\n<li>无块级作用域</li>\n<li>不带申明类型默认为全局变量</li>\n<li>变量提升</li>\n<li>运行重新申明变量</li>\n</ol>\n<h4 id=\"一、块级作用域\"><a href=\"#一、块级作用域\" class=\"headerlink\" title=\"一、块级作用域\"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; 100; i++)&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(i); // 输入100</div></pre></td></tr></table></figure>\n<p>若我们使用es6的let与const，就不会出现这种问题。</p>\n<h4 id=\"二、影响全局\"><a href=\"#二、影响全局\" class=\"headerlink\" title=\"二、影响全局\"></a>二、影响全局</h4><p>若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const obj = &#123;</div><div class=\"line\">  a: &apos;a&apos;,</div><div class=\"line\">  b: &apos;b&apos;,</div><div class=\"line\">&#125;;</div><div class=\"line\">with (obj) &#123;</div><div class=\"line\">  console.log(a, b); // a b</div><div class=\"line\">  b = 3;</div><div class=\"line\">  c = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(obj.b, c); // 3 1</div></pre></td></tr></table></figure>\n<p>在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">const testobj = &#123; foo: &apos;bar&apos; &#125;;</div><div class=\"line\">let value;</div><div class=\"line\">let starttime;</div><div class=\"line\">let endtime;</div><div class=\"line\">const times = 1000000;</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">  value = testobj.foo;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`正常赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">with (testobj) &#123;</div><div class=\"line\">  for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">    value = foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`with赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">*****输出结果</div><div class=\"line\">正常赋值操作:25ms</div><div class=\"line\">with赋值操作:415ms</div></pre></td></tr></table></figure>\n<p>造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。</p>\n<h4 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h4><p>大家肯定熟悉函数提升，可将函数定义放在调用代码之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a(); // haha</div><div class=\"line\">function a() &#123;</div><div class=\"line\">    console.log(&apos;haha&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。</p>\n<p>在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(a); // undefined</div><div class=\"line\">var a = &apos;1&apos;;</div></pre></td></tr></table></figure>\n<p>其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。</p>\n<p>只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：<code>暂时性死区</code>。</p>\n<blockquote>\n<p>暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。</p>\n</blockquote>\n<p>这里有一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1</div><div class=\"line\">if(true)&#123;</div><div class=\"line\">    console.log(a) //ReferenceError</div><div class=\"line\">    let a = 2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var tmp = new Date();</div><div class=\"line\"></div><div class=\"line\">function f() &#123;</div><div class=\"line\">  console.log(tmp);</div><div class=\"line\">  if (false) &#123;</div><div class=\"line\">    var tmp = &quot;hello world&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); // undefined</div></pre></td></tr></table></figure>\n<h4 id=\"四、全局对象属性\"><a href=\"#四、全局对象属性\" class=\"headerlink\" title=\"四、全局对象属性\"></a>四、全局对象属性</h4><p>全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  a = 3</div><div class=\"line\">&#125;)()</div><div class=\"line\">var b = 2</div><div class=\"line\">console.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性</div><div class=\"line\"></div><div class=\"line\">let c = 123</div><div class=\"line\">const d = 456</div><div class=\"line\">console.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩</div></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>var属性有多种需要注意的特性：</p>\n<ol>\n<li>无块级作用域</li>\n<li>不带申明类型默认为全局变量</li>\n<li>变量提升</li>\n<li>运行重新申明变量</li>\n</ol>\n<h4 id=\"一、块级作用域\"><a href=\"#一、块级作用域\" class=\"headerlink\" title=\"一、块级作用域\"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; 100; i++)&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(i); // 输入100</div></pre></td></tr></table></figure>\n<p>若我们使用es6的let与const，就不会出现这种问题。</p>\n<h4 id=\"二、影响全局\"><a href=\"#二、影响全局\" class=\"headerlink\" title=\"二、影响全局\"></a>二、影响全局</h4><p>若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const obj = &#123;</div><div class=\"line\">  a: &apos;a&apos;,</div><div class=\"line\">  b: &apos;b&apos;,</div><div class=\"line\">&#125;;</div><div class=\"line\">with (obj) &#123;</div><div class=\"line\">  console.log(a, b); // a b</div><div class=\"line\">  b = 3;</div><div class=\"line\">  c = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(obj.b, c); // 3 1</div></pre></td></tr></table></figure>\n<p>在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">const testobj = &#123; foo: &apos;bar&apos; &#125;;</div><div class=\"line\">let value;</div><div class=\"line\">let starttime;</div><div class=\"line\">let endtime;</div><div class=\"line\">const times = 1000000;</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">  value = testobj.foo;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`正常赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">with (testobj) &#123;</div><div class=\"line\">  for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">    value = foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`with赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">*****输出结果</div><div class=\"line\">正常赋值操作:25ms</div><div class=\"line\">with赋值操作:415ms</div></pre></td></tr></table></figure>\n<p>造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。</p>\n<h4 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h4><p>大家肯定熟悉函数提升，可将函数定义放在调用代码之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a(); // haha</div><div class=\"line\">function a() &#123;</div><div class=\"line\">    console.log(&apos;haha&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。</p>\n<p>在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(a); // undefined</div><div class=\"line\">var a = &apos;1&apos;;</div></pre></td></tr></table></figure>\n<p>其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。</p>\n<p>只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：<code>暂时性死区</code>。</p>\n<blockquote>\n<p>暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。</p>\n</blockquote>\n<p>这里有一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1</div><div class=\"line\">if(true)&#123;</div><div class=\"line\">    console.log(a) //ReferenceError</div><div class=\"line\">    let a = 2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var tmp = new Date();</div><div class=\"line\"></div><div class=\"line\">function f() &#123;</div><div class=\"line\">  console.log(tmp);</div><div class=\"line\">  if (false) &#123;</div><div class=\"line\">    var tmp = &quot;hello world&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); // undefined</div></pre></td></tr></table></figure>\n<h4 id=\"四、全局对象属性\"><a href=\"#四、全局对象属性\" class=\"headerlink\" title=\"四、全局对象属性\"></a>四、全局对象属性</h4><p>全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  a = 3</div><div class=\"line\">&#125;)()</div><div class=\"line\">var b = 2</div><div class=\"line\">console.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性</div><div class=\"line\"></div><div class=\"line\">let c = 123</div><div class=\"line\">const d = 456</div><div class=\"line\">console.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩</div></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。</p>\n"},{"title":"jenkins部署","date":"2017-10-18T15:59:52.000Z","_content":"Jenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。\n\n典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。\n\n## Jenkins部署步骤\n\n准备工作如下：\n\n1. 服务器安装docker\n2. 拉取镜像：`docker pull jenkins/jenkins`\n3. 创建一个文件夹`jenkins_home`用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：`chown 1000 ./jenkins_home`\n\n做完以上流程，即可执行：\n\n```\ndocker run -d --name jenkins_node -p 8899:8080 -v /var/jenkins_home:/var/jenkins_home jenkins/jenkins\n```\n\n其中，参数如下定义：\n\n- -d，docker进程在后台运行\n- -name，docker容器名称\n- -p，映射docker端口8080为本地端口8899，通过`localhost:8899`即可访问\n- -v，将服务器的`/var/jenkins_home`挂载到docker容器的`/var/jenkins_home`\n\n以上步骤都执行成功后，访问`server_ip/8899`可以看到如下页面：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-18/84127408.jpg)\n\n此时查询到container ID， 然后通过`docker logs id`可以查询到密钥就在log中：\n\n```\nINFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n```\n","source":"_posts/jenkins-deploy.md","raw":"---\ntitle: jenkins部署\ndate: 2017-10-18 23:59:52\ntags:\n---\nJenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。\n\n典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。\n\n## Jenkins部署步骤\n\n准备工作如下：\n\n1. 服务器安装docker\n2. 拉取镜像：`docker pull jenkins/jenkins`\n3. 创建一个文件夹`jenkins_home`用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：`chown 1000 ./jenkins_home`\n\n做完以上流程，即可执行：\n\n```\ndocker run -d --name jenkins_node -p 8899:8080 -v /var/jenkins_home:/var/jenkins_home jenkins/jenkins\n```\n\n其中，参数如下定义：\n\n- -d，docker进程在后台运行\n- -name，docker容器名称\n- -p，映射docker端口8080为本地端口8899，通过`localhost:8899`即可访问\n- -v，将服务器的`/var/jenkins_home`挂载到docker容器的`/var/jenkins_home`\n\n以上步骤都执行成功后，访问`server_ip/8899`可以看到如下页面：\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/17-10-18/84127408.jpg)\n\n此时查询到container ID， 然后通过`docker logs id`可以查询到密钥就在log中：\n\n```\nINFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n```\n","slug":"jenkins-deploy","published":1,"updated":"2017-10-18T16:00:52.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8bu000jnuc3qvb56tam","content":"<p>Jenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。</p>\n<p>典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。</p>\n<h2 id=\"Jenkins部署步骤\"><a href=\"#Jenkins部署步骤\" class=\"headerlink\" title=\"Jenkins部署步骤\"></a>Jenkins部署步骤</h2><p>准备工作如下：</p>\n<ol>\n<li>服务器安装docker</li>\n<li>拉取镜像：<code>docker pull jenkins/jenkins</code></li>\n<li>创建一个文件夹<code>jenkins_home</code>用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：<code>chown 1000 ./jenkins_home</code></li>\n</ol>\n<p>做完以上流程，即可执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --name jenkins_node -p 8899:8080 -v /var/jenkins_home:/var/jenkins_home jenkins/jenkins</div></pre></td></tr></table></figure>\n<p>其中，参数如下定义：</p>\n<ul>\n<li>-d，docker进程在后台运行</li>\n<li>-name，docker容器名称</li>\n<li>-p，映射docker端口8080为本地端口8899，通过<code>localhost:8899</code>即可访问</li>\n<li>-v，将服务器的<code>/var/jenkins_home</code>挂载到docker容器的<code>/var/jenkins_home</code></li>\n</ul>\n<p>以上步骤都执行成功后，访问<code>server_ip/8899</code>可以看到如下页面：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-18/84127408.jpg\" alt=\"\"></p>\n<p>此时查询到container ID， 然后通过<code>docker logs id</code>可以查询到密钥就在log中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">INFO:</div><div class=\"line\"></div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\"></div><div class=\"line\">Jenkins initial setup is required. An admin user has been created and a password generated.</div><div class=\"line\">Please use the following password to proceed to installation:</div><div class=\"line\"></div><div class=\"line\">密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥</div><div class=\"line\"></div><div class=\"line\">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</div><div class=\"line\"></div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Jenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。</p>\n<p>典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。</p>\n<h2 id=\"Jenkins部署步骤\"><a href=\"#Jenkins部署步骤\" class=\"headerlink\" title=\"Jenkins部署步骤\"></a>Jenkins部署步骤</h2><p>准备工作如下：</p>\n<ol>\n<li>服务器安装docker</li>\n<li>拉取镜像：<code>docker pull jenkins/jenkins</code></li>\n<li>创建一个文件夹<code>jenkins_home</code>用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：<code>chown 1000 ./jenkins_home</code></li>\n</ol>\n<p>做完以上流程，即可执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --name jenkins_node -p 8899:8080 -v /var/jenkins_home:/var/jenkins_home jenkins/jenkins</div></pre></td></tr></table></figure>\n<p>其中，参数如下定义：</p>\n<ul>\n<li>-d，docker进程在后台运行</li>\n<li>-name，docker容器名称</li>\n<li>-p，映射docker端口8080为本地端口8899，通过<code>localhost:8899</code>即可访问</li>\n<li>-v，将服务器的<code>/var/jenkins_home</code>挂载到docker容器的<code>/var/jenkins_home</code></li>\n</ul>\n<p>以上步骤都执行成功后，访问<code>server_ip/8899</code>可以看到如下页面：</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/17-10-18/84127408.jpg\" alt=\"\"></p>\n<p>此时查询到container ID， 然后通过<code>docker logs id</code>可以查询到密钥就在log中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">INFO:</div><div class=\"line\"></div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\"></div><div class=\"line\">Jenkins initial setup is required. An admin user has been created and a password generated.</div><div class=\"line\">Please use the following password to proceed to installation:</div><div class=\"line\"></div><div class=\"line\">密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥密钥</div><div class=\"line\"></div><div class=\"line\">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</div><div class=\"line\"></div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div><div class=\"line\">*************************************************************</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"nodejs中exports与module.exports的区别","date":"2016-12-25T15:52:57.000Z","_content":"\n在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。\n\n### require()的返回值\nrequire()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：\n\ntest.js:\n\n```\nmodule.exports = function(){\n    console.log('I\\'m module.exports')\n}\nexports = function(){\n    console.log('I\\'m exports')\n}\n```\n\n通过`var a = require('./test')()`即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。\n\n### exports是module.exports的一个指针\n假设有两个变量，`var a={name:'name1}, var b = a;`，b指向a的内存区域，如果执行`b.name='name2'`，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。\n\n可如果我们执行`a = {}`或者`b = {}`之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：\n1. module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。\n2. exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。\n3. exports.xxx与module.exports.xxx等价且可以共同存在。\n","source":"_posts/nodejs中exports与module-exports的区别.md","raw":"---\nlayout: post\ntitle: nodejs中exports与module.exports的区别\ndate: 2016/12/25 23:52:57\ntags: nodejs\n---\n\n在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。\n\n### require()的返回值\nrequire()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：\n\ntest.js:\n\n```\nmodule.exports = function(){\n    console.log('I\\'m module.exports')\n}\nexports = function(){\n    console.log('I\\'m exports')\n}\n```\n\n通过`var a = require('./test')()`即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。\n\n### exports是module.exports的一个指针\n假设有两个变量，`var a={name:'name1}, var b = a;`，b指向a的内存区域，如果执行`b.name='name2'`，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。\n\n可如果我们执行`a = {}`或者`b = {}`之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：\n1. module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。\n2. exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。\n3. exports.xxx与module.exports.xxx等价且可以共同存在。\n","slug":"nodejs中exports与module-exports的区别","published":1,"updated":"2017-10-08T13:58:32.077Z","comments":1,"photos":[],"link":"","_id":"cjaggj8bv000lnuc31z2kl9t5","content":"<p>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。</p>\n<h3 id=\"require-的返回值\"><a href=\"#require-的返回值\" class=\"headerlink\" title=\"require()的返回值\"></a>require()的返回值</h3><p>require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：</p>\n<p>test.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m module.exports&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m exports&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>var a = require(&#39;./test&#39;)()</code>即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。</p>\n<h3 id=\"exports是module-exports的一个指针\"><a href=\"#exports是module-exports的一个指针\" class=\"headerlink\" title=\"exports是module.exports的一个指针\"></a>exports是module.exports的一个指针</h3><p>假设有两个变量，<code>var a={name:&#39;name1}, var b = a;</code>，b指向a的内存区域，如果执行<code>b.name=&#39;name2&#39;</code>，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。</p>\n<p>可如果我们执行<code>a = {}</code>或者<code>b = {}</code>之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：</p>\n<ol>\n<li>module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。</li>\n<li>exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。</li>\n<li>exports.xxx与module.exports.xxx等价且可以共同存在。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。</p>\n<h3 id=\"require-的返回值\"><a href=\"#require-的返回值\" class=\"headerlink\" title=\"require()的返回值\"></a>require()的返回值</h3><p>require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：</p>\n<p>test.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m module.exports&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m exports&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>var a = require(&#39;./test&#39;)()</code>即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。</p>\n<h3 id=\"exports是module-exports的一个指针\"><a href=\"#exports是module-exports的一个指针\" class=\"headerlink\" title=\"exports是module.exports的一个指针\"></a>exports是module.exports的一个指针</h3><p>假设有两个变量，<code>var a={name:&#39;name1}, var b = a;</code>，b指向a的内存区域，如果执行<code>b.name=&#39;name2&#39;</code>，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。</p>\n<p>可如果我们执行<code>a = {}</code>或者<code>b = {}</code>之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：</p>\n<ol>\n<li>module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。</li>\n<li>exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。</li>\n<li>exports.xxx与module.exports.xxx等价且可以共同存在。</li>\n</ol>\n"},{"layout":"post","title":"js变量作用域与垃圾回收","date":"2016-11-20T16:26:18.000Z","_content":"\n## 栈内存与堆内存\njs变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:\n\n```javascript\nconst name = '某某某';\nconst age = 22;\nconst hasGf = false;\nconst obj = {\n  test: 123,\n}\nconst anotherObj = obj;\n```\n\n它们在内存中的结构如图：\n\n![](/imgs/js变量的内存管理.jpg)\n\n* 栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间\n* 堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用\n\n由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:\n\n* 基本类型直接在栈内存中进行复制值\n* 引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象\n\n既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:\n\n```\n\nfunction test(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n + test(n - 1);\n}\ntest(10000); // 50005000\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:\n\n```\ntest(5)\n5 + test(4)\n5 + (4 + test(3))\n5 + (4 + (3 + test(2)))\n5 + (4 + (3 + (2 + test(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n\n正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:\n\n```\nfunction test(n, count) {\n  if (n === 0) {\n    return count;\n  }\n  return test(n - 1, count + n);\n}\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：\n```\nTemporarily Removed in Babel 6\nOnly explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.\n```\n\n\n那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:\n\n```\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction test(x, count) {\n    function recur(x, count) {\n        if (x > 0) {\n          return recur.bind(null, x - 1, count + x);\n        } else {\n          return count;\n        }\n    }\n    return trampoline(recur.bind(null, x, count));\n}\n\nconsole.log(test(100000, 0)); // 5000050000\n```\n\n\n## 内存泄漏\njavascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：\n\n1. 遍历所有可访问的对象。\n2. 回收已不可访问的对象。\n\n因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.\n\n\n#### 闭包拾遗\n通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:\n\n```\nfunction outerFn() {\n  var a = 0;\n  function innerFn() {\n    console.log(a++);\n  }\n  return innerFn;\n}\n\nvar fn = outerFn();\nfn(); // 0\nfn(); // 1\n```\n\n\n\n#### 在函数内创建全局变量\n若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:\n\n```\nfunction Test() {\n  hehe = 123;\n  this.a = 1;\n}\nTest();\nconsole.log(hehe, a); // 123, 1\n```\n\n#### 循环引用\n如果dom元素操作不当, 很容易造成非常规的内存占用:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  element.onclick = function () {\n    alert(element.id);\n  };\n}\n```\n\n由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  var id = element.id;\n  element.onclick = function () {\n    alert(id);\n  };\n  element = null;\n}\n```\n","source":"_posts/js变量的内存管理.md","raw":"---\nlayout: post\ntitle: js变量作用域与垃圾回收\ndate: 2016/11/21 00:26:18\ntags: js\n---\n\n## 栈内存与堆内存\njs变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:\n\n```javascript\nconst name = '某某某';\nconst age = 22;\nconst hasGf = false;\nconst obj = {\n  test: 123,\n}\nconst anotherObj = obj;\n```\n\n它们在内存中的结构如图：\n\n![](/imgs/js变量的内存管理.jpg)\n\n* 栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间\n* 堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用\n\n由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:\n\n* 基本类型直接在栈内存中进行复制值\n* 引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象\n\n既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:\n\n```\n\nfunction test(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n + test(n - 1);\n}\ntest(10000); // 50005000\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:\n\n```\ntest(5)\n5 + test(4)\n5 + (4 + test(3))\n5 + (4 + (3 + test(2)))\n5 + (4 + (3 + (2 + test(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n\n正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:\n\n```\nfunction test(n, count) {\n  if (n === 0) {\n    return count;\n  }\n  return test(n - 1, count + n);\n}\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：\n```\nTemporarily Removed in Babel 6\nOnly explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.\n```\n\n\n那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:\n\n```\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction test(x, count) {\n    function recur(x, count) {\n        if (x > 0) {\n          return recur.bind(null, x - 1, count + x);\n        } else {\n          return count;\n        }\n    }\n    return trampoline(recur.bind(null, x, count));\n}\n\nconsole.log(test(100000, 0)); // 5000050000\n```\n\n\n## 内存泄漏\njavascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：\n\n1. 遍历所有可访问的对象。\n2. 回收已不可访问的对象。\n\n因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.\n\n\n#### 闭包拾遗\n通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:\n\n```\nfunction outerFn() {\n  var a = 0;\n  function innerFn() {\n    console.log(a++);\n  }\n  return innerFn;\n}\n\nvar fn = outerFn();\nfn(); // 0\nfn(); // 1\n```\n\n\n\n#### 在函数内创建全局变量\n若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:\n\n```\nfunction Test() {\n  hehe = 123;\n  this.a = 1;\n}\nTest();\nconsole.log(hehe, a); // 123, 1\n```\n\n#### 循环引用\n如果dom元素操作不当, 很容易造成非常规的内存占用:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  element.onclick = function () {\n    alert(element.id);\n  };\n}\n```\n\n由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  var id = element.id;\n  element.onclick = function () {\n    alert(id);\n  };\n  element = null;\n}\n```\n","slug":"js变量的内存管理","published":1,"updated":"2017-10-08T13:58:55.406Z","comments":1,"photos":[],"link":"","_id":"cjaggj8c3000onuc3e77cci17","content":"<h2 id=\"栈内存与堆内存\"><a href=\"#栈内存与堆内存\" class=\"headerlink\" title=\"栈内存与堆内存\"></a>栈内存与堆内存</h2><p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'某某某'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">22</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> hasGf = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  test: <span class=\"number\">123</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> anotherObj = obj;</div></pre></td></tr></table></figure>\n<p>它们在内存中的结构如图：</p>\n<p><img src=\"/imgs/js变量的内存管理.jpg\" alt=\"\"></p>\n<ul>\n<li>栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间</li>\n<li>堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用</li>\n</ul>\n<p>由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:</p>\n<ul>\n<li>基本类型直接在栈内存中进行复制值</li>\n<li>引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象</li>\n</ul>\n<p>既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function test(n) &#123;</div><div class=\"line\">  if (n === 1) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return n + test(n - 1);</div><div class=\"line\">&#125;</div><div class=\"line\">test(10000); // 50005000</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(5)</div><div class=\"line\">5 + test(4)</div><div class=\"line\">5 + (4 + test(3))</div><div class=\"line\">5 + (4 + (3 + test(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + test(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure>\n<p>正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function test(n, count) &#123;</div><div class=\"line\">  if (n === 0) &#123;</div><div class=\"line\">    return count;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return test(n - 1, count + n);</div><div class=\"line\">&#125;</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Temporarily Removed in Babel 6</div><div class=\"line\">Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</div></pre></td></tr></table></figure></p>\n<p>那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function trampoline(f) &#123;</div><div class=\"line\">    while (f &amp;&amp; f instanceof Function) &#123;</div><div class=\"line\">        f = f();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return f;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function test(x, count) &#123;</div><div class=\"line\">    function recur(x, count) &#123;</div><div class=\"line\">        if (x &gt; 0) &#123;</div><div class=\"line\">          return recur.bind(null, x - 1, count + x);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">          return count;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return trampoline(recur.bind(null, x, count));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(test(100000, 0)); // 5000050000</div></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>javascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：</p>\n<ol>\n<li>遍历所有可访问的对象。</li>\n<li>回收已不可访问的对象。</li>\n</ol>\n<p>因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.</p>\n<h4 id=\"闭包拾遗\"><a href=\"#闭包拾遗\" class=\"headerlink\" title=\"闭包拾遗\"></a>闭包拾遗</h4><p>通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerFn() &#123;</div><div class=\"line\">  var a = 0;</div><div class=\"line\">  function innerFn() &#123;</div><div class=\"line\">    console.log(a++);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var fn = outerFn();</div><div class=\"line\">fn(); // 0</div><div class=\"line\">fn(); // 1</div></pre></td></tr></table></figure>\n<h4 id=\"在函数内创建全局变量\"><a href=\"#在函数内创建全局变量\" class=\"headerlink\" title=\"在函数内创建全局变量\"></a>在函数内创建全局变量</h4><p>若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test() &#123;</div><div class=\"line\">  hehe = 123;</div><div class=\"line\">  this.a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">Test();</div><div class=\"line\">console.log(hehe, a); // 123, 1</div></pre></td></tr></table></figure>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>如果dom元素操作不当, 很容易造成非常规的内存占用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(element.id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  var id = element.id;</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  element = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"栈内存与堆内存\"><a href=\"#栈内存与堆内存\" class=\"headerlink\" title=\"栈内存与堆内存\"></a>栈内存与堆内存</h2><p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'某某某'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">22</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> hasGf = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  test: <span class=\"number\">123</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> anotherObj = obj;</div></pre></td></tr></table></figure>\n<p>它们在内存中的结构如图：</p>\n<p><img src=\"/imgs/js变量的内存管理.jpg\" alt=\"\"></p>\n<ul>\n<li>栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间</li>\n<li>堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用</li>\n</ul>\n<p>由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:</p>\n<ul>\n<li>基本类型直接在栈内存中进行复制值</li>\n<li>引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象</li>\n</ul>\n<p>既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function test(n) &#123;</div><div class=\"line\">  if (n === 1) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return n + test(n - 1);</div><div class=\"line\">&#125;</div><div class=\"line\">test(10000); // 50005000</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(5)</div><div class=\"line\">5 + test(4)</div><div class=\"line\">5 + (4 + test(3))</div><div class=\"line\">5 + (4 + (3 + test(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + test(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure>\n<p>正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function test(n, count) &#123;</div><div class=\"line\">  if (n === 0) &#123;</div><div class=\"line\">    return count;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return test(n - 1, count + n);</div><div class=\"line\">&#125;</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Temporarily Removed in Babel 6</div><div class=\"line\">Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</div></pre></td></tr></table></figure></p>\n<p>那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function trampoline(f) &#123;</div><div class=\"line\">    while (f &amp;&amp; f instanceof Function) &#123;</div><div class=\"line\">        f = f();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return f;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function test(x, count) &#123;</div><div class=\"line\">    function recur(x, count) &#123;</div><div class=\"line\">        if (x &gt; 0) &#123;</div><div class=\"line\">          return recur.bind(null, x - 1, count + x);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">          return count;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return trampoline(recur.bind(null, x, count));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(test(100000, 0)); // 5000050000</div></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>javascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：</p>\n<ol>\n<li>遍历所有可访问的对象。</li>\n<li>回收已不可访问的对象。</li>\n</ol>\n<p>因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.</p>\n<h4 id=\"闭包拾遗\"><a href=\"#闭包拾遗\" class=\"headerlink\" title=\"闭包拾遗\"></a>闭包拾遗</h4><p>通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerFn() &#123;</div><div class=\"line\">  var a = 0;</div><div class=\"line\">  function innerFn() &#123;</div><div class=\"line\">    console.log(a++);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var fn = outerFn();</div><div class=\"line\">fn(); // 0</div><div class=\"line\">fn(); // 1</div></pre></td></tr></table></figure>\n<h4 id=\"在函数内创建全局变量\"><a href=\"#在函数内创建全局变量\" class=\"headerlink\" title=\"在函数内创建全局变量\"></a>在函数内创建全局变量</h4><p>若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test() &#123;</div><div class=\"line\">  hehe = 123;</div><div class=\"line\">  this.a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">Test();</div><div class=\"line\">console.log(hehe, a); // 123, 1</div></pre></td></tr></table></figure>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>如果dom元素操作不当, 很容易造成非常规的内存占用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(element.id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  var id = element.id;</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  element = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"python变量作用域","date":"2016-12-25T15:43:05.000Z","_content":"\nclass比作整个屋子，def为卧室，class外面的部分就是小区环境。\n\n#### 首先测试房子(class)与公共设施变量(globals)之间的关系\n\n```\n# encoding: utf-8\n\nPUBLIC_FACILITIES = u\"公共厕所\"\n\nclass House():\n    print PUBLIC_FACILITIES\n    PUBLIC_FACILITIES = '改造'\n\nif __name__ == '__main__':\n    test = House()\n    print PUBLIC_FACILITIES\n\n```\n\n测试结果：\n\n```\n公共厕所\n公共厕所\n\n***Repl Closed***\n```\n\n房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。\n\n#### 测试房子(class)与房间(def)的关系\n\n```\n# encoding: utf-8\n\nclass House():\n    SOFA = u'真皮沙发'\n    def room(self):\n        # print SOFA # 无法直接访问外部变量，取消注释会报错\n        print self.SOFA\n        self.SOFA = '布质沙发'\n\n\nif __name__ == '__main__':\n    test = House()\n    test.room()\n    print test.SOFA, House.SOFA\n```\n\n测试结果：\n\n```\n真皮沙发\n布质沙发 真皮沙发\n\n***Repl Closed***\n```\n\n大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。\n\n#### 总结\n用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明`global variable`， 访问类变量要接上类名，如`class_name.variable`, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。\n","source":"_posts/python变量作用域.md","raw":"---\nlayout: post\ntitle: python变量作用域\ndate: 2016/12/25 23:43:05\ntags: python\n---\n\nclass比作整个屋子，def为卧室，class外面的部分就是小区环境。\n\n#### 首先测试房子(class)与公共设施变量(globals)之间的关系\n\n```\n# encoding: utf-8\n\nPUBLIC_FACILITIES = u\"公共厕所\"\n\nclass House():\n    print PUBLIC_FACILITIES\n    PUBLIC_FACILITIES = '改造'\n\nif __name__ == '__main__':\n    test = House()\n    print PUBLIC_FACILITIES\n\n```\n\n测试结果：\n\n```\n公共厕所\n公共厕所\n\n***Repl Closed***\n```\n\n房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。\n\n#### 测试房子(class)与房间(def)的关系\n\n```\n# encoding: utf-8\n\nclass House():\n    SOFA = u'真皮沙发'\n    def room(self):\n        # print SOFA # 无法直接访问外部变量，取消注释会报错\n        print self.SOFA\n        self.SOFA = '布质沙发'\n\n\nif __name__ == '__main__':\n    test = House()\n    test.room()\n    print test.SOFA, House.SOFA\n```\n\n测试结果：\n\n```\n真皮沙发\n布质沙发 真皮沙发\n\n***Repl Closed***\n```\n\n大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。\n\n#### 总结\n用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明`global variable`， 访问类变量要接上类名，如`class_name.variable`, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。\n","slug":"python变量作用域","published":1,"updated":"2017-10-08T13:58:25.166Z","comments":1,"photos":[],"link":"","_id":"cjaggj8c8000qnuc3khzkf3gn","content":"<p>class比作整个屋子，def为卧室，class外面的部分就是小区环境。</p>\n<h4 id=\"首先测试房子-class-与公共设施变量-globals-之间的关系\"><a href=\"#首先测试房子-class-与公共设施变量-globals-之间的关系\" class=\"headerlink\" title=\"首先测试房子(class)与公共设施变量(globals)之间的关系\"></a>首先测试房子(class)与公共设施变量(globals)之间的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">PUBLIC_FACILITIES = u&quot;公共厕所&quot;</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    print PUBLIC_FACILITIES</div><div class=\"line\">    PUBLIC_FACILITIES = &apos;改造&apos;</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    print PUBLIC_FACILITIES</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">公共厕所</div><div class=\"line\">公共厕所</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。</p>\n<h4 id=\"测试房子-class-与房间-def-的关系\"><a href=\"#测试房子-class-与房间-def-的关系\" class=\"headerlink\" title=\"测试房子(class)与房间(def)的关系\"></a>测试房子(class)与房间(def)的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    SOFA = u&apos;真皮沙发&apos;</div><div class=\"line\">    def room(self):</div><div class=\"line\">        # print SOFA # 无法直接访问外部变量，取消注释会报错</div><div class=\"line\">        print self.SOFA</div><div class=\"line\">        self.SOFA = &apos;布质沙发&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    test.room()</div><div class=\"line\">    print test.SOFA, House.SOFA</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">真皮沙发</div><div class=\"line\">布质沙发 真皮沙发</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明<code>global variable</code>， 访问类变量要接上类名，如<code>class_name.variable</code>, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>class比作整个屋子，def为卧室，class外面的部分就是小区环境。</p>\n<h4 id=\"首先测试房子-class-与公共设施变量-globals-之间的关系\"><a href=\"#首先测试房子-class-与公共设施变量-globals-之间的关系\" class=\"headerlink\" title=\"首先测试房子(class)与公共设施变量(globals)之间的关系\"></a>首先测试房子(class)与公共设施变量(globals)之间的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">PUBLIC_FACILITIES = u&quot;公共厕所&quot;</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    print PUBLIC_FACILITIES</div><div class=\"line\">    PUBLIC_FACILITIES = &apos;改造&apos;</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    print PUBLIC_FACILITIES</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">公共厕所</div><div class=\"line\">公共厕所</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。</p>\n<h4 id=\"测试房子-class-与房间-def-的关系\"><a href=\"#测试房子-class-与房间-def-的关系\" class=\"headerlink\" title=\"测试房子(class)与房间(def)的关系\"></a>测试房子(class)与房间(def)的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    SOFA = u&apos;真皮沙发&apos;</div><div class=\"line\">    def room(self):</div><div class=\"line\">        # print SOFA # 无法直接访问外部变量，取消注释会报错</div><div class=\"line\">        print self.SOFA</div><div class=\"line\">        self.SOFA = &apos;布质沙发&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    test.room()</div><div class=\"line\">    print test.SOFA, House.SOFA</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">真皮沙发</div><div class=\"line\">布质沙发 真皮沙发</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明<code>global variable</code>， 访问类变量要接上类名，如<code>class_name.variable</code>, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。</p>\n"},{"layout":"post","title":"vue中如何自定义v-model","date":"2017-03-30T17:36:00.000Z","_content":"\n## 简介\n在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。\n\n基本的v-model用法为：\n```\n<input v-model=\"something\">\n```\n\n其实它是以下用法的简写：\n```\n<input :value=\"something\" @input=\"something = $event.target.value\" />\n```\n\n因此，自己封装组件的话，可以这样来定义：\n\n\n```\n// demo.vue\n<template lang=\"html\">\n  <input :value=\"value\" @input=\"valueChange\">\n</template>\n\n<script>\nexport default {\n  props: ['value'],\n  methods: {\n    valueChange (v) {\n      this.$emit('input', v.target.value)\n    }\n  }\n}\n</script>\n\n// 引用\n<demo v-model=\"something\"></demo>\n```\n\n## 用法示例\n在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:\n\n![](http://i4.buimg.com/567571/4be2a48163ab3278.png)\n\n我们想要展示的数据格式为：\n\n![](http://i2.muimg.com/567571/22498a7d7df1a596.png)\n\n仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format => YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：\n```\n<el-time-select\n  v-model=\"value1\"\n</el-time-select>\n```\n\n因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：\n\n```\n<el-time-select\n  :value=\"time | convertToRangeTime\"\n  @input=\"e => time = e\"\n</el-time-select>\n```\n","source":"_posts/vue中如何自定义v-model.md","raw":"---\nlayout: \"post\"\ntitle: \"vue中如何自定义v-model\"\ndate: \"2017/03/31 01:36\"\ntags: vue\n---\n\n## 简介\n在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。\n\n基本的v-model用法为：\n```\n<input v-model=\"something\">\n```\n\n其实它是以下用法的简写：\n```\n<input :value=\"something\" @input=\"something = $event.target.value\" />\n```\n\n因此，自己封装组件的话，可以这样来定义：\n\n\n```\n// demo.vue\n<template lang=\"html\">\n  <input :value=\"value\" @input=\"valueChange\">\n</template>\n\n<script>\nexport default {\n  props: ['value'],\n  methods: {\n    valueChange (v) {\n      this.$emit('input', v.target.value)\n    }\n  }\n}\n</script>\n\n// 引用\n<demo v-model=\"something\"></demo>\n```\n\n## 用法示例\n在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:\n\n![](http://i4.buimg.com/567571/4be2a48163ab3278.png)\n\n我们想要展示的数据格式为：\n\n![](http://i2.muimg.com/567571/22498a7d7df1a596.png)\n\n仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format => YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：\n```\n<el-time-select\n  v-model=\"value1\"\n</el-time-select>\n```\n\n因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：\n\n```\n<el-time-select\n  :value=\"time | convertToRangeTime\"\n  @input=\"e => time = e\"\n</el-time-select>\n```\n","slug":"vue中如何自定义v-model","published":1,"updated":"2017-10-08T13:57:52.004Z","comments":1,"photos":[],"link":"","_id":"cjaggj8ca000tnuc3w2vjft79","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。</p>\n<p>基本的v-model用法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其实它是以下用法的简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input :value=&quot;something&quot; @input=&quot;something = $event.target.value&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，自己封装组件的话，可以这样来定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// demo.vue</div><div class=\"line\">&lt;template lang=&quot;html&quot;&gt;</div><div class=\"line\">  &lt;input :value=&quot;value&quot; @input=&quot;valueChange&quot;&gt;</div><div class=\"line\">&lt;/template&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">export default &#123;</div><div class=\"line\">  props: [&apos;value&apos;],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    valueChange (v) &#123;</div><div class=\"line\">      this.$emit(&apos;input&apos;, v.target.value)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">// 引用</div><div class=\"line\">&lt;demo v-model=&quot;something&quot;&gt;&lt;/demo&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h2><p>在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:</p>\n<p><img src=\"http://i4.buimg.com/567571/4be2a48163ab3278.png\" alt=\"\"></p>\n<p>我们想要展示的数据格式为：</p>\n<p><img src=\"http://i2.muimg.com/567571/22498a7d7df1a596.png\" alt=\"\"></p>\n<p>仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format =&gt; YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  v-model=&quot;value1&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  :value=&quot;time | convertToRangeTime&quot;</div><div class=\"line\">  @input=&quot;e =&gt; time = e&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。</p>\n<p>基本的v-model用法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其实它是以下用法的简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input :value=&quot;something&quot; @input=&quot;something = $event.target.value&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，自己封装组件的话，可以这样来定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// demo.vue</div><div class=\"line\">&lt;template lang=&quot;html&quot;&gt;</div><div class=\"line\">  &lt;input :value=&quot;value&quot; @input=&quot;valueChange&quot;&gt;</div><div class=\"line\">&lt;/template&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">export default &#123;</div><div class=\"line\">  props: [&apos;value&apos;],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    valueChange (v) &#123;</div><div class=\"line\">      this.$emit(&apos;input&apos;, v.target.value)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">// 引用</div><div class=\"line\">&lt;demo v-model=&quot;something&quot;&gt;&lt;/demo&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h2><p>在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:</p>\n<p><img src=\"http://i4.buimg.com/567571/4be2a48163ab3278.png\" alt=\"\"></p>\n<p>我们想要展示的数据格式为：</p>\n<p><img src=\"http://i2.muimg.com/567571/22498a7d7df1a596.png\" alt=\"\"></p>\n<p>仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format =&gt; YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  v-model=&quot;value1&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  :value=&quot;time | convertToRangeTime&quot;</div><div class=\"line\">  @input=&quot;e =&gt; time = e&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"几个简单的排序-js描述","date":"2016-12-26T07:02:51.000Z","_content":"排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。\n\n\n## 冒泡\n冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-1.jpg)\n\n此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。\n\n#### 代码\n\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if ( arrs[j] > arrs[j + 1]) {\n        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];\n      }\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 选择排序\n选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。\n\n#### 原理\n![选择排序](/imgs/冒泡、选择与插入排序-2.jpg)\n\n如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  let index;\n  for (let i = 0; i < len - 1; i++) {\n    index = i;\n    for (let j = i; j < len; j++) {\n      if (arrs[index] < arrs[j]) {\n        index = j;\n      }\n    }\n    if (i !== index) {\n      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：9,6,4,3,2\n耗时：18ms\n```\n\n## 插入\n插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-3.jpg)\n\n想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7>5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 1; i < len; i++) {\n    let j = i - 1;\n    const index = arrs[i];\n    while (j >= 0 && arrs[j] > index) {\n      arrs[j + 1] = arrs[j--];\n    }\n    arrs[j + 1] = index;\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 快排\n快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。\n\n#### 原理\n1. 选取数组中最左边的数作为基准。\n2. 分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。\n3. 对左右区间重复第二步，直到各区间只有一个数。\n\n#### 代码\n```\nfunction sort(arrs, left, right) {\n  if (left > right) return;\n  const len = arrs.length;\n  const key = arrs[left];\n  let low = left;\n  let high = right;\n  while (low < high) {\n    while (low < high && arrs[high] > key) {\n      high--;\n    }\n    arrs[low] = arrs[high];\n    while (low < high && arrs[low] < key) {\n      low++;\n    }\n    arrs[high] = arrs[low];\n  }\n  arrs[low] = key;\n  sort(arrs, left, low - 1);\n  sort(arrs, low + 1, right);\n}\n\n输入：[3,6,9,4,2],0,4\n输出：[2,3,4,6,9],0,4\n耗时：15ms\n```\n","source":"_posts/冒泡、选择与插入排序.markdown","raw":"---\nlayout: post\ntitle: 几个简单的排序-js描述\ndate: 2016/12/26 15:02:51\ntags: js\n---\n排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。\n\n\n## 冒泡\n冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-1.jpg)\n\n此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。\n\n#### 代码\n\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if ( arrs[j] > arrs[j + 1]) {\n        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];\n      }\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 选择排序\n选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。\n\n#### 原理\n![选择排序](/imgs/冒泡、选择与插入排序-2.jpg)\n\n如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  let index;\n  for (let i = 0; i < len - 1; i++) {\n    index = i;\n    for (let j = i; j < len; j++) {\n      if (arrs[index] < arrs[j]) {\n        index = j;\n      }\n    }\n    if (i !== index) {\n      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：9,6,4,3,2\n耗时：18ms\n```\n\n## 插入\n插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-3.jpg)\n\n想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7>5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 1; i < len; i++) {\n    let j = i - 1;\n    const index = arrs[i];\n    while (j >= 0 && arrs[j] > index) {\n      arrs[j + 1] = arrs[j--];\n    }\n    arrs[j + 1] = index;\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 快排\n快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。\n\n#### 原理\n1. 选取数组中最左边的数作为基准。\n2. 分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。\n3. 对左右区间重复第二步，直到各区间只有一个数。\n\n#### 代码\n```\nfunction sort(arrs, left, right) {\n  if (left > right) return;\n  const len = arrs.length;\n  const key = arrs[left];\n  let low = left;\n  let high = right;\n  while (low < high) {\n    while (low < high && arrs[high] > key) {\n      high--;\n    }\n    arrs[low] = arrs[high];\n    while (low < high && arrs[low] < key) {\n      low++;\n    }\n    arrs[high] = arrs[low];\n  }\n  arrs[low] = key;\n  sort(arrs, left, low - 1);\n  sort(arrs, low + 1, right);\n}\n\n输入：[3,6,9,4,2],0,4\n输出：[2,3,4,6,9],0,4\n耗时：15ms\n```\n","slug":"冒泡、选择与插入排序","published":1,"updated":"2017-10-08T13:58:20.279Z","comments":1,"photos":[],"link":"","_id":"cjaggj8cb000vnuc3zoi27coj","content":"<p>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。</p>\n<h2 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h2><p>冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-1.jpg\" alt=\"\"></p>\n<p>此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class=\"line\">      if ( arrs[j] &gt; arrs[j + 1]) &#123;</div><div class=\"line\">        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。</p>\n<h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-2.jpg\" alt=\"选择排序\"></p>\n<p>如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  let index;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    index = i;</div><div class=\"line\">    for (let j = i; j &lt; len; j++) &#123;</div><div class=\"line\">      if (arrs[index] &lt; arrs[j]) &#123;</div><div class=\"line\">        index = j;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (i !== index) &#123;</div><div class=\"line\">      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：9,6,4,3,2</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。</p>\n<h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-3.jpg\" alt=\"\"></p>\n<p>想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7&gt;5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 1; i &lt; len; i++) &#123;</div><div class=\"line\">    let j = i - 1;</div><div class=\"line\">    const index = arrs[i];</div><div class=\"line\">    while (j &gt;= 0 &amp;&amp; arrs[j] &gt; index) &#123;</div><div class=\"line\">      arrs[j + 1] = arrs[j--];</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[j + 1] = index;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h2><p>快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。</p>\n<h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>选取数组中最左边的数作为基准。</li>\n<li>分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。</li>\n<li>对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs, left, right) &#123;</div><div class=\"line\">  if (left &gt; right) return;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  const key = arrs[left];</div><div class=\"line\">  let low = left;</div><div class=\"line\">  let high = right;</div><div class=\"line\">  while (low &lt; high) &#123;</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[high] &gt; key) &#123;</div><div class=\"line\">      high--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[low] = arrs[high];</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[low] &lt; key) &#123;</div><div class=\"line\">      low++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[high] = arrs[low];</div><div class=\"line\">  &#125;</div><div class=\"line\">  arrs[low] = key;</div><div class=\"line\">  sort(arrs, left, low - 1);</div><div class=\"line\">  sort(arrs, low + 1, right);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：[3,6,9,4,2],0,4</div><div class=\"line\">输出：[2,3,4,6,9],0,4</div><div class=\"line\">耗时：15ms</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。</p>\n<h2 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h2><p>冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-1.jpg\" alt=\"\"></p>\n<p>此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class=\"line\">      if ( arrs[j] &gt; arrs[j + 1]) &#123;</div><div class=\"line\">        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。</p>\n<h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-2.jpg\" alt=\"选择排序\"></p>\n<p>如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  let index;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    index = i;</div><div class=\"line\">    for (let j = i; j &lt; len; j++) &#123;</div><div class=\"line\">      if (arrs[index] &lt; arrs[j]) &#123;</div><div class=\"line\">        index = j;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (i !== index) &#123;</div><div class=\"line\">      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：9,6,4,3,2</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。</p>\n<h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-3.jpg\" alt=\"\"></p>\n<p>想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7&gt;5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 1; i &lt; len; i++) &#123;</div><div class=\"line\">    let j = i - 1;</div><div class=\"line\">    const index = arrs[i];</div><div class=\"line\">    while (j &gt;= 0 &amp;&amp; arrs[j] &gt; index) &#123;</div><div class=\"line\">      arrs[j + 1] = arrs[j--];</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[j + 1] = index;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h2><p>快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。</p>\n<h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>选取数组中最左边的数作为基准。</li>\n<li>分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。</li>\n<li>对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs, left, right) &#123;</div><div class=\"line\">  if (left &gt; right) return;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  const key = arrs[left];</div><div class=\"line\">  let low = left;</div><div class=\"line\">  let high = right;</div><div class=\"line\">  while (low &lt; high) &#123;</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[high] &gt; key) &#123;</div><div class=\"line\">      high--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[low] = arrs[high];</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[low] &lt; key) &#123;</div><div class=\"line\">      low++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[high] = arrs[low];</div><div class=\"line\">  &#125;</div><div class=\"line\">  arrs[low] = key;</div><div class=\"line\">  sort(arrs, left, low - 1);</div><div class=\"line\">  sort(arrs, low + 1, right);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：[3,6,9,4,2],0,4</div><div class=\"line\">输出：[2,3,4,6,9],0,4</div><div class=\"line\">耗时：15ms</div></pre></td></tr></table></figure>\n"},{"title":"什么是函数节流","date":"2017-10-14T09:28:24.000Z","_content":"## 什么是函数节流\n\n避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。\n\n## 代码实现\n\n首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：\n\n```\nfunction throttle(fn, delay, ...args) {\n  let timer = null\n  return function() {\n  \tclearTimeout(timer)\n  \ttimer = setTimeout(() => fn.apply(this, args), delay)\n  }\n}\n```\n\n测试函数：\n\n```\nconst log = throttle(console.log, 300, 1)\nfor (let i = 0; i < 100; i++) {\n  log() // 只会打印一次\n}\n```\n\n\n\n这样的函数有时还无法完成要求，比如在拖拽一个元素时，直接使用此节流函数会造成拖拽的时候无法移动，等拖完了就直接闪到终点去了，因为函数一直在定时器内不断刷新，只有到最后才执行了，因此需要对此函数改进一下，多设定一个参数，即触发的时间间隔，这样即可保证函数的执行频率了。\n\n```\nfunction throttle(fn, delay, duration, ...args) {\n  let timer = null\n  let tStart\n  return function() {\n  \tclearTimeout(timer)\n  \tconst cStart = +Date()\n  \tif (!tStart) {\n      tStart = cStart\n  \t}\n  \tif (cStart - tStart >= duration) {\n      fn.apply(this, args)\n      tStart = cStart\n  \t} else {\n      timer = setTimeout(() => {\n      \tfn.apply(this, args);\n      }, delay)\n  \t}\n  }\n}\n```\n\n## 参考资料\n\n- [浅谈javascript的函数节流](http://www.alloyteam.com/2012/11/javascript-throttle/)\n\n\n\n","source":"_posts/throttle.md","raw":"---\ntitle: 什么是函数节流\ndate: 2017-10-14 17:28:24\ntags: js\n---\n## 什么是函数节流\n\n避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。\n\n## 代码实现\n\n首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：\n\n```\nfunction throttle(fn, delay, ...args) {\n  let timer = null\n  return function() {\n  \tclearTimeout(timer)\n  \ttimer = setTimeout(() => fn.apply(this, args), delay)\n  }\n}\n```\n\n测试函数：\n\n```\nconst log = throttle(console.log, 300, 1)\nfor (let i = 0; i < 100; i++) {\n  log() // 只会打印一次\n}\n```\n\n\n\n这样的函数有时还无法完成要求，比如在拖拽一个元素时，直接使用此节流函数会造成拖拽的时候无法移动，等拖完了就直接闪到终点去了，因为函数一直在定时器内不断刷新，只有到最后才执行了，因此需要对此函数改进一下，多设定一个参数，即触发的时间间隔，这样即可保证函数的执行频率了。\n\n```\nfunction throttle(fn, delay, duration, ...args) {\n  let timer = null\n  let tStart\n  return function() {\n  \tclearTimeout(timer)\n  \tconst cStart = +Date()\n  \tif (!tStart) {\n      tStart = cStart\n  \t}\n  \tif (cStart - tStart >= duration) {\n      fn.apply(this, args)\n      tStart = cStart\n  \t} else {\n      timer = setTimeout(() => {\n      \tfn.apply(this, args);\n      }, delay)\n  \t}\n  }\n}\n```\n\n## 参考资料\n\n- [浅谈javascript的函数节流](http://www.alloyteam.com/2012/11/javascript-throttle/)\n\n\n\n","slug":"throttle","published":1,"updated":"2017-10-14T09:30:28.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8cc000xnuc3dxmjhtvo","content":"<h2 id=\"什么是函数节流\"><a href=\"#什么是函数节流\" class=\"headerlink\" title=\"什么是函数节流\"></a>什么是函数节流</h2><p>避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle(fn, delay, ...args) &#123;</div><div class=\"line\">  let timer = null</div><div class=\"line\">  return function() &#123;</div><div class=\"line\">  \tclearTimeout(timer)</div><div class=\"line\">  \ttimer = setTimeout(() =&gt; fn.apply(this, args), delay)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const log = throttle(console.log, 300, 1)</div><div class=\"line\">for (let i = 0; i &lt; 100; i++) &#123;</div><div class=\"line\">  log() // 只会打印一次</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的函数有时还无法完成要求，比如在拖拽一个元素时，直接使用此节流函数会造成拖拽的时候无法移动，等拖完了就直接闪到终点去了，因为函数一直在定时器内不断刷新，只有到最后才执行了，因此需要对此函数改进一下，多设定一个参数，即触发的时间间隔，这样即可保证函数的执行频率了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle(fn, delay, duration, ...args) &#123;</div><div class=\"line\">  let timer = null</div><div class=\"line\">  let tStart</div><div class=\"line\">  return function() &#123;</div><div class=\"line\">  \tclearTimeout(timer)</div><div class=\"line\">  \tconst cStart = +Date()</div><div class=\"line\">  \tif (!tStart) &#123;</div><div class=\"line\">      tStart = cStart</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  \tif (cStart - tStart &gt;= duration) &#123;</div><div class=\"line\">      fn.apply(this, args)</div><div class=\"line\">      tStart = cStart</div><div class=\"line\">  \t&#125; else &#123;</div><div class=\"line\">      timer = setTimeout(() =&gt; &#123;</div><div class=\"line\">      \tfn.apply(this, args);</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.alloyteam.com/2012/11/javascript-throttle/\" target=\"_blank\" rel=\"external\">浅谈javascript的函数节流</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是函数节流\"><a href=\"#什么是函数节流\" class=\"headerlink\" title=\"什么是函数节流\"></a>什么是函数节流</h2><p>避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle(fn, delay, ...args) &#123;</div><div class=\"line\">  let timer = null</div><div class=\"line\">  return function() &#123;</div><div class=\"line\">  \tclearTimeout(timer)</div><div class=\"line\">  \ttimer = setTimeout(() =&gt; fn.apply(this, args), delay)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const log = throttle(console.log, 300, 1)</div><div class=\"line\">for (let i = 0; i &lt; 100; i++) &#123;</div><div class=\"line\">  log() // 只会打印一次</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的函数有时还无法完成要求，比如在拖拽一个元素时，直接使用此节流函数会造成拖拽的时候无法移动，等拖完了就直接闪到终点去了，因为函数一直在定时器内不断刷新，只有到最后才执行了，因此需要对此函数改进一下，多设定一个参数，即触发的时间间隔，这样即可保证函数的执行频率了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle(fn, delay, duration, ...args) &#123;</div><div class=\"line\">  let timer = null</div><div class=\"line\">  let tStart</div><div class=\"line\">  return function() &#123;</div><div class=\"line\">  \tclearTimeout(timer)</div><div class=\"line\">  \tconst cStart = +Date()</div><div class=\"line\">  \tif (!tStart) &#123;</div><div class=\"line\">      tStart = cStart</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  \tif (cStart - tStart &gt;= duration) &#123;</div><div class=\"line\">      fn.apply(this, args)</div><div class=\"line\">      tStart = cStart</div><div class=\"line\">  \t&#125; else &#123;</div><div class=\"line\">      timer = setTimeout(() =&gt; &#123;</div><div class=\"line\">      \tfn.apply(this, args);</div><div class=\"line\">      &#125;, delay)</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.alloyteam.com/2012/11/javascript-throttle/\" target=\"_blank\" rel=\"external\">浅谈javascript的函数节流</a></li>\n</ul>\n"},{"layout":"post","title":"python求质数的几种方法","date":"2016-12-25T16:02:23.000Z","_content":"\n今天偶然在博客上上看到有人提[求质素的几种境界](http://blog.csdn.net/program_think/article/details/7032600/),在此用python进行实现代码,并进行简单的说明.\n\n我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.\n\n### 境界1\n我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取`2~N/2`.\n代码如下:\n\n```\ndef f1(num):\n    # 2也是质数,之后程序从3开始判断\n    count = 1\n    for i in range(3, num):\n        b = True\n        for j in range(2, i/2 + 1):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时35.1589805796秒, 个数9592\n```\n\n### 境界2\n我们可以从j的范围再进行优化一下,最优的范围是`2~sqrt(N)`,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:\n\n```\ndef f1(num):\n    count = 1\n    # 优化点1:偶数不做判断\n    for i in range(3, num, 2):\n        b = True\n        sq = int(math.sqrt(i)) + 1\n        # 优化点2:缩小试除范围\n        for j in range(2, sq):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时0.264536051872秒, 个数9592\n```\n\n### 境界3\n是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.\n\n细想一下, 比如判断101是否为质数,`sqrt(101)`为10, 那我们就要依次用这个数去除以`2, 3, 5, 7, 9`,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的**质数**即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:\n\n```\ndef f2(num):\n    arrs = [2]\n    count = 1\n    # 质数数组中的索引\n    stop = 0\n    for i in range(3, num):\n        k = int(math.sqrt(i))\n        while stop < count and arrs[stop] <= k:\n            stop += 1\n        # 整除计数\n        j = 0\n        for k in range(stop):\n            if i % arrs[j] == 0:\n                break\n            j += 1\n        # 判定为质数后加入质数数组\n        if j == stop:\n            arrs.append(i)\n            count += 1\n    return count\n\nf2(100000)\n# 耗时0.199287338917秒, 个数9592\n```\n\n### 境界4\n以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg)\n\n首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!\n\n我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:\n\n+ 试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值\n+ 筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小\n+ 用加法代替乘法\n\n```\ndef f4(num):\n    # 初始化时将偶数全预筛除掉\n    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]\n    arrs[2] = 1\n    count = 0\n    for i in range(3, int(math.sqrt(num)), 2):\n        if arrs[i] == 0:\n            continue\n        # j为i的合数,此处用加法代替乘法\n        j = i + i\n        while j <= num:\n            arrs[j] = 0\n            j += i\n    # 计数\n    for k in range(2, num + 1):\n        if arrs[k] == 1:\n            count += 1\n    return count\n\nf4(100000)\n# 耗时0.03232869726秒, 个数9592\n```\n\n### 境界5\n...\n","source":"_posts/求质数的几种方法.md","raw":"---\nlayout: post\ntitle: python求质数的几种方法\ndate: 2016/12/26 00:02:23\ntags: python\n---\n\n今天偶然在博客上上看到有人提[求质素的几种境界](http://blog.csdn.net/program_think/article/details/7032600/),在此用python进行实现代码,并进行简单的说明.\n\n我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.\n\n### 境界1\n我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取`2~N/2`.\n代码如下:\n\n```\ndef f1(num):\n    # 2也是质数,之后程序从3开始判断\n    count = 1\n    for i in range(3, num):\n        b = True\n        for j in range(2, i/2 + 1):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时35.1589805796秒, 个数9592\n```\n\n### 境界2\n我们可以从j的范围再进行优化一下,最优的范围是`2~sqrt(N)`,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:\n\n```\ndef f1(num):\n    count = 1\n    # 优化点1:偶数不做判断\n    for i in range(3, num, 2):\n        b = True\n        sq = int(math.sqrt(i)) + 1\n        # 优化点2:缩小试除范围\n        for j in range(2, sq):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时0.264536051872秒, 个数9592\n```\n\n### 境界3\n是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.\n\n细想一下, 比如判断101是否为质数,`sqrt(101)`为10, 那我们就要依次用这个数去除以`2, 3, 5, 7, 9`,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的**质数**即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:\n\n```\ndef f2(num):\n    arrs = [2]\n    count = 1\n    # 质数数组中的索引\n    stop = 0\n    for i in range(3, num):\n        k = int(math.sqrt(i))\n        while stop < count and arrs[stop] <= k:\n            stop += 1\n        # 整除计数\n        j = 0\n        for k in range(stop):\n            if i % arrs[j] == 0:\n                break\n            j += 1\n        # 判定为质数后加入质数数组\n        if j == stop:\n            arrs.append(i)\n            count += 1\n    return count\n\nf2(100000)\n# 耗时0.199287338917秒, 个数9592\n```\n\n### 境界4\n以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg)\n\n首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!\n\n我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:\n\n+ 试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值\n+ 筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小\n+ 用加法代替乘法\n\n```\ndef f4(num):\n    # 初始化时将偶数全预筛除掉\n    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]\n    arrs[2] = 1\n    count = 0\n    for i in range(3, int(math.sqrt(num)), 2):\n        if arrs[i] == 0:\n            continue\n        # j为i的合数,此处用加法代替乘法\n        j = i + i\n        while j <= num:\n            arrs[j] = 0\n            j += i\n    # 计数\n    for k in range(2, num + 1):\n        if arrs[k] == 1:\n            count += 1\n    return count\n\nf4(100000)\n# 耗时0.03232869726秒, 个数9592\n```\n\n### 境界5\n...\n","slug":"求质数的几种方法","published":1,"updated":"2017-10-08T13:58:14.261Z","comments":1,"photos":[],"link":"","_id":"cjaggj8ci000znuc3l6m0cfrm","content":"<p>今天偶然在博客上上看到有人提<a href=\"http://blog.csdn.net/program_think/article/details/7032600/\" target=\"_blank\" rel=\"external\">求质素的几种境界</a>,在此用python进行实现代码,并进行简单的说明.</p>\n<p>我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.</p>\n<h3 id=\"境界1\"><a href=\"#境界1\" class=\"headerlink\" title=\"境界1\"></a>境界1</h3><p>我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取<code>2~N/2</code>.<br>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    # 2也是质数,之后程序从3开始判断</div><div class=\"line\">    count = 1</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        b = True</div><div class=\"line\">        for j in range(2, i/2 + 1):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时35.1589805796秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界2\"><a href=\"#境界2\" class=\"headerlink\" title=\"境界2\"></a>境界2</h3><p>我们可以从j的范围再进行优化一下,最优的范围是<code>2~sqrt(N)</code>,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 优化点1:偶数不做判断</div><div class=\"line\">    for i in range(3, num, 2):</div><div class=\"line\">        b = True</div><div class=\"line\">        sq = int(math.sqrt(i)) + 1</div><div class=\"line\">        # 优化点2:缩小试除范围</div><div class=\"line\">        for j in range(2, sq):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时0.264536051872秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界3\"><a href=\"#境界3\" class=\"headerlink\" title=\"境界3\"></a>境界3</h3><p>是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.</p>\n<p>细想一下, 比如判断101是否为质数,<code>sqrt(101)</code>为10, 那我们就要依次用这个数去除以<code>2, 3, 5, 7, 9</code>,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的<strong>质数</strong>即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f2(num):</div><div class=\"line\">    arrs = [2]</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 质数数组中的索引</div><div class=\"line\">    stop = 0</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        k = int(math.sqrt(i))</div><div class=\"line\">        while stop &lt; count and arrs[stop] &lt;= k:</div><div class=\"line\">            stop += 1</div><div class=\"line\">        # 整除计数</div><div class=\"line\">        j = 0</div><div class=\"line\">        for k in range(stop):</div><div class=\"line\">            if i % arrs[j] == 0:</div><div class=\"line\">                break</div><div class=\"line\">            j += 1</div><div class=\"line\">        # 判定为质数后加入质数数组</div><div class=\"line\">        if j == stop:</div><div class=\"line\">            arrs.append(i)</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f2(100000)</div><div class=\"line\"># 耗时0.199287338917秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界4\"><a href=\"#境界4\" class=\"headerlink\" title=\"境界4\"></a>境界4</h3><p>以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg\" alt=\"\"></p>\n<p>首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!</p>\n<p>我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:</p>\n<ul>\n<li>试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值</li>\n<li>筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小</li>\n<li>用加法代替乘法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f4(num):</div><div class=\"line\">    # 初始化时将偶数全预筛除掉</div><div class=\"line\">    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]</div><div class=\"line\">    arrs[2] = 1</div><div class=\"line\">    count = 0</div><div class=\"line\">    for i in range(3, int(math.sqrt(num)), 2):</div><div class=\"line\">        if arrs[i] == 0:</div><div class=\"line\">            continue</div><div class=\"line\">        # j为i的合数,此处用加法代替乘法</div><div class=\"line\">        j = i + i</div><div class=\"line\">        while j &lt;= num:</div><div class=\"line\">            arrs[j] = 0</div><div class=\"line\">            j += i</div><div class=\"line\">    # 计数</div><div class=\"line\">    for k in range(2, num + 1):</div><div class=\"line\">        if arrs[k] == 1:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f4(100000)</div><div class=\"line\"># 耗时0.03232869726秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界5\"><a href=\"#境界5\" class=\"headerlink\" title=\"境界5\"></a>境界5</h3><p>…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天偶然在博客上上看到有人提<a href=\"http://blog.csdn.net/program_think/article/details/7032600/\" target=\"_blank\" rel=\"external\">求质素的几种境界</a>,在此用python进行实现代码,并进行简单的说明.</p>\n<p>我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.</p>\n<h3 id=\"境界1\"><a href=\"#境界1\" class=\"headerlink\" title=\"境界1\"></a>境界1</h3><p>我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取<code>2~N/2</code>.<br>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    # 2也是质数,之后程序从3开始判断</div><div class=\"line\">    count = 1</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        b = True</div><div class=\"line\">        for j in range(2, i/2 + 1):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时35.1589805796秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界2\"><a href=\"#境界2\" class=\"headerlink\" title=\"境界2\"></a>境界2</h3><p>我们可以从j的范围再进行优化一下,最优的范围是<code>2~sqrt(N)</code>,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 优化点1:偶数不做判断</div><div class=\"line\">    for i in range(3, num, 2):</div><div class=\"line\">        b = True</div><div class=\"line\">        sq = int(math.sqrt(i)) + 1</div><div class=\"line\">        # 优化点2:缩小试除范围</div><div class=\"line\">        for j in range(2, sq):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时0.264536051872秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界3\"><a href=\"#境界3\" class=\"headerlink\" title=\"境界3\"></a>境界3</h3><p>是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.</p>\n<p>细想一下, 比如判断101是否为质数,<code>sqrt(101)</code>为10, 那我们就要依次用这个数去除以<code>2, 3, 5, 7, 9</code>,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的<strong>质数</strong>即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f2(num):</div><div class=\"line\">    arrs = [2]</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 质数数组中的索引</div><div class=\"line\">    stop = 0</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        k = int(math.sqrt(i))</div><div class=\"line\">        while stop &lt; count and arrs[stop] &lt;= k:</div><div class=\"line\">            stop += 1</div><div class=\"line\">        # 整除计数</div><div class=\"line\">        j = 0</div><div class=\"line\">        for k in range(stop):</div><div class=\"line\">            if i % arrs[j] == 0:</div><div class=\"line\">                break</div><div class=\"line\">            j += 1</div><div class=\"line\">        # 判定为质数后加入质数数组</div><div class=\"line\">        if j == stop:</div><div class=\"line\">            arrs.append(i)</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f2(100000)</div><div class=\"line\"># 耗时0.199287338917秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界4\"><a href=\"#境界4\" class=\"headerlink\" title=\"境界4\"></a>境界4</h3><p>以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg\" alt=\"\"></p>\n<p>首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!</p>\n<p>我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:</p>\n<ul>\n<li>试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值</li>\n<li>筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小</li>\n<li>用加法代替乘法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f4(num):</div><div class=\"line\">    # 初始化时将偶数全预筛除掉</div><div class=\"line\">    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]</div><div class=\"line\">    arrs[2] = 1</div><div class=\"line\">    count = 0</div><div class=\"line\">    for i in range(3, int(math.sqrt(num)), 2):</div><div class=\"line\">        if arrs[i] == 0:</div><div class=\"line\">            continue</div><div class=\"line\">        # j为i的合数,此处用加法代替乘法</div><div class=\"line\">        j = i + i</div><div class=\"line\">        while j &lt;= num:</div><div class=\"line\">            arrs[j] = 0</div><div class=\"line\">            j += i</div><div class=\"line\">    # 计数</div><div class=\"line\">    for k in range(2, num + 1):</div><div class=\"line\">        if arrs[k] == 1:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f4(100000)</div><div class=\"line\"># 耗时0.03232869726秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界5\"><a href=\"#境界5\" class=\"headerlink\" title=\"境界5\"></a>境界5</h3><p>…</p>\n"},{"layout":"post","title":"理解javascript线程","date":"2017-02-09T09:30:24.000Z","_content":"\n## 进程和线程\n+ 进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间\n+ 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)\n\n线程的作用：\n\n1. 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型\n1. 线程很轻量，创建与销毁消耗的资源小\n1. 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作\n\n根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：\n\n```\n最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。\n\n能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。\n\n另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。\n```\n\n## javascript单线程机制\n\njavascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：\n\n1. 在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。\n1. 再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。\n\n所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。\n\n## 任务队列\n\njavascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。\n\n同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。\n\n任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。\n\n关于定时器的用法，常见的如`setTimeout(fn, 0);`，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。\n\n## 事件循环(Event Loop)\n\n![image](http://i4.buimg.com/567571/eadf3db4bf455904.png)\nEvent Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。\n\n主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:\n\n```javascript\nwhile (queue.waitForMessage()) {\n    queue.processNextMessage()\n}\n```\n\n而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。\n\n## Web Worker\n随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。\n\nWeb Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。\n","source":"_posts/深入理解javascript线程.md","raw":"---\nlayout: post\ntitle: 理解javascript线程\ndate: 2017/02/09 17:30:24\ntags: js\n---\n\n## 进程和线程\n+ 进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间\n+ 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)\n\n线程的作用：\n\n1. 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型\n1. 线程很轻量，创建与销毁消耗的资源小\n1. 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作\n\n根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：\n\n```\n最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。\n\n能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。\n\n另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。\n```\n\n## javascript单线程机制\n\njavascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：\n\n1. 在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。\n1. 再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。\n\n所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。\n\n## 任务队列\n\njavascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。\n\n同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。\n\n任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。\n\n关于定时器的用法，常见的如`setTimeout(fn, 0);`，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。\n\n## 事件循环(Event Loop)\n\n![image](http://i4.buimg.com/567571/eadf3db4bf455904.png)\nEvent Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。\n\n主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:\n\n```javascript\nwhile (queue.waitForMessage()) {\n    queue.processNextMessage()\n}\n```\n\n而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。\n\n## Web Worker\n随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。\n\nWeb Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。\n","slug":"深入理解javascript线程","published":1,"updated":"2017-10-08T13:57:57.462Z","comments":1,"photos":[],"link":"","_id":"cjaggj8cp0011nuc3ugerjxuk","content":"<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><ul>\n<li>进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间</li>\n<li>线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)</li>\n</ul>\n<p>线程的作用：</p>\n<ol>\n<li>大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型</li>\n<li>线程很轻量，创建与销毁消耗的资源小</li>\n<li>线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作</li>\n</ol>\n<p>根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。</div><div class=\"line\"></div><div class=\"line\">能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。</div><div class=\"line\"></div><div class=\"line\">另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。</div></pre></td></tr></table></figure>\n<h2 id=\"javascript单线程机制\"><a href=\"#javascript单线程机制\" class=\"headerlink\" title=\"javascript单线程机制\"></a>javascript单线程机制</h2><p>javascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：</p>\n<ol>\n<li>在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。</li>\n<li>再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。</li>\n</ol>\n<p>所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。</p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>javascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。</p>\n<p>同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。</p>\n<p>任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。</p>\n<p>关于定时器的用法，常见的如<code>setTimeout(fn, 0);</code>，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p><img src=\"http://i4.buimg.com/567571/eadf3db4bf455904.png\" alt=\"image\"><br>Event Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。</p>\n<p>主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</div><div class=\"line\">    queue.processNextMessage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。</p>\n<h2 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h2><p>随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。</p>\n<p>Web Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><ul>\n<li>进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间</li>\n<li>线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)</li>\n</ul>\n<p>线程的作用：</p>\n<ol>\n<li>大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型</li>\n<li>线程很轻量，创建与销毁消耗的资源小</li>\n<li>线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作</li>\n</ol>\n<p>根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。</div><div class=\"line\"></div><div class=\"line\">能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。</div><div class=\"line\"></div><div class=\"line\">另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。</div></pre></td></tr></table></figure>\n<h2 id=\"javascript单线程机制\"><a href=\"#javascript单线程机制\" class=\"headerlink\" title=\"javascript单线程机制\"></a>javascript单线程机制</h2><p>javascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：</p>\n<ol>\n<li>在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。</li>\n<li>再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。</li>\n</ol>\n<p>所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。</p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>javascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。</p>\n<p>同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。</p>\n<p>任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。</p>\n<p>关于定时器的用法，常见的如<code>setTimeout(fn, 0);</code>，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p><img src=\"http://i4.buimg.com/567571/eadf3db4bf455904.png\" alt=\"image\"><br>Event Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。</p>\n<p>主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</div><div class=\"line\">    queue.processNextMessage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。</p>\n<h2 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h2><p>随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。</p>\n<p>Web Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。</p>\n"},{"title":"异步编程中的thunk函数","date":"2017-08-22T17:16:14.000Z","_content":"\n## 什么是Thunk\n\nThunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。\n\n写一个简单的函数，用于读取package.json的信息：\n\n```\nfs.readFile('package.json', (err, data) => {\n    if (err) throw err;\n    console.log(data.toString())\n})\n```\n\n在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：\n\n```\nconst app = new Koa()\n\napp.use(function*(next) {\n    const data = yield readFileThunk('package.json')\n    console.log(data)\n    yield next\n})\n\nfunction readFileThunk(path, cb) {\n    return function(cb) {\n        fs.readFile(path, (err, data) => {\n            if (err) throw err\n            cb(null, data.toString())\n        })\n    }\n}\napp.listen(3000)\n```\n\n通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。**Thunk函数将多参数函数替换成了单参数版本**，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：\n\n```\napp.use(async(ctx, next) => {\n    const data = await readFileWrap('package.json')\n    console.log(data)\n    await next()\n})\n\nfunction readFileWrap(path, cb) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, (err, data) => {\n            if (err) throw reject(error)\n            resolve(data.toString())\n        })\n    })\n}\n```\n\n我们接下来自己实现一个简易的thunk工具方法，思路如下：\n\n1. 一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包\n2. 第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法\n3. 第三层函数传入一个回调函数cb, 然后执行主程序\n\n```\nfunction thunkit(fn) {\n    return function() {\n        var args = Array.prototype.slice.call(arguments) \n        return function(cb) {\n            args.push(cb)\n            return fn.apply(this, args)\n        }\n    }\n}\n```\n\n在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。\n\n## thunkify源码解析\n\n```\nfunction thunkify(fn){\n  assert('function' == typeof fn, 'function required'); // 是否为函数\n\n  return function(){\n    var args = new Array(arguments.length); \n    var ctx = this; // 绑定函数的上下文对象\n\t\n\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组\n    for(var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function(done){\n      var called; // 记录是否执行回调，只允许执行一次\n\n      args.push(function(){\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args); // 调用参数列表\n      } catch (err) {\n        done(err); // 返回错误\n      }\n    }\n  }\n};\n```\n\n源代码已经够简单了，想也无需多说明，**重要的是函数本身的思想与灵活的去运用**。\n\n### 参考资料\n\n- [node-thunkify](https://github.com/tj/node-thunkify)\n\n- [阮一峰-Thunk 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/thunk.html)\n\n- [experiments-with-koa-and-javascript-generators](http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/)\n","source":"_posts/异步编程中的thunk函数.md","raw":"---\ntitle: 异步编程中的thunk函数\ndate: 2017-08-23 01:16:14\ntags: js\n---\n\n## 什么是Thunk\n\nThunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。\n\n写一个简单的函数，用于读取package.json的信息：\n\n```\nfs.readFile('package.json', (err, data) => {\n    if (err) throw err;\n    console.log(data.toString())\n})\n```\n\n在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：\n\n```\nconst app = new Koa()\n\napp.use(function*(next) {\n    const data = yield readFileThunk('package.json')\n    console.log(data)\n    yield next\n})\n\nfunction readFileThunk(path, cb) {\n    return function(cb) {\n        fs.readFile(path, (err, data) => {\n            if (err) throw err\n            cb(null, data.toString())\n        })\n    }\n}\napp.listen(3000)\n```\n\n通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。**Thunk函数将多参数函数替换成了单参数版本**，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：\n\n```\napp.use(async(ctx, next) => {\n    const data = await readFileWrap('package.json')\n    console.log(data)\n    await next()\n})\n\nfunction readFileWrap(path, cb) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, (err, data) => {\n            if (err) throw reject(error)\n            resolve(data.toString())\n        })\n    })\n}\n```\n\n我们接下来自己实现一个简易的thunk工具方法，思路如下：\n\n1. 一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包\n2. 第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法\n3. 第三层函数传入一个回调函数cb, 然后执行主程序\n\n```\nfunction thunkit(fn) {\n    return function() {\n        var args = Array.prototype.slice.call(arguments) \n        return function(cb) {\n            args.push(cb)\n            return fn.apply(this, args)\n        }\n    }\n}\n```\n\n在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。\n\n## thunkify源码解析\n\n```\nfunction thunkify(fn){\n  assert('function' == typeof fn, 'function required'); // 是否为函数\n\n  return function(){\n    var args = new Array(arguments.length); \n    var ctx = this; // 绑定函数的上下文对象\n\t\n\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组\n    for(var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function(done){\n      var called; // 记录是否执行回调，只允许执行一次\n\n      args.push(function(){\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args); // 调用参数列表\n      } catch (err) {\n        done(err); // 返回错误\n      }\n    }\n  }\n};\n```\n\n源代码已经够简单了，想也无需多说明，**重要的是函数本身的思想与灵活的去运用**。\n\n### 参考资料\n\n- [node-thunkify](https://github.com/tj/node-thunkify)\n\n- [阮一峰-Thunk 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/thunk.html)\n\n- [experiments-with-koa-and-javascript-generators](http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/)\n","slug":"异步编程中的thunk函数","published":1,"updated":"2017-10-08T13:57:45.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8cq0014nuc3kwxhhmab","content":"<h2 id=\"什么是Thunk\"><a href=\"#什么是Thunk\" class=\"headerlink\" title=\"什么是Thunk\"></a>什么是Thunk</h2><p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>\n<p>写一个简单的函数，用于读取package.json的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(&apos;package.json&apos;, (err, data) =&gt; &#123;</div><div class=\"line\">    if (err) throw err;</div><div class=\"line\">    console.log(data.toString())</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">const app = new Koa()</div><div class=\"line\"></div><div class=\"line\">app.use(function*(next) &#123;</div><div class=\"line\">    const data = yield readFileThunk(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    yield next</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileThunk(path, cb) &#123;</div><div class=\"line\">    return function(cb) &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw err</div><div class=\"line\">            cb(null, data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">app.listen(3000)</div></pre></td></tr></table></figure>\n<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async(ctx, next) =&gt; &#123;</div><div class=\"line\">    const data = await readFileWrap(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    await next()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileWrap(path, cb) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw reject(error)</div><div class=\"line\">            resolve(data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>\n<ol>\n<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>\n<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>\n<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkit(fn) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        var args = Array.prototype.slice.call(arguments) </div><div class=\"line\">        return function(cb) &#123;</div><div class=\"line\">            args.push(cb)</div><div class=\"line\">            return fn.apply(this, args)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>\n<h2 id=\"thunkify源码解析\"><a href=\"#thunkify源码解析\" class=\"headerlink\" title=\"thunkify源码解析\"></a>thunkify源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkify(fn)&#123;</div><div class=\"line\">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); // 是否为函数</div><div class=\"line\"></div><div class=\"line\">  return function()&#123;</div><div class=\"line\">    var args = new Array(arguments.length); </div><div class=\"line\">    var ctx = this; // 绑定函数的上下文对象</div><div class=\"line\">\t</div><div class=\"line\">\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组</div><div class=\"line\">    for(var i = 0; i &lt; args.length; ++i) &#123;</div><div class=\"line\">      args[i] = arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return function(done)&#123;</div><div class=\"line\">      var called; // 记录是否执行回调，只允许执行一次</div><div class=\"line\"></div><div class=\"line\">      args.push(function()&#123;</div><div class=\"line\">        if (called) return;</div><div class=\"line\">        called = true;</div><div class=\"line\">        done.apply(null, arguments);</div><div class=\"line\">      &#125;);</div><div class=\"line\"></div><div class=\"line\">      try &#123;</div><div class=\"line\">        fn.apply(ctx, args); // 调用参数列表</div><div class=\"line\">      &#125; catch (err) &#123;</div><div class=\"line\">        done(err); // 返回错误</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"https://github.com/tj/node-thunkify\" target=\"_blank\" rel=\"external\">node-thunkify</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/05/thunk.html\" target=\"_blank\" rel=\"external\">阮一峰-Thunk 函数的含义和用法</a></p>\n</li>\n<li><p><a href=\"http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/\" target=\"_blank\" rel=\"external\">experiments-with-koa-and-javascript-generators</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Thunk\"><a href=\"#什么是Thunk\" class=\"headerlink\" title=\"什么是Thunk\"></a>什么是Thunk</h2><p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>\n<p>写一个简单的函数，用于读取package.json的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(&apos;package.json&apos;, (err, data) =&gt; &#123;</div><div class=\"line\">    if (err) throw err;</div><div class=\"line\">    console.log(data.toString())</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">const app = new Koa()</div><div class=\"line\"></div><div class=\"line\">app.use(function*(next) &#123;</div><div class=\"line\">    const data = yield readFileThunk(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    yield next</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileThunk(path, cb) &#123;</div><div class=\"line\">    return function(cb) &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw err</div><div class=\"line\">            cb(null, data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">app.listen(3000)</div></pre></td></tr></table></figure>\n<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async(ctx, next) =&gt; &#123;</div><div class=\"line\">    const data = await readFileWrap(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    await next()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileWrap(path, cb) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw reject(error)</div><div class=\"line\">            resolve(data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>\n<ol>\n<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>\n<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>\n<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkit(fn) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        var args = Array.prototype.slice.call(arguments) </div><div class=\"line\">        return function(cb) &#123;</div><div class=\"line\">            args.push(cb)</div><div class=\"line\">            return fn.apply(this, args)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>\n<h2 id=\"thunkify源码解析\"><a href=\"#thunkify源码解析\" class=\"headerlink\" title=\"thunkify源码解析\"></a>thunkify源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkify(fn)&#123;</div><div class=\"line\">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); // 是否为函数</div><div class=\"line\"></div><div class=\"line\">  return function()&#123;</div><div class=\"line\">    var args = new Array(arguments.length); </div><div class=\"line\">    var ctx = this; // 绑定函数的上下文对象</div><div class=\"line\">\t</div><div class=\"line\">\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组</div><div class=\"line\">    for(var i = 0; i &lt; args.length; ++i) &#123;</div><div class=\"line\">      args[i] = arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return function(done)&#123;</div><div class=\"line\">      var called; // 记录是否执行回调，只允许执行一次</div><div class=\"line\"></div><div class=\"line\">      args.push(function()&#123;</div><div class=\"line\">        if (called) return;</div><div class=\"line\">        called = true;</div><div class=\"line\">        done.apply(null, arguments);</div><div class=\"line\">      &#125;);</div><div class=\"line\"></div><div class=\"line\">      try &#123;</div><div class=\"line\">        fn.apply(ctx, args); // 调用参数列表</div><div class=\"line\">      &#125; catch (err) &#123;</div><div class=\"line\">        done(err); // 返回错误</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"https://github.com/tj/node-thunkify\" target=\"_blank\" rel=\"external\">node-thunkify</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/05/thunk.html\" target=\"_blank\" rel=\"external\">阮一峰-Thunk 函数的含义和用法</a></p>\n</li>\n<li><p><a href=\"http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/\" target=\"_blank\" rel=\"external\">experiments-with-koa-and-javascript-generators</a></p>\n</li>\n</ul>\n"},{"title":"简历中的STAR原则","date":"2017-10-08T13:53:25.000Z","_content":"\n## STAR概念\n\n- Situation：事情是在什么情况下发生的\n- Task：主要的任务目标是什么\n- Action：朝向目标的具体行动方式\n- Result：结果如何，有哪些成长\n\nStar法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。\n\n## Example 1\n\n举一个示例：获得省比赛跨栏季军。\n\nS：省比赛一共有三十个四川省本科院校，其中B组参赛有12个院校，我处于B组。\n\nT：获取前三名，为学院争光。\n\nA：在学校每周都会进行两次跨栏训练。\n\nR：获得四川省110跨栏比赛季军，并受到学院表彰。\n\n## 总结\n\n明确目标，保持专注，大步向前。\n","source":"_posts/简历中的STAR原则.md","raw":"---\ntitle: 简历中的STAR原则\ndate: 2017-10-08 21:53:25\ntags: tricks\n---\n\n## STAR概念\n\n- Situation：事情是在什么情况下发生的\n- Task：主要的任务目标是什么\n- Action：朝向目标的具体行动方式\n- Result：结果如何，有哪些成长\n\nStar法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。\n\n## Example 1\n\n举一个示例：获得省比赛跨栏季军。\n\nS：省比赛一共有三十个四川省本科院校，其中B组参赛有12个院校，我处于B组。\n\nT：获取前三名，为学院争光。\n\nA：在学校每周都会进行两次跨栏训练。\n\nR：获得四川省110跨栏比赛季军，并受到学院表彰。\n\n## 总结\n\n明确目标，保持专注，大步向前。\n","slug":"简历中的STAR原则","published":1,"updated":"2017-10-09T05:14:12.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaggj8cr0016nuc3jrjfb3kr","content":"<h2 id=\"STAR概念\"><a href=\"#STAR概念\" class=\"headerlink\" title=\"STAR概念\"></a>STAR概念</h2><ul>\n<li>Situation：事情是在什么情况下发生的</li>\n<li>Task：主要的任务目标是什么</li>\n<li>Action：朝向目标的具体行动方式</li>\n<li>Result：结果如何，有哪些成长</li>\n</ul>\n<p>Star法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。</p>\n<h2 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h2><p>举一个示例：获得省比赛跨栏季军。</p>\n<p>S：省比赛一共有三十个四川省本科院校，其中B组参赛有12个院校，我处于B组。</p>\n<p>T：获取前三名，为学院争光。</p>\n<p>A：在学校每周都会进行两次跨栏训练。</p>\n<p>R：获得四川省110跨栏比赛季军，并受到学院表彰。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>明确目标，保持专注，大步向前。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"STAR概念\"><a href=\"#STAR概念\" class=\"headerlink\" title=\"STAR概念\"></a>STAR概念</h2><ul>\n<li>Situation：事情是在什么情况下发生的</li>\n<li>Task：主要的任务目标是什么</li>\n<li>Action：朝向目标的具体行动方式</li>\n<li>Result：结果如何，有哪些成长</li>\n</ul>\n<p>Star法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。</p>\n<h2 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h2><p>举一个示例：获得省比赛跨栏季军。</p>\n<p>S：省比赛一共有三十个四川省本科院校，其中B组参赛有12个院校，我处于B组。</p>\n<p>T：获取前三名，为学院争光。</p>\n<p>A：在学校每周都会进行两次跨栏训练。</p>\n<p>R：获得四川省110跨栏比赛季军，并受到学院表彰。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>明确目标，保持专注，大步向前。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjaggj8ah0000nuc3l5n535t5","tag_id":"cjaggj8ay0003nuc3bebp3l10","_id":"cjaggj8bc0008nuc384x54gfx"},{"post_id":"cjaggj8ba0006nuc3ugxtnf1f","tag_id":"cjaggj8ay0003nuc3bebp3l10","_id":"cjaggj8bd000anuc3ink24ez4"},{"post_id":"cjaggj8bc0009nuc3d71zpauu","tag_id":"cjaggj8ay0003nuc3bebp3l10","_id":"cjaggj8bf000dnuc34oiu7xqd"},{"post_id":"cjaggj8at0002nuc3dm7cenc7","tag_id":"cjaggj8bb0007nuc35i1dz4ze","_id":"cjaggj8bk000fnuc3vkttv8qt"},{"post_id":"cjaggj8bf000enuc3ofzijr70","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8bu000inuc30wcyhfov"},{"post_id":"cjaggj8b50004nuc39ylb76uc","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8bv000knuc3ezwxkbdo"},{"post_id":"cjaggj8bk000gnuc3u5gejck8","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8c2000nnuc3l9xxh2a0"},{"post_id":"cjaggj8b70005nuc3olf1vkgf","tag_id":"cjaggj8bb0007nuc35i1dz4ze","_id":"cjaggj8c8000pnuc3byktahvg"},{"post_id":"cjaggj8c3000onuc3e77cci17","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8c9000snuc3dkvieqfo"},{"post_id":"cjaggj8be000bnuc3y0wvhqv9","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8cb000unuc3hcs5psdm"},{"post_id":"cjaggj8bv000lnuc31z2kl9t5","tag_id":"cjaggj8c9000rnuc3yiamlbud","_id":"cjaggj8cf000ynuc3505nqguw"},{"post_id":"cjaggj8cb000vnuc3zoi27coj","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8co0010nuc3rhl2uz0a"},{"post_id":"cjaggj8cc000xnuc3dxmjhtvo","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8cq0013nuc3siq9sdvn"},{"post_id":"cjaggj8ci000znuc3l6m0cfrm","tag_id":"cjaggj8cc000wnuc3l5bn41aw","_id":"cjaggj8cr0015nuc3dcuvs3b2"},{"post_id":"cjaggj8c8000qnuc3khzkf3gn","tag_id":"cjaggj8cc000wnuc3l5bn41aw","_id":"cjaggj8cs0017nuc336tavm7n"},{"post_id":"cjaggj8cp0011nuc3ugerjxuk","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8ct0018nuc3jasb6d76"},{"post_id":"cjaggj8cq0014nuc3kwxhhmab","tag_id":"cjaggj8bf000cnuc3w9p0jdhn","_id":"cjaggj8ct0019nuc3587p3950"},{"post_id":"cjaggj8ca000tnuc3w2vjft79","tag_id":"cjaggj8cp0012nuc3d4ggvpvh","_id":"cjaggj8ct001anuc3u41wg4cg"},{"post_id":"cjaggj8cr0016nuc3jrjfb3kr","tag_id":"cjaggj8bb0007nuc35i1dz4ze","_id":"cjaggj8cu001bnuc3gzfufap4"}],"Tag":[{"name":"web","_id":"cjaggj8ay0003nuc3bebp3l10"},{"name":"tricks","_id":"cjaggj8bb0007nuc35i1dz4ze"},{"name":"js","_id":"cjaggj8bf000cnuc3w9p0jdhn"},{"name":"nodejs","_id":"cjaggj8c9000rnuc3yiamlbud"},{"name":"python","_id":"cjaggj8cc000wnuc3l5bn41aw"},{"name":"vue","_id":"cjaggj8cp0012nuc3d4ggvpvh"}]}}