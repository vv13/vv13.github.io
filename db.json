{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/imgs/flex布局.png","path":"imgs/flex布局.png","modified":0,"renderable":0},{"_id":"source/imgs/js变量的内存管理.jpg","path":"imgs/js变量的内存管理.jpg","modified":0,"renderable":0},{"_id":"source/imgs/git实用命令技巧-2.png","path":"imgs/git实用命令技巧-2.png","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-1.jpg","path":"imgs/冒泡、选择与插入排序-1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-3.jpg","path":"imgs/冒泡、选择与插入排序-3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/git实用命令技巧-1.png","path":"imgs/git实用命令技巧-1.png","modified":0,"renderable":0},{"_id":"source/imgs/冒泡、选择与插入排序-2.jpg","path":"imgs/冒泡、选择与插入排序-2.jpg","modified":0,"renderable":0},{"_id":"themes/13/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/13/source/js/disqus.js","path":"js/disqus.js","modified":0,"renderable":1},{"_id":"themes/13/source/css/const.less","path":"css/const.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"themes/13/source/css/vv13.less","path":"css/vv13.less","modified":0,"renderable":1},{"_id":"themes/13/source/js/vv13.js","path":"js/vv13.js","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/HELP-US-OUT.txt","path":"css/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/pagination.less","path":"css/partials/pagination.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/post.less","path":"css/partials/post.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/sidemenu.less","path":"css/partials/sidemenu.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/partials/title-info.less","path":"css/partials/title-info.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/css/font-awesome.css","path":"css/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/css/font-awesome.min.css","path":"css/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/bordered-pulled.less","path":"css/font-awesome/less/bordered-pulled.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/animated.less","path":"css/font-awesome/less/animated.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/core.less","path":"css/font-awesome/less/core.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/fixed-width.less","path":"css/font-awesome/less/fixed-width.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/font-awesome.less","path":"css/font-awesome/less/font-awesome.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/larger.less","path":"css/font-awesome/less/larger.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/mixins.less","path":"css/font-awesome/less/mixins.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/icons.less","path":"css/font-awesome/less/icons.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/path.less","path":"css/font-awesome/less/path.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/rotated-flipped.less","path":"css/font-awesome/less/rotated-flipped.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/list.less","path":"css/font-awesome/less/list.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/stacked.less","path":"css/font-awesome/less/stacked.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/screen-reader.less","path":"css/font-awesome/less/screen-reader.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/less/variables.less","path":"css/font-awesome/less/variables.less","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/scss/font-awesome.scss","path":"css/font-awesome/scss/font-awesome.scss","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.woff","path":"css/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.woff2","path":"css/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/FontAwesome.otf","path":"css/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.eot","path":"css/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.ttf","path":"css/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.svg","path":"css/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"264365778c4fa8f76160534958dc960521a0d60b","modified":1502128812000},{"_id":"source/CNAME","hash":"f48d71d79d74551ad16105e080a5acbfec1bef79","modified":1502129735000},{"_id":"source/favicon.ico","hash":"77804a0523be198ceeea245b69aef92019fa0716","modified":1502385637000},{"_id":"source/_posts/.DS_Store","hash":"b7b4ea54547ed9e42523f53b84de4e001bdde038","modified":1502128829000},{"_id":"source/_posts/2016-11-21-js变量的内存管理.md","hash":"b4e91c5c70b4a5a43bfdaa9a3bb47b796f24cf9b","modified":1502199757000},{"_id":"source/_posts/2016-12-09-js代理函数技巧.md","hash":"00e3eaf4a44fe1c952085eeb5afc3ca08885c268","modified":1502384140000},{"_id":"source/_posts/2016-12-09-js变量申明解析.md","hash":"53f7ef06b02cad52d9b351ab20f13a2ce8da5afe","modified":1502199849000},{"_id":"source/_posts/2016-12-11-git实用命令技巧.md","hash":"a56924dc45b6f4e3af475d0468450de5a2d59cf7","modified":1502199863000},{"_id":"source/_posts/2016-12-18-BOM对象的应用.md","hash":"672e2e5cf4885023ffe28d23b8b0d99d9181f6d3","modified":1502199868000},{"_id":"source/_posts/2016-12-25-nodejs中exports与module-exports的区别.md","hash":"705f7c402008ad8e09f6e89bca4fdf38b2ce2a21","modified":1502199873000},{"_id":"source/_posts/2016-12-25python变量作用域.md","hash":"7fd0a57311185de5b79e470634d04608e5171339","modified":1502199882000},{"_id":"source/_posts/2016-12-26-冒泡、选择与插入排序.markdown","hash":"97b31395c753fa4813651c2397d4c3ad76b7d045","modified":1502199888000},{"_id":"source/_posts/2016-12-26-求质数的几种方法.md","hash":"96111dd03ffbe2fa5f84f27bc017a3ead78c7370","modified":1502199898000},{"_id":"source/_posts/2017-01-09-BEM规范.md","hash":"7200ac096a390acf0e84c61c6d54c00c8a4f4a38","modified":1502199903000},{"_id":"source/_posts/2017-01-21-flex布局.md","hash":"38fd063d60b2fd71692ca61fde2473d5de69e14b","modified":1502199908000},{"_id":"source/_posts/2017-03-06-深入理解javascript线程.md","hash":"e1c9addf0c2cde3dd3bba5f27d903473641b2a29","modified":1502199916000},{"_id":"source/_posts/2017-03-31-vue中如何自定义v-model.md","hash":"4e598e72da061d163111640c2d1085c0cef536fb","modified":1502385344000},{"_id":"source/_posts/2017-08-22-异步编程中的thunk函数.md","hash":"579c0aa876ffa159bb95022a885c5b3bdad0a95a","modified":1503422646000},{"_id":"source/imgs/flex布局.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1502129038000},{"_id":"source/imgs/js变量的内存管理.jpg","hash":"0eb4c720b8b5e9759f7bf066e6353a0d0feae7ca","modified":1502129038000},{"_id":"source/imgs/git实用命令技巧-2.png","hash":"ce3db35ad9792984e3f543ddd13841a10bcf4a88","modified":1502129038000},{"_id":"source/imgs/冒泡、选择与插入排序-1.jpg","hash":"9ab13dd7666249f0e7364a8cc8b7ef6da268d0ee","modified":1502129038000},{"_id":"source/imgs/冒泡、选择与插入排序-3.jpg","hash":"2943a4f2ffc2f5fec69edecc54e9607c715f72b7","modified":1502129038000},{"_id":"source/imgs/git实用命令技巧-1.png","hash":"73d8e732cd22b30e4aab60e894af9619bc4a4473","modified":1502129038000},{"_id":"source/imgs/冒泡、选择与插入排序-2.jpg","hash":"b7a7bdf51ea8bf16be33aff322472bbc1ccbd13f","modified":1502129038000},{"_id":"public/atom.xml","hash":"70db19046505caccf385a97706b2bd09a0a188e4","modified":1504583454374},{"_id":"public/2017/08/23/2017-08-22-异步编程中的thunk函数/index.html","hash":"ecbd42f58e24f913d3d0509f03f6d44920e34a66","modified":1504583454416},{"_id":"public/2017/03/31/2017-03-31-vue中如何自定义v-model/index.html","hash":"c652cda499c42ba542ec58f54eb3d5226c610d37","modified":1504583454416},{"_id":"public/2017/02/09/2017-03-06-深入理解javascript线程/index.html","hash":"8b4308f9bf727960c51722383859ae94c95c2905","modified":1504583454416},{"_id":"public/2017/01/21/2017-01-21-flex布局/index.html","hash":"7576b8243abd42cf6fe8d80121cda66b1b45d015","modified":1504583454417},{"_id":"public/2017/01/09/2017-01-09-BEM规范/index.html","hash":"e039b0f83129a29c7cbecc0d730c1d69a414a621","modified":1504583454417},{"_id":"public/2016/12/26/2016-12-26-冒泡、选择与插入排序/index.html","hash":"2b613edcca96a5b7bc1f47fef4721a5f74784465","modified":1504583454417},{"_id":"public/2016/12/26/2016-12-26-求质数的几种方法/index.html","hash":"dc527fd475035a59a91af0f02ef26235c17b96bb","modified":1504583454417},{"_id":"public/2016/12/25/2016-12-25-nodejs中exports与module-exports的区别/index.html","hash":"e3b88e1e0a2ce8c82f1a25791902c40badb8817d","modified":1504583454417},{"_id":"public/2016/12/25/2016-12-25python变量作用域/index.html","hash":"1349b31319032cbe1e364cb212cb9744a5267105","modified":1504583454417},{"_id":"public/2016/12/18/2016-12-18-BOM对象的应用/index.html","hash":"82da15524f382cda4c3e581028effc66a2e05434","modified":1504583454417},{"_id":"public/2016/12/11/2016-12-11-git实用命令技巧/index.html","hash":"1c6aa1908185988f455b4807e836384a1c4fd2c4","modified":1504583454417},{"_id":"public/2016/12/09/2016-12-09-js变量申明解析/index.html","hash":"d733592d6b0b6295e72333f375ed23983fa8b178","modified":1504583454418},{"_id":"public/2016/12/09/2016-12-09-js代理函数技巧/index.html","hash":"ba23eeaf20be0bae0dc997f8a449132bd6a98729","modified":1504583454418},{"_id":"public/2016/11/21/2016-11-21-js变量的内存管理/index.html","hash":"7b198b71a472452054c4eee922b07fededd1ab06","modified":1504583454418},{"_id":"public/archives/index.html","hash":"e9a32795432899f49f9d5b247f62b539c63b4f15","modified":1504583454419},{"_id":"public/archives/page/2/index.html","hash":"ccd573e6220e5398f063e52b2bb1f887b887c89b","modified":1504583454419},{"_id":"public/archives/2016/index.html","hash":"eafecb2a9f1c8cf366187146ee8824e95c0c2495","modified":1504583454419},{"_id":"public/archives/2016/11/index.html","hash":"8f67bd4068e26e86d9f0fa51618ee382b1ad12f2","modified":1504583454419},{"_id":"public/archives/2016/12/index.html","hash":"54405b3e65fab4602c83a20777fd6e1c9f2f5c45","modified":1504583454419},{"_id":"public/archives/2017/index.html","hash":"6d0e10b7ed85a52cfa83f9e9b88271c722d1d830","modified":1504583454420},{"_id":"public/archives/2017/01/index.html","hash":"761e9e4d86adec2a1a521af07a8344a38e85dbda","modified":1504583454420},{"_id":"public/archives/2017/02/index.html","hash":"8dcd079ed52d6a532d5f7beb7f8d6f710a76b036","modified":1504583454420},{"_id":"public/archives/2017/03/index.html","hash":"c058978b1731b43aa0bd7668e3ee8647b83720de","modified":1504583454420},{"_id":"public/archives/2017/08/index.html","hash":"482360dbfa027cb766c87f6d276eac7a22685cbc","modified":1504583454420},{"_id":"public/index.html","hash":"8c136ef5df540d400295d2e130a814d54c5a9cb5","modified":1504583454421},{"_id":"public/page/2/index.html","hash":"2a496762e81dc7fc81d359e6ba567d9310487920","modified":1504583454420},{"_id":"public/tags/js/index.html","hash":"bcda8642cfda11fd472cf829e217658b024c9ec8","modified":1504583454420},{"_id":"public/tags/tricks/index.html","hash":"9d6eb68d4ec12df7ec48831289bacf1275dd7b5c","modified":1504583454420},{"_id":"public/tags/nodejs/index.html","hash":"9616c1134f32eae9beb4f9b7d2804b405c6a299c","modified":1504583454420},{"_id":"public/tags/python/index.html","hash":"8f3f820b983397c4c67bca82ab3b8e14391269bc","modified":1504583454420},{"_id":"public/tags/web/index.html","hash":"d5c0487e7b8fbd0dcb19242731f3e1e67baa040b","modified":1504583454421},{"_id":"public/tags/vue/index.html","hash":"142ee81f188e9f92772f5e62d27d1bf0cd37d0e4","modified":1504583454421},{"_id":"public/CNAME","hash":"f48d71d79d74551ad16105e080a5acbfec1bef79","modified":1504582959122},{"_id":"public/favicon.ico","hash":"77804a0523be198ceeea245b69aef92019fa0716","modified":1504582959122},{"_id":"public/imgs/flex布局.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1504582959122},{"_id":"public/imgs/js变量的内存管理.jpg","hash":"0eb4c720b8b5e9759f7bf066e6353a0d0feae7ca","modified":1504582959122},{"_id":"public/imgs/git实用命令技巧-2.png","hash":"ce3db35ad9792984e3f543ddd13841a10bcf4a88","modified":1504582959122},{"_id":"public/imgs/冒泡、选择与插入排序-1.jpg","hash":"9ab13dd7666249f0e7364a8cc8b7ef6da268d0ee","modified":1504582959122},{"_id":"public/imgs/冒泡、选择与插入排序-3.jpg","hash":"2943a4f2ffc2f5fec69edecc54e9607c715f72b7","modified":1504582959122},{"_id":"public/imgs/git实用命令技巧-1.png","hash":"73d8e732cd22b30e4aab60e894af9619bc4a4473","modified":1504582959124},{"_id":"public/imgs/冒泡、选择与插入排序-2.jpg","hash":"b7a7bdf51ea8bf16be33aff322472bbc1ccbd13f","modified":1504582959124},{"_id":"themes/13/.DS_Store","hash":"82821d28cd6299b5430ce52717126ad20a6b6c2a","modified":1501088584000},{"_id":"themes/13/.gitignore","hash":"fadea9edd29e83c1866d8ff5246d38b9e4254801","modified":1502389260000},{"_id":"themes/13/README.md","hash":"dedb0722e2cce178ffd171672159211d954f1ba1","modified":1502671744000},{"_id":"themes/13/_config.yml","hash":"f449cbd5a89200f3b46a7522594ced08033ab410","modified":1502385932000},{"_id":"themes/13/.git/COMMIT_EDITMSG","hash":"345084de08339e8c286ebeac5a8cb6d4cf92d292","modified":1502671725000},{"_id":"themes/13/.git/FETCH_HEAD","hash":"560e79b318e471b8f045b33b7aadcc9293fb1a0d","modified":1502671744000},{"_id":"themes/13/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1502671744000},{"_id":"themes/13/.git/config","hash":"c137b33534412f14639d0f20dc1ae5da61084088","modified":1502389392000},{"_id":"themes/13/.git/ORIG_HEAD","hash":"ee5fcbc32017e1ac59570cb034acc427d3df4513","modified":1502671744000},{"_id":"themes/13/.git/index","hash":"69af7eb227a0311c69281fb8c98bfc61f7721fee","modified":1502671748000},{"_id":"themes/13/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1502389230000},{"_id":"themes/13/layout/archive.pug","hash":"d8a9ca1a38bfbe264314267e1646c6dc53b16806","modified":1498494263000},{"_id":"themes/13/layout/category.pug","hash":"f305f0dccf29d12ab0b1f5633aea8ae9a39f3255","modified":1502671744000},{"_id":"themes/13/layout/index.pug","hash":"b8007c441d4b86435a8751d38bd2477e890f9f3d","modified":1502117975000},{"_id":"themes/13/layout/page.pug","hash":"4696a806523bf60fcfae96982ea1194afc631e63","modified":1502199967000},{"_id":"themes/13/layout/post.pug","hash":"35a31857b24316275f37818fde54b7b499b49582","modified":1502671744000},{"_id":"themes/13/layout/tag.pug","hash":"03bdf55dabf0f0630f6c4eb992b95a1e56620fa8","modified":1502671744000},{"_id":"themes/13/source/.DS_Store","hash":"c58599eba8cc806344e95807f87b76fbf05d14e6","modified":1501088584000},{"_id":"themes/13/source/favicon.ico","hash":"77804a0523be198ceeea245b69aef92019fa0716","modified":1502385808000},{"_id":"themes/13/source/js/disqus.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1501006821000},{"_id":"themes/13/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1502389230000},{"_id":"themes/13/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1502389230000},{"_id":"themes/13/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1502389230000},{"_id":"themes/13/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1502389230000},{"_id":"themes/13/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1502389230000},{"_id":"themes/13/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1502389230000},{"_id":"themes/13/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1502389230000},{"_id":"themes/13/.git/logs/HEAD","hash":"b34058c73cd118d63ba6a16e7b28cd43b477cb2c","modified":1502671744000},{"_id":"themes/13/layout/includes/article-tags.pug","hash":"b50d1beb77a7300681e0618e71414cfb724b6448","modified":1500996413000},{"_id":"themes/13/layout/includes/article-categories.pug","hash":"8ed9aaa5d32950dcde8b91d29b3649da92bfb6bd","modified":1500996621000},{"_id":"themes/13/layout/includes/disqus.pug","hash":"7c01484a808ce30a947807e2456fd8c838608c10","modified":1502387063000},{"_id":"themes/13/layout/includes/footer.pug","hash":"e82c1b1f1b3c12cf0a14eb75301013f755b2d786","modified":1502128732000},{"_id":"themes/13/layout/includes/layout.pug","hash":"75620516dd429ead30d9bda600bda43d945e471e","modified":1502671744000},{"_id":"themes/13/layout/includes/pagination.pug","hash":"d1393902b555c46524da870ba78d244a074a56b7","modified":1502020640000},{"_id":"themes/13/layout/includes/recent-posts.pug","hash":"53440e9655a6ae8e2d3202d33f2fa83c5c00caed","modified":1502201199000},{"_id":"themes/13/layout/includes/sidemenu.pug","hash":"46c7086d971012dae2765b9edbe5cca25297d990","modified":1502671744000},{"_id":"themes/13/layout/mixins/title-info.pug","hash":"70558fb35525ef57005aa9e494badfeed66ce5bb","modified":1502130179000},{"_id":"themes/13/source/css/.DS_Store","hash":"70955943c87c488c8d9dacae0664351d5d4b9e0a","modified":1501119361000},{"_id":"themes/13/source/css/const.less","hash":"50e9ebb3ba129770d554c377cca7d4411ecf9fe8","modified":1502118846000},{"_id":"themes/13/source/css/github-markdown.css","hash":"74a4ec889dc85a75bdfbb86ab19e241a53d8f542","modified":1502385276000},{"_id":"themes/13/source/css/vv13.less","hash":"71fed879b328fd1642513af38a5034ca61f153de","modified":1502671744000},{"_id":"themes/13/source/js/vv13.js","hash":"1dd34bf40925ed8df8120fd819f155319862e559","modified":1502671744000},{"_id":"themes/13/.git/refs/heads/master","hash":"47cbca026668fb7df4018df5bf6677dc7109e221","modified":1502671744000},{"_id":"themes/13/.git/objects/00/b613fff7af31ebfde3d3a6e99d61c43f7ceb09","hash":"72a2c8b7c61e46a606fe8a63f633edd1279e3315","modified":1502389313000},{"_id":"themes/13/.git/objects/00/1a647776affc49705381ade2e72c4c39a7d846","hash":"29198f4d006e909613f2da2aac8e2531fd93fd48","modified":1502671744000},{"_id":"themes/13/.git/objects/01/37f8da3d39f4bfcd2e88e5a0bfa4ec8ad770d7","hash":"702a316f306bfd8aaee056eafc6d58c93721a656","modified":1502389313000},{"_id":"themes/13/.git/objects/02/86c7275f976c17aa9fd5dc312f793498ab6146","hash":"d6992a51974edd9fdc74ef75b0aaf1e60e3ae7de","modified":1502389340000},{"_id":"themes/13/.git/objects/0a/0704a420bb16c2c258ee3a74baf479d15d8762","hash":"f6e226b1a8f8003f66ed71a652b2f8bd858f0ce7","modified":1502389319000},{"_id":"themes/13/.git/objects/08/094668e3b7a4c051015d695f70c130dd5a19d9","hash":"4dc08ecfbddf332b2bdf606fe909dcbe4a5c3713","modified":1502389313000},{"_id":"themes/13/.git/objects/0b/440382f61f0bb1683e5b15c2a00e4e398f9980","hash":"44808c3eb62e6ee72c611183b3bfb5f4f84a750b","modified":1502389313000},{"_id":"themes/13/.git/objects/13/41f3e370a18688f064745bcc3de4b86a760447","hash":"625232771687889bf455f02dacdbbc91ede79bfd","modified":1502389313000},{"_id":"themes/13/.git/objects/11/0289f2f4b5260ce04dd035408961f1e4f2785b","hash":"9ab545e4728997f085078383f8835a939a46c346","modified":1502389313000},{"_id":"themes/13/.git/objects/11/c188196d5ade55930b7b94fc5a1dd0f6d1a800","hash":"8ae1b6fed8a3837d32ee9cf782c09767cd5e462d","modified":1502389313000},{"_id":"themes/13/.git/objects/15/9d600425c73c282be34f94af12179f091a16d2","hash":"c92d9ab9e9ccd8493957d1de655bdaf5c38e291e","modified":1502389313000},{"_id":"themes/13/.git/objects/1f/ba460b43891c1ca17ef10c4050e05ca0a6efd3","hash":"d6ba10ce9be05a3c47b2429f849e48f91f2dc773","modified":1502389313000},{"_id":"themes/13/.git/objects/2e/d1a54c957082d7f7336e57a4ae83d817ab9b63","hash":"d5cb8ce5885ec7a4bcc3a49ebae173d2b7f58990","modified":1502389313000},{"_id":"themes/13/.git/objects/0c/00abd154053357cf10c3863c0252d2edb48a59","hash":"17497e09287eb04d82a13873595b2c1d49c49ccb","modified":1502389313000},{"_id":"themes/13/.git/objects/10/de2c5bae38eb467255d3e47573edc84581515f","hash":"e2a6e9f204e866dc711beef900fd0873dbc97f40","modified":1502671744000},{"_id":"themes/13/.git/objects/35/21b0ef2971a96024ebd988c7e0cfafc7f5553b","hash":"1f2a6b7ec5b86f890277d1fa797722f54c7325d8","modified":1502671744000},{"_id":"themes/13/.git/objects/41/e9a8184aa287c5970cc8415e3c5a6310dc9f79","hash":"4f3ea7778b43c1eb583e5d69d37a738ce07f7a57","modified":1502389313000},{"_id":"themes/13/.git/objects/45/f5380fbc8743ce7d6067d0c4c30d034c69c317","hash":"7eb5b03f95fba5c385104283368046c21509ef66","modified":1502671744000},{"_id":"themes/13/.git/objects/44/3fa060fab51d5a32c14061e3793a8348471803","hash":"59ab8903ae12bb848550ff04082b72dc3ca1abca","modified":1502671744000},{"_id":"themes/13/.git/objects/39/bf10f676f23262b821b3902ef1b0c8e54f4e10","hash":"d2d2719a63adedcf19b3ca17b3dfffa8c2f030a7","modified":1502671744000},{"_id":"themes/13/.git/objects/33/3ce4820cf4e03192edcd6c5a41755c4dc97bad","hash":"045ba86b369b7f78bebdb444153d6aa57f63e8fb","modified":1502671725000},{"_id":"themes/13/.git/objects/49/49bad47d3e22994594660484de0c73042a8744","hash":"327d0f1c8bd5d9932f754ed4773d1475a7130d52","modified":1502389313000},{"_id":"themes/13/.git/objects/49/8fc4a087c614614166df2e9f08bb5e0071daf4","hash":"5c1fcc2fea8a027202db52ef389ac142e19c559f","modified":1502389313000},{"_id":"themes/13/.git/objects/49/a817e6dd851f23efb04dee99910e5a16cbbd92","hash":"9a2daaa22f2db1d055b11cd9bc4de4f4310947c4","modified":1502389313000},{"_id":"themes/13/.git/objects/4b/032312f841032fe9ab96a9626b4f026247e1e4","hash":"18c05c6f768995b2dccca5b4fba0d48c509b5cb7","modified":1502389313000},{"_id":"themes/13/.git/objects/4d/519bfec3b04a13b1584ad6bf9532f8c10f24ee","hash":"7cd4123002c953bffb92b8e48d8f5ad52c0e25f5","modified":1502671744000},{"_id":"themes/13/.git/objects/52/704e47b853d6619780ca285f58e90da13f22f5","hash":"2163ebdc7a7f543582f2e877094ca0b279a83750","modified":1502389340000},{"_id":"themes/13/.git/objects/54/0440ce89f2a408aa699b65100e18f15e0f09ca","hash":"2e363893fc6ce9c409347af769daffb3d335096f","modified":1502389313000},{"_id":"themes/13/.git/objects/5c/24831e3b4e4f4f7431fb9c4f0dadd60f124e7f","hash":"8257ebe9ce73f5b03360d75e802543f5f07f409f","modified":1502671744000},{"_id":"themes/13/.git/objects/68/17f827b3f3ffd3ab75b30e455c576013f1206d","hash":"4057804b82c4e121a9145c93506f021282fafc8a","modified":1502389313000},{"_id":"themes/13/.git/objects/63/7426f0da6dcef3602d764d9e359dabb4a5a862","hash":"78f8bd636e97c6f5c9f6e1428294a28440b774f9","modified":1502389313000},{"_id":"themes/13/.git/objects/5c/cf7e2d961c08bd7146ae8dac24acca3d8cc1a4","hash":"145d1e3e4d314c8776941f672d5e618ddd36abb0","modified":1502389313000},{"_id":"themes/13/.git/objects/66/ad52a5ba052ced428dcc7ec7016bc25438a2ca","hash":"125699e87e53eb0815637a9c803f21f50233351e","modified":1502389313000},{"_id":"themes/13/.git/objects/6e/ec7c5901d8ca4d2ad528f31cb6d82b4fea6635","hash":"284990de5861e0d74c93ec7e683cebbf606b16a0","modified":1502389313000},{"_id":"themes/13/.git/objects/74/25ef85fc80ce6b035065906fc27490715e3733","hash":"16078521b931191896047cb1c3d24dde1a4a6232","modified":1502389313000},{"_id":"themes/13/.git/objects/75/cc0637c8dcbe68bec98467659933c969dee4b7","hash":"90b6659bb12897f4676cf365c91bb2223d09ba20","modified":1502389340000},{"_id":"themes/13/.git/objects/72/1acdb78e26cf746a5d80970e7d8e621a9189bc","hash":"56b2af973447a20bfd16f425c4390895ff4106bc","modified":1502389340000},{"_id":"themes/13/.git/objects/76/11c8decbd6039b49e8c984b853cd7c95d6a4c9","hash":"e8ecb25c62b01e27a5a278dd11b012f960017e85","modified":1502389313000},{"_id":"themes/13/.git/objects/7d/dbbc0115f5b017bae9f401651f00d824a396b2","hash":"5d27a4a3bd5d82b3ced49ab99f11f23fcc98db17","modified":1502389313000},{"_id":"themes/13/.git/objects/7d/1e4d54d6c293333eb638aa56feba7b62e15564","hash":"7824a66652e35f7aae1d285ba8467bf798ab0a9c","modified":1502389313000},{"_id":"themes/13/.git/objects/7e/92f34a1a51eb86f437760a78187b34558362ec","hash":"b88ed315e43766dc345b51c0503e9f07b185eddc","modified":1502671744000},{"_id":"themes/13/.git/objects/83/2a1286ff3c7d14880a0d05b4443a37747ded59","hash":"48ef245b802554c429d5fd6c30cefe8d6b5bdfad","modified":1502671744000},{"_id":"themes/13/.git/objects/84/e6131fa9e14e0ac4e109ae0c7a44cb6c2b6e07","hash":"8bbc51133bc3d18bb123d0a8fbe933a4eeb922e3","modified":1502389478000},{"_id":"themes/13/.git/objects/83/5be41f8151b6439f799be29ec7921af1b72593","hash":"9f7fe3876d9088f5f2aeefe42cfde1f644462656","modified":1502389313000},{"_id":"themes/13/.git/objects/83/d083dd770c94ee238774e2df508094ff5cc3a1","hash":"dc212df6983111482746a310bf37147cdcfa142b","modified":1502389313000},{"_id":"themes/13/.git/objects/89/c11feae6b6fa1f710f9101fcd9c06ad71f0c31","hash":"f25467d676b7bf235f43fcd96db02fa114417138","modified":1502671744000},{"_id":"themes/13/.git/objects/8a/020dbfff7822bf57c7217eafdaa4884b8aa943","hash":"59fe9b30355730fa043876ad245193537e250657","modified":1502389313000},{"_id":"themes/13/.git/objects/91/cd8dd4735769aa06ccbb3d74afaa7cb971484c","hash":"0e6984eb5c781e012122292dd0aa9c02c5ebb0e4","modified":1502671744000},{"_id":"themes/13/.git/objects/8e/b365063e6eecbb468b545345d21239c5cd8847","hash":"21f7339450f0857e0a1d5818c7ef1dc1acfbfb99","modified":1502671744000},{"_id":"themes/13/.git/objects/8c/69792959fbaba96e11c941a8aea6cb84006ad1","hash":"00a73ad1356049d524e0dd9f0b2a2d51cb3451dd","modified":1502671744000},{"_id":"themes/13/.git/objects/a0/e54f0498656465f6f91b0d3647b84ff9bc5086","hash":"7d98f3c1dd9c7aeb12ddb6438eeae7d0427bc5d5","modified":1502671744000},{"_id":"themes/13/.git/objects/9a/56baf6256108c11b6913a62547bcb1ae5fe5da","hash":"b8bfd4e307c87dabefbc1a13966193a7f53ee51d","modified":1502389313000},{"_id":"themes/13/.git/objects/a3/558fd09ca7cb968166d5445f4df1a0bc2d5a7e","hash":"4cdd8d9f35bdab170357eecf24d3eebfb9632569","modified":1502389313000},{"_id":"themes/13/.git/objects/a3/7777fc3ab49a8db202fdd4851a61c568abcea6","hash":"0a6b9413eb089789e1709e7eaf630cac8e88c56b","modified":1502389313000},{"_id":"themes/13/.git/objects/a5/4827a99078b7ca2ae2b73a5ea157ef0e946b4a","hash":"3f4eee1171d46459b452a0188f58bef35c76c3b1","modified":1502389340000},{"_id":"themes/13/.git/objects/a6/14cc84ea37b6bb80f1d0b09ccd784a3bb1694b","hash":"925b7098621a7be65ba15d6e8fd770b758db8557","modified":1502389313000},{"_id":"themes/13/.git/objects/a8/b18558d0df8609f0f419d449f4d36540057aef","hash":"b9fe72c253ba4caf943aca0d548b7993746b6a6b","modified":1502671744000},{"_id":"themes/13/.git/objects/a9/3a0472ab99eb7839bd06eae17f8ff7b1e8faa3","hash":"f8d96d9e409a2fb8634ad9f242e2382c181a936c","modified":1502389313000},{"_id":"themes/13/.git/objects/ac/ce9e25d879e3d7a2d712664aa72803b51e9e9a","hash":"b13b7a24c436087a8a2f65a41559dd6995a7a546","modified":1502389474000},{"_id":"themes/13/.git/objects/b4/9ce7e9fc60c1e73aad975ef6db580b8c77bb01","hash":"01e8a9639d31329b7eed377911bf657ab164a4e1","modified":1502671744000},{"_id":"themes/13/.git/objects/ae/f7403660c9a2ccc02a264c62c6b105f7d8d532","hash":"783ebd8a3937e86dba3edab4ff97b15523ec01bf","modified":1502389313000},{"_id":"themes/13/.git/objects/b2/21c98133a4d4a8449c848ccb69bf631d1c3e5d","hash":"751c186cfa88415702760ce22b994c8f98798792","modified":1502389313000},{"_id":"themes/13/.git/objects/bb/457c23a8e4e0688ebd9383e34ab9f2b3acecab","hash":"daeeabb744f3cfddaa97423bddf0188b1f8394c3","modified":1502389313000},{"_id":"themes/13/.git/objects/be/ef231d0e176a47375d93fb7365270eea52f7b4","hash":"b43dd0a75e7fb84e19775280f5f5efc737cc81a7","modified":1502389313000},{"_id":"themes/13/.git/objects/bf/c1b4432f0cb993ad81dfdb507136077b93178a","hash":"a123d6d0e8d3ec4c99e6959ed152e909b6984d6b","modified":1502389340000},{"_id":"themes/13/.git/objects/c0/19d7e29eb481027e651e181ecd01a27969d085","hash":"ca0e54f17c809875a1b27e50b929bbacd6d39b26","modified":1502389340000},{"_id":"themes/13/.git/objects/c3/677def3131af54af2a87d9cd2bb737a321e97e","hash":"8b1371ad440b89b7dafe4285deda5bf45c57ccf3","modified":1502389313000},{"_id":"themes/13/.git/objects/c3/bbd5745d35bebda3e16ce18aeff7a4a0ce5ae1","hash":"c25b1e146f0d797128c37f546af173785cce156a","modified":1502389313000},{"_id":"themes/13/.git/objects/c3/22899b59a477f4db56af6373ca49a059b96252","hash":"70731ca26ca8777e5205fb485edc3f167ad3ad49","modified":1502389340000},{"_id":"themes/13/.git/objects/c5/77ac84a6a55ef39ff7f4e25d60c3977a902ed1","hash":"17863cbe8bfb1776e230138dc2aae3a6553c1195","modified":1502389313000},{"_id":"themes/13/.git/objects/c8/38eebaab3764e5b59225da24ef6bc26941b403","hash":"65b637520a3c0bfb3dc19a11b9cb5bea5ae87941","modified":1502671744000},{"_id":"themes/13/.git/objects/c9/682a34b88a5684182619c24e74c5a08d27407e","hash":"464ec5e701d0f1e468486b0d1f32a41536dc2fca","modified":1502389313000},{"_id":"themes/13/.git/objects/c9/d646770e2186c73632cbe042d82d1d1acaa25b","hash":"0b444b6b4aadb2bd684c7fe3c5f064bf556436a2","modified":1502389313000},{"_id":"themes/13/.git/objects/c6/3a617c36f52f644f558183d39546e91519de7b","hash":"ea2ccc3f40644fb057002c58f5c2d11e82d2775b","modified":1502389340000},{"_id":"themes/13/.git/objects/ce/de52e5b81e45c4a0a2c9aa4a0775f7c9040356","hash":"eac3300e35635daf0c3d67de7ce584bef620756f","modified":1502389340000},{"_id":"themes/13/.git/objects/cb/1f02e87da49cdcd189c7417f14cd2caf8651f5","hash":"f44329fe9b4a97d9c84ba0d61454befb945c799c","modified":1502389313000},{"_id":"themes/13/.git/objects/d2/a69f7f6438247b013461d6db908c1901c7007d","hash":"e07290b15e04e362d246db9ee0499d69135408c2","modified":1502389340000},{"_id":"themes/13/.git/objects/d2/b157d0a408274279a0b579b68de52119666def","hash":"6c038efb796a33d147404ff799457ad2a87cd7ef","modified":1502671744000},{"_id":"themes/13/.git/objects/d3/cfa2ef8af33b33458b703f5441b052925254b8","hash":"ed1f0e349dbe0a651a300ca01614675441062ee1","modified":1502389313000},{"_id":"themes/13/.git/objects/d4/b85a02f24adad8890ad69f7a1db6c7e3ec8a7d","hash":"1dd2dd1cb0c57a3c630ffb82917a8271aa893aef","modified":1502389313000},{"_id":"themes/13/.git/objects/da/417bec0c6921f0df0fb32b4fef367a788174e1","hash":"85f43901ce4b71a5aff58ab708b23aedc59d7204","modified":1502389313000},{"_id":"themes/13/.git/objects/dd/3c3f42aa1515fe4842746b9ee18d05445c9309","hash":"ce6872a4b33099e816328801f824fa83fb764392","modified":1502389340000},{"_id":"themes/13/.git/objects/df/32403839a495cdb23de89ce6a7100d52ee564a","hash":"d25503084f8669508ce5b8ba9c78a6b5da4e2790","modified":1502389340000},{"_id":"themes/13/.git/objects/e2/e7ca4f8e7f839a70a49b61441fa09b6beb6158","hash":"8f99567efc865260628de351693090fca5b68571","modified":1502671744000},{"_id":"themes/13/.git/objects/e6/3e702c4d9c28fb78922cefa5daf91858b12c9a","hash":"8aaeb94dfaf17e86bce9816322d5f909f7ec133a","modified":1502389313000},{"_id":"themes/13/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391","hash":"c2baae88d6364d878fd67e778c6a5d8306ad4ab0","modified":1502389313000},{"_id":"themes/13/.git/objects/ec/3f2aec4b234edab2b76c0ded261e747dd34f74","hash":"d0e9cc7a1609881e4526afa502353cedc9be9b03","modified":1502389313000},{"_id":"themes/13/.git/objects/e7/df7a0273206883008dce8cef7bfdeebe558365","hash":"c42851e5c1026bf952dbc0e219ec880a00616768","modified":1502389313000},{"_id":"themes/13/.git/objects/ee/906a8196d0fbd581c27a9d5615db4c250860f2","hash":"befed115d962d2da4b6346309224f5d7d521fd37","modified":1502389313000},{"_id":"themes/13/.git/objects/ea/4bc425e6029b82774806fa0535ae90293db270","hash":"94e39d382f67d0f942abde07a63d7b373004e9e0","modified":1502671725000},{"_id":"themes/13/.git/objects/ef/d7ef7653239aa935a99ba806ac2515f7f0fc00","hash":"9c45f1cbfde2152d0fe731c7e82d34ad6e29137b","modified":1502389469000},{"_id":"themes/13/.git/objects/f1/c83aaa5d24da542d81b09677307f47f374401e","hash":"dd32fddf559b48d74a95cf4a8d7e70b08214bd8f","modified":1502389313000},{"_id":"themes/13/.git/objects/f1/c8ad75f52bbc6c84a6dc3a341fe39e8d3edfd4","hash":"b8e5a32495a9333b1488805253160f360f4bedda","modified":1502389313000},{"_id":"themes/13/.git/objects/f6/ba81475b92355723f0dc12767f715995a34162","hash":"c1b8cf40e123397d1243bfaaf642eb8ed01dd75a","modified":1502389313000},{"_id":"themes/13/.git/objects/f8/6aae6bb2f043769312861aa759579746cda0bd","hash":"b20d1c6ccba9a184d4d058792e6ce261fe965fef","modified":1502389313000},{"_id":"themes/13/.git/objects/fc/53fb0e7ab49594e1eac97208c32a290558efeb","hash":"285032d48cef23838c362de9cba272fcfbdf7c17","modified":1502389313000},{"_id":"themes/13/.git/objects/fd/865ec4ce5d0161aa1800bc9af3053752818f54","hash":"1a11a356d8283a38244e1f28a8c5650575592572","modified":1502389340000},{"_id":"themes/13/source/css/font-awesome/.DS_Store","hash":"e270ba6755e2dd4c58c943c907ca941b9152c297","modified":1501088485000},{"_id":"themes/13/source/css/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1495529032000},{"_id":"themes/13/source/css/partials/pagination.less","hash":"9e31ecc7e65d1176f2b9263ee349e005098eb05c","modified":1502116567000},{"_id":"themes/13/source/css/partials/post.less","hash":"bbbe8cffd6c8a32e92f302f2aa1bbb67daa00bda","modified":1502123199000},{"_id":"themes/13/source/css/partials/sidemenu.less","hash":"8b6171dab33e33d191a72c18a6998315a655e5fb","modified":1502671744000},{"_id":"themes/13/source/css/partials/title-info.less","hash":"75342fdaf2420868e305a22ad849323dd42e1275","modified":1502671744000},{"_id":"themes/13/.git/objects/40/0014a4b06eee3d0c0d54402a47ab2601b2862b","hash":"c145ad3ab1a3efcb1c3df4a470813b1b74ea43b8","modified":1502389313000},{"_id":"themes/13/.git/objects/35/acda2fa1196aad98c2adf4378a7611dd713aa3","hash":"c57681ba2ea020d954be3f1723d4626187e66b1f","modified":1502389313000},{"_id":"themes/13/.git/objects/40/1ec0f36e4f73b8efa40bd6f604fe80d286db70","hash":"0688cfde8cff71150bbccd59c4da4aa5f3597a08","modified":1502389313000},{"_id":"themes/13/.git/objects/4d/13fc60404b91e398a37200c4a77b645cfd9586","hash":"213ccde6a68f47c08264f135847ea5a8c3c05905","modified":1502389313000},{"_id":"themes/13/.git/objects/e9/f60ca953f93e35eab4108bd414bc02ddcf3928","hash":"797a4014c9739ab8a1f5bb96e18b7062a53e2f8e","modified":1502389313000},{"_id":"themes/13/.git/logs/refs/heads/master","hash":"a1a8d635b173608f120280d6e9864d3b648a4bbe","modified":1502671744000},{"_id":"themes/13/.git/refs/remotes/origin/master","hash":"47cbca026668fb7df4018df5bf6677dc7109e221","modified":1502671757000},{"_id":"themes/13/.git/objects/85/5c845e538b65548118279537a04eab2ec6ef0d","hash":"cab9b55bf59bf50fe5d95610e0b53f20a7e5c1bf","modified":1502389313000},{"_id":"themes/13/source/css/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1495529034000},{"_id":"themes/13/source/css/font-awesome/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_core.scss","hash":"55a14a34267edc401b82e5ee41d8bd84fbb5da3f","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_animated.scss","hash":"8daf189b2f8a404495b8424b6fd1ba630dd1c2dc","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_bordered-pulled.scss","hash":"164b6a0a2b307cd293f4a914ab0fcdf643950374","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_fixed-width.scss","hash":"224417ca266c657849afb2bbcb6dc455894ff387","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_list.scss","hash":"4b53ee01513df8b9ce76442b2d8f1851613a435c","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_larger.scss","hash":"940e1c5ebc690283bfaee92560cf15fabedbf6a9","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_mixins.scss","hash":"4f3881034a4c11cae8cc915f288477b498a357a2","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_icons.scss","hash":"830e0183337d16c07b1c63838f7593a33ee87b15","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_path.scss","hash":"080158aeb1bf6df59ec98b2bbed44da61d9c9ca3","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_screen-reader.scss","hash":"2d8563c488f68e75a28d540dd89301ee4ee08c97","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_rotated-flipped.scss","hash":"ca08a0af3da63c2f2a7d3c27a8747637744cc785","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_stacked.scss","hash":"cf6752ee609af36eb293a7197c88d31ecacbbc74","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/_variables.scss","hash":"0d6d70535104b42e60d7f44ae6ccf9de023a7b8b","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1495529032000},{"_id":"themes/13/.git/logs/refs/remotes/origin/master","hash":"8669491b79406f90becf2426c99fe2baa591c658","modified":1502671757000},{"_id":"themes/13/source/css/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1495529032000},{"_id":"themes/13/source/css/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1495529032000},{"_id":"public/css/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1504583454440},{"_id":"public/css/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1504583454440},{"_id":"public/css/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1504583454767},{"_id":"public/css/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1504583454768},{"_id":"public/js/disqus.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454795},{"_id":"public/css/github-markdown.css","hash":"74a4ec889dc85a75bdfbb86ab19e241a53d8f542","modified":1504583454795},{"_id":"public/js/vv13.js","hash":"1dd34bf40925ed8df8120fd819f155319862e559","modified":1504583454796},{"_id":"public/css/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1504583454796},{"_id":"public/css/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1504583454796},{"_id":"public/css/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1504583454796},{"_id":"public/css/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1504583454796},{"_id":"public/css/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1504583454796},{"_id":"public/css/partials/post.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454801},{"_id":"public/css/partials/title-info.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454801},{"_id":"public/css/font-awesome/less/bordered-pulled.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454801},{"_id":"public/css/font-awesome/less/animated.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454801},{"_id":"public/css/font-awesome/less/core.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454801},{"_id":"public/css/font-awesome/less/fixed-width.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/larger.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/icons.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/path.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/rotated-flipped.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/list.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/stacked.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/font-awesome/less/screen-reader.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/const.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454802},{"_id":"public/css/partials/pagination.css","hash":"44e796e8af924934cd161a9b310d3d18e3be7d07","modified":1504583454802},{"_id":"public/css/partials/sidemenu.css","hash":"1256fd4ff5d1840e854778837754cf3606430f36","modified":1504583454803},{"_id":"public/css/font-awesome/less/mixins.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454803},{"_id":"public/css/font-awesome/less/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504583454803},{"_id":"public/css/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1504583454846},{"_id":"public/css/vv13.css","hash":"b8e748055e049509aff752d9274b91f676abaabb","modified":1504583455074},{"_id":"public/css/font-awesome/less/font-awesome.css","hash":"93897ebc560b38a1d2bff43c22dd6a3b7ee90c0c","modified":1504583455074}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"js变量作用域与垃圾回收","date":"2016-11-20T16:26:18.000Z","_content":"\n## 栈内存与堆内存\njs变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:\n\n```javascript\nconst name = '某某某';\nconst age = 22;\nconst hasGf = false;\nconst obj = {\n  test: 123,\n}\nconst anotherObj = obj;\n```\n\n它们在内存中的结构如图：\n\n![](/imgs/js变量的内存管理.jpg)\n\n* 栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间\n* 堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用\n\n由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:\n\n* 基本类型直接在栈内存中进行复制值\n* 引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象\n\n既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:\n\n```\n\nfunction test(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n + test(n - 1);\n}\ntest(10000); // 50005000\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:\n\n```\ntest(5)\n5 + test(4)\n5 + (4 + test(3))\n5 + (4 + (3 + test(2)))\n5 + (4 + (3 + (2 + test(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n\n正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:\n\n```\nfunction test(n, count) {\n  if (n === 0) {\n    return count;\n  }\n  return test(n - 1, count + n);\n}\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：\n```\nTemporarily Removed in Babel 6\nOnly explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.\n```\n\n\n那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:\n\n```\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction test(x, count) {\n    function recur(x, count) {\n        if (x > 0) {\n          return recur.bind(null, x - 1, count + x);\n        } else {\n          return count;\n        }\n    }\n    return trampoline(recur.bind(null, x, count));\n}\n\nconsole.log(test(100000, 0)); // 5000050000\n```\n\n\n## 内存泄漏\njavascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：\n\n1. 遍历所有可访问的对象。\n2. 回收已不可访问的对象。\n\n因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.\n\n\n#### 闭包拾遗\n通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:\n\n```\nfunction outerFn() {\n  var a = 0;\n  function innerFn() {\n    console.log(a++);\n  }\n  return innerFn;\n}\n\nvar fn = outerFn();\nfn(); // 0\nfn(); // 1\n```\n\n\n\n#### 在函数内创建全局变量\n若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:\n\n```\nfunction Test() {\n  hehe = 123;\n  this.a = 1;\n}\nTest();\nconsole.log(hehe, a); // 123, 1\n```\n\n#### 循环引用\n如果dom元素操作不当, 很容易造成非常规的内存占用:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  element.onclick = function () {\n    alert(element.id);\n  };\n}\n```\n\n由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  var id = element.id;\n  element.onclick = function () {\n    alert(id);\n  };\n  element = null;\n}\n```\n","source":"_posts/2016-11-21-js变量的内存管理.md","raw":"---\nlayout: post\ntitle: js变量作用域与垃圾回收\ndate: 2016/11/21 00:26:18\ntags: js\n---\n\n## 栈内存与堆内存\njs变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:\n\n```javascript\nconst name = '某某某';\nconst age = 22;\nconst hasGf = false;\nconst obj = {\n  test: 123,\n}\nconst anotherObj = obj;\n```\n\n它们在内存中的结构如图：\n\n![](/imgs/js变量的内存管理.jpg)\n\n* 栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间\n* 堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用\n\n由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:\n\n* 基本类型直接在栈内存中进行复制值\n* 引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象\n\n既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:\n\n```\n\nfunction test(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n + test(n - 1);\n}\ntest(10000); // 50005000\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:\n\n```\ntest(5)\n5 + test(4)\n5 + (4 + test(3))\n5 + (4 + (3 + test(2)))\n5 + (4 + (3 + (2 + test(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n\n正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:\n\n```\nfunction test(n, count) {\n  if (n === 0) {\n    return count;\n  }\n  return test(n - 1, count + n);\n}\ntest(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：\n```\nTemporarily Removed in Babel 6\nOnly explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.\n```\n\n\n那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:\n\n```\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction test(x, count) {\n    function recur(x, count) {\n        if (x > 0) {\n          return recur.bind(null, x - 1, count + x);\n        } else {\n          return count;\n        }\n    }\n    return trampoline(recur.bind(null, x, count));\n}\n\nconsole.log(test(100000, 0)); // 5000050000\n```\n\n\n## 内存泄漏\njavascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：\n\n1. 遍历所有可访问的对象。\n2. 回收已不可访问的对象。\n\n因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.\n\n\n#### 闭包拾遗\n通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:\n\n```\nfunction outerFn() {\n  var a = 0;\n  function innerFn() {\n    console.log(a++);\n  }\n  return innerFn;\n}\n\nvar fn = outerFn();\nfn(); // 0\nfn(); // 1\n```\n\n\n\n#### 在函数内创建全局变量\n若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:\n\n```\nfunction Test() {\n  hehe = 123;\n  this.a = 1;\n}\nTest();\nconsole.log(hehe, a); // 123, 1\n```\n\n#### 循环引用\n如果dom元素操作不当, 很容易造成非常规的内存占用:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  element.onclick = function () {\n    alert(element.id);\n  };\n}\n```\n\n由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:\n\n```\nfunction assignHandler () {\n  var element = document.getElementById('someElement');\n  var id = element.id;\n  element.onclick = function () {\n    alert(id);\n  };\n  element = null;\n}\n```\n","slug":"2016-11-21-js变量的内存管理","published":1,"updated":"2017-08-08T13:42:37.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugwv0000yqc352yjmc40","content":"<h2 id=\"栈内存与堆内存\"><a href=\"#栈内存与堆内存\" class=\"headerlink\" title=\"栈内存与堆内存\"></a>栈内存与堆内存</h2><p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'某某某'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">22</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> hasGf = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  test: <span class=\"number\">123</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> anotherObj = obj;</div></pre></td></tr></table></figure>\n<p>它们在内存中的结构如图：</p>\n<p><img src=\"/imgs/js变量的内存管理.jpg\" alt=\"\"></p>\n<ul>\n<li>栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间</li>\n<li>堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用</li>\n</ul>\n<p>由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:</p>\n<ul>\n<li>基本类型直接在栈内存中进行复制值</li>\n<li>引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象</li>\n</ul>\n<p>既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function test(n) &#123;</div><div class=\"line\">  if (n === 1) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return n + test(n - 1);</div><div class=\"line\">&#125;</div><div class=\"line\">test(10000); // 50005000</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(5)</div><div class=\"line\">5 + test(4)</div><div class=\"line\">5 + (4 + test(3))</div><div class=\"line\">5 + (4 + (3 + test(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + test(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure>\n<p>正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function test(n, count) &#123;</div><div class=\"line\">  if (n === 0) &#123;</div><div class=\"line\">    return count;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return test(n - 1, count + n);</div><div class=\"line\">&#125;</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Temporarily Removed in Babel 6</div><div class=\"line\">Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</div></pre></td></tr></table></figure></p>\n<p>那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function trampoline(f) &#123;</div><div class=\"line\">    while (f &amp;&amp; f instanceof Function) &#123;</div><div class=\"line\">        f = f();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return f;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function test(x, count) &#123;</div><div class=\"line\">    function recur(x, count) &#123;</div><div class=\"line\">        if (x &gt; 0) &#123;</div><div class=\"line\">          return recur.bind(null, x - 1, count + x);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">          return count;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return trampoline(recur.bind(null, x, count));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(test(100000, 0)); // 5000050000</div></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>javascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：</p>\n<ol>\n<li>遍历所有可访问的对象。</li>\n<li>回收已不可访问的对象。</li>\n</ol>\n<p>因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.</p>\n<h4 id=\"闭包拾遗\"><a href=\"#闭包拾遗\" class=\"headerlink\" title=\"闭包拾遗\"></a>闭包拾遗</h4><p>通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerFn() &#123;</div><div class=\"line\">  var a = 0;</div><div class=\"line\">  function innerFn() &#123;</div><div class=\"line\">    console.log(a++);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var fn = outerFn();</div><div class=\"line\">fn(); // 0</div><div class=\"line\">fn(); // 1</div></pre></td></tr></table></figure>\n<h4 id=\"在函数内创建全局变量\"><a href=\"#在函数内创建全局变量\" class=\"headerlink\" title=\"在函数内创建全局变量\"></a>在函数内创建全局变量</h4><p>若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test() &#123;</div><div class=\"line\">  hehe = 123;</div><div class=\"line\">  this.a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">Test();</div><div class=\"line\">console.log(hehe, a); // 123, 1</div></pre></td></tr></table></figure>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>如果dom元素操作不当, 很容易造成非常规的内存占用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(element.id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  var id = element.id;</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  element = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"栈内存与堆内存\"><a href=\"#栈内存与堆内存\" class=\"headerlink\" title=\"栈内存与堆内存\"></a>栈内存与堆内存</h2><p>js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'某某某'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">22</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> hasGf = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  test: <span class=\"number\">123</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> anotherObj = obj;</div></pre></td></tr></table></figure>\n<p>它们在内存中的结构如图：</p>\n<p><img src=\"/imgs/js变量的内存管理.jpg\" alt=\"\"></p>\n<ul>\n<li>栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间</li>\n<li>堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用</li>\n</ul>\n<p>由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:</p>\n<ul>\n<li>基本类型直接在栈内存中进行复制值</li>\n<li>引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象</li>\n</ul>\n<p>既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function test(n) &#123;</div><div class=\"line\">  if (n === 1) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return n + test(n - 1);</div><div class=\"line\">&#125;</div><div class=\"line\">test(10000); // 50005000</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(5)</div><div class=\"line\">5 + test(4)</div><div class=\"line\">5 + (4 + test(3))</div><div class=\"line\">5 + (4 + (3 + test(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + test(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure>\n<p>正由于每递归一次都会在内存中形成一个调用帧,于是就会形成栈溢出,我们可用尾递归对栈调用进行优化,尾递归的含义为:在函数尾部调用函数本身,因为只调用了自身,当前栈大多数局部变量都不需要进行保存,因此就不会出现栈溢出了,以下是用尾递归进行实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function test(n, count) &#123;</div><div class=\"line\">  if (n === 0) &#123;</div><div class=\"line\">    return count;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return test(n - 1, count + n);</div><div class=\"line\">&#125;</div><div class=\"line\">test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…)</div></pre></td></tr></table></figure>\n<p>上述还是会出现栈溢出，究其结果是因为es6没有进行尾递归优化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Temporarily Removed in Babel 6</div><div class=\"line\">Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</div></pre></td></tr></table></figure></p>\n<p>那么为了消除栈溢出,只能使用另一种方法了:蹦床(Trampolining), 蹦床函数会将函数的递归调用转换成循环:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function trampoline(f) &#123;</div><div class=\"line\">    while (f &amp;&amp; f instanceof Function) &#123;</div><div class=\"line\">        f = f();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return f;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function test(x, count) &#123;</div><div class=\"line\">    function recur(x, count) &#123;</div><div class=\"line\">        if (x &gt; 0) &#123;</div><div class=\"line\">          return recur.bind(null, x - 1, count + x);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">          return count;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return trampoline(recur.bind(null, x, count));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(test(100000, 0)); // 5000050000</div></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>javascript具有自动垃圾回收机制(GC),当变量所属的函数执行结束后,就会等待垃圾回收器对其内存进行释放,回收器主要有使用的是标记清楚策略,核心概念为：</p>\n<ol>\n<li>遍历所有可访问的对象。</li>\n<li>回收已不可访问的对象。</li>\n</ol>\n<p>因此我们应当特别小心那些造成作用域改变的对象或者没有留意到对象的引用,这样它们的内存就会得不到释放,常驻于内存影响性能.</p>\n<h4 id=\"闭包拾遗\"><a href=\"#闭包拾遗\" class=\"headerlink\" title=\"闭包拾遗\"></a>闭包拾遗</h4><p>通过闭包,内部函数可以访问外部函数的变量,要特别小心在闭包内引用了外部函数的变量后,将内部函数返回出去时, 由于内部函数依赖外部函数的变量,因此不会失去引用而被垃圾回收机制释放掉,直到指向内部函数的指针为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerFn() &#123;</div><div class=\"line\">  var a = 0;</div><div class=\"line\">  function innerFn() &#123;</div><div class=\"line\">    console.log(a++);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var fn = outerFn();</div><div class=\"line\">fn(); // 0</div><div class=\"line\">fn(); // 1</div></pre></td></tr></table></figure>\n<h4 id=\"在函数内创建全局变量\"><a href=\"#在函数内创建全局变量\" class=\"headerlink\" title=\"在函数内创建全局变量\"></a>在函数内创建全局变量</h4><p>若在方法内不带var或let等关键字访问变量,若变量不存在的画就会创建一个全局变量, 从而造成无法释放掉内存,也有可能是构造函数自身进行了调用,this就会指向全局对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Test() &#123;</div><div class=\"line\">  hehe = 123;</div><div class=\"line\">  this.a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">Test();</div><div class=\"line\">console.log(hehe, a); // 123, 1</div></pre></td></tr></table></figure>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>如果dom元素操作不当, 很容易造成非常规的内存占用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(element.id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于匿名函数引用了element, 因此element并不会被垃圾回收器回收,在代码中不要直接通过对象获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function assignHandler () &#123;</div><div class=\"line\">  var element = document.getElementById(&apos;someElement&apos;);</div><div class=\"line\">  var id = element.id;</div><div class=\"line\">  element.onclick = function () &#123;</div><div class=\"line\">    alert(id);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  element = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"js代理函数技巧","date":"2016-12-08T17:06:48.000Z","_content":"\n#### 简述\n有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？\n\n#### 示例\n假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：\n```\nfunction splice(arrs, start, length) {\n  arrs.splice(start, length);\n  return arrs;\n}\n\nconst arrs = [1,2,3];\nsplice(arrs, 1, 1); // 返回为：[1,3]\n```\n\n如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：\n\n```\nfunction splice(arrs, start, length) {\n  console.log(`索引位置：${start}, 长度${length}，元素为：${arrs.splice(start, length)}`);\n  return arrs;\n}\nconst arrs = [1,2,3];\nsplice(arrs, 1, 2); // 返回为: [1]\n// 索引位置：1, 长度2，元素为：2,3\n```\n\n上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:\n\n```\nconst arrs = [1,2,3];\nconst proxy = (...args) => {\n  const cutArrs = arrs.splice.apply(arrs, args);\n  console.log(`索引位置：${args[0]}, 长度${args[1]}，元素为：${cutArrs}`);\n}\nproxy(1, 2); // 索引位置：1, 长度2，元素为：2,3\nconsole.log(arrs); // [1]\n```\n\n#### 代理做了什么\n通过proxy(...)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。\n\n原理如下\n1. 将参数通过...args传入，它会变为一个args数组\n2. 通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身\n3. 在proxy方法体中进行进一步操作，构造完毕\n4. 按原顺序传入参数，进行执行。\n\n#### 实际用例\n在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：\n```\n// reset方法通过reduxForm包装来注入：\nexport default reduxForm({\n  form: 'xxx',\n})(xxx);\n\n// 清除按钮\n<button\n  type=\"button\"\n  className={style['invoice-btn']}\n  onClick={this.props.reset}\n>\n```\n\n我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：\n```\n<button\n  type=\"button\"\n  className={style['xxx']}\n  onClick={(...args) => {\n    reset.apply(this, args);\n    this.props.hideit();\n  }}\n>\n\n```\n\n#### 结尾\n谢谢阅读。\n","source":"_posts/2016-12-09-js代理函数技巧.md","raw":"---\nlayout: post\ntitle: js代理函数技巧\ndate: 2016/12/09 01:06:48\ntags: js\n---\n\n#### 简述\n有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？\n\n#### 示例\n假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：\n```\nfunction splice(arrs, start, length) {\n  arrs.splice(start, length);\n  return arrs;\n}\n\nconst arrs = [1,2,3];\nsplice(arrs, 1, 1); // 返回为：[1,3]\n```\n\n如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：\n\n```\nfunction splice(arrs, start, length) {\n  console.log(`索引位置：${start}, 长度${length}，元素为：${arrs.splice(start, length)}`);\n  return arrs;\n}\nconst arrs = [1,2,3];\nsplice(arrs, 1, 2); // 返回为: [1]\n// 索引位置：1, 长度2，元素为：2,3\n```\n\n上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:\n\n```\nconst arrs = [1,2,3];\nconst proxy = (...args) => {\n  const cutArrs = arrs.splice.apply(arrs, args);\n  console.log(`索引位置：${args[0]}, 长度${args[1]}，元素为：${cutArrs}`);\n}\nproxy(1, 2); // 索引位置：1, 长度2，元素为：2,3\nconsole.log(arrs); // [1]\n```\n\n#### 代理做了什么\n通过proxy(...)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。\n\n原理如下\n1. 将参数通过...args传入，它会变为一个args数组\n2. 通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身\n3. 在proxy方法体中进行进一步操作，构造完毕\n4. 按原顺序传入参数，进行执行。\n\n#### 实际用例\n在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：\n```\n// reset方法通过reduxForm包装来注入：\nexport default reduxForm({\n  form: 'xxx',\n})(xxx);\n\n// 清除按钮\n<button\n  type=\"button\"\n  className={style['invoice-btn']}\n  onClick={this.props.reset}\n>\n```\n\n我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：\n```\n<button\n  type=\"button\"\n  className={style['xxx']}\n  onClick={(...args) => {\n    reset.apply(this, args);\n    this.props.hideit();\n  }}\n>\n\n```\n\n#### 结尾\n谢谢阅读。\n","slug":"2016-12-09-js代理函数技巧","published":1,"updated":"2017-08-10T16:55:40.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugx00001yqc3tcjmo46i","content":"<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  arrs.splice(start, length);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 1); // 返回为：[1,3]</div></pre></td></tr></table></figure></p>\n<p>如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  console.log(`索引位置：$&#123;start&#125;, 长度$&#123;length&#125;，元素为：$&#123;arrs.splice(start, length)&#125;`);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 2); // 返回为: [1]</div><div class=\"line\">// 索引位置：1, 长度2，元素为：2,3</div></pre></td></tr></table></figure>\n<p>上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">const proxy = (...args) =&gt; &#123;</div><div class=\"line\">  const cutArrs = arrs.splice.apply(arrs, args);</div><div class=\"line\">  console.log(`索引位置：$&#123;args[0]&#125;, 长度$&#123;args[1]&#125;，元素为：$&#123;cutArrs&#125;`);</div><div class=\"line\">&#125;</div><div class=\"line\">proxy(1, 2); // 索引位置：1, 长度2，元素为：2,3</div><div class=\"line\">console.log(arrs); // [1]</div></pre></td></tr></table></figure>\n<h4 id=\"代理做了什么\"><a href=\"#代理做了什么\" class=\"headerlink\" title=\"代理做了什么\"></a>代理做了什么</h4><p>通过proxy(…)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。</p>\n<p>原理如下</p>\n<ol>\n<li>将参数通过…args传入，它会变为一个args数组</li>\n<li>通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身</li>\n<li>在proxy方法体中进行进一步操作，构造完毕</li>\n<li>按原顺序传入参数，进行执行。</li>\n</ol>\n<h4 id=\"实际用例\"><a href=\"#实际用例\" class=\"headerlink\" title=\"实际用例\"></a>实际用例</h4><p>在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// reset方法通过reduxForm包装来注入：</div><div class=\"line\">export default reduxForm(&#123;</div><div class=\"line\">  form: &apos;xxx&apos;,</div><div class=\"line\">&#125;)(xxx);</div><div class=\"line\"></div><div class=\"line\">// 清除按钮</div><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;invoice-btn&apos;]&#125;</div><div class=\"line\">  onClick=&#123;this.props.reset&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;xxx&apos;]&#125;</div><div class=\"line\">  onClick=&#123;(...args) =&gt; &#123;</div><div class=\"line\">    reset.apply(this, args);</div><div class=\"line\">    this.props.hideit();</div><div class=\"line\">  &#125;&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>谢谢阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  arrs.splice(start, length);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 1); // 返回为：[1,3]</div></pre></td></tr></table></figure></p>\n<p>如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function splice(arrs, start, length) &#123;</div><div class=\"line\">  console.log(`索引位置：$&#123;start&#125;, 长度$&#123;length&#125;，元素为：$&#123;arrs.splice(start, length)&#125;`);</div><div class=\"line\">  return arrs;</div><div class=\"line\">&#125;</div><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">splice(arrs, 1, 2); // 返回为: [1]</div><div class=\"line\">// 索引位置：1, 长度2，元素为：2,3</div></pre></td></tr></table></figure>\n<p>上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrs = [1,2,3];</div><div class=\"line\">const proxy = (...args) =&gt; &#123;</div><div class=\"line\">  const cutArrs = arrs.splice.apply(arrs, args);</div><div class=\"line\">  console.log(`索引位置：$&#123;args[0]&#125;, 长度$&#123;args[1]&#125;，元素为：$&#123;cutArrs&#125;`);</div><div class=\"line\">&#125;</div><div class=\"line\">proxy(1, 2); // 索引位置：1, 长度2，元素为：2,3</div><div class=\"line\">console.log(arrs); // [1]</div></pre></td></tr></table></figure>\n<h4 id=\"代理做了什么\"><a href=\"#代理做了什么\" class=\"headerlink\" title=\"代理做了什么\"></a>代理做了什么</h4><p>通过proxy(…)调用，可以保持原有函数的传参模式，在不修改函数的情况，对函数进行了功能扩展，意义在于我们给原有的函数加了一些功能，可使用传入的参数进行进一步操作，而不是修改函数体本身。</p>\n<p>原理如下</p>\n<ol>\n<li>将参数通过…args传入，它会变为一个args数组</li>\n<li>通过apply进行调用原函数，需注意的是，splice属于数组的作用域而不是当前的执行环境，因此apply的第一个参数不应该填this，直接填数组本身</li>\n<li>在proxy方法体中进行进一步操作，构造完毕</li>\n<li>按原顺序传入参数，进行执行。</li>\n</ol>\n<h4 id=\"实际用例\"><a href=\"#实际用例\" class=\"headerlink\" title=\"实际用例\"></a>实际用例</h4><p>在react项目中，我需要使用到redux-form传入的reset的操作，以此来清除表单，但是清除后我还需要改变state将表单收起，这样一个需求建立在一个这样的代码中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// reset方法通过reduxForm包装来注入：</div><div class=\"line\">export default reduxForm(&#123;</div><div class=\"line\">  form: &apos;xxx&apos;,</div><div class=\"line\">&#125;)(xxx);</div><div class=\"line\"></div><div class=\"line\">// 清除按钮</div><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;invoice-btn&apos;]&#125;</div><div class=\"line\">  onClick=&#123;this.props.reset&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>我们并不清除reset参数具体的传入顺序与值，仅仅是想追加一个操作，这在react中十分常见，因为很多方法都是从父组件传递进来的，我们一般直接绑定到指定子组件中即可，如果我们想追加操作，可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button</div><div class=\"line\">  type=&quot;button&quot;</div><div class=\"line\">  className=&#123;style[&apos;xxx&apos;]&#125;</div><div class=\"line\">  onClick=&#123;(...args) =&gt; &#123;</div><div class=\"line\">    reset.apply(this, args);</div><div class=\"line\">    this.props.hideit();</div><div class=\"line\">  &#125;&#125;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>谢谢阅读。</p>\n"},{"layout":"post","title":"js变量申明解析","date":"2016-12-09T09:30:24.000Z","_content":"\n\nvar属性有多种需要注意的特性：\n1. 无块级作用域\n2. 不带申明类型默认为全局变量\n3. 变量提升\n4. 运行重新申明变量\n\n#### 一、块级作用域\n\n首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：\n\n```\nfor (var i = 0; i < 100; i++){\n  // ...\n}\nconsole.log(i); // 输入100\n```\n\n若我们使用es6的let与const，就不会出现这种问题。\n\n#### 二、影响全局\n\n若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：\n\n```\nconst obj = {\n  a: 'a',\n  b: 'b',\n};\nwith (obj) {\n  console.log(a, b); // a b\n  b = 3;\n  c = 1;\n}\nconsole.log(obj.b, c); // 3 1\n```\n\n在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:\n\n```\nconst testobj = { foo: 'bar' };\nlet value;\nlet starttime;\nlet endtime;\nconst times = 1000000;\n\nstarttime = new Date().getTime();\nfor (let n = 0; n < times; n++) {\n  value = testobj.foo;\n}\nendtime = new Date().getTime();\nconsole.log(`正常赋值操作:${endtime - starttime}ms`);\n\nstarttime = new Date().getTime();\nwith (testobj) {\n  for (let n = 0; n < times; n++) {\n    value = foo;\n  }\n}\nendtime = new Date().getTime();\nconsole.log(`with赋值操作:${endtime - starttime}ms`);\n\n*****输出结果\n正常赋值操作:25ms\nwith赋值操作:415ms\n```\n\n造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。\n\n#### 三、变量提升\n大家肯定熟悉函数提升，可将函数定义放在调用代码之后：\n\n```\na(); // haha\nfunction a() {\n    console.log('haha');\n}\n```\n\n函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。\n\n在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:\n\n```\nconsole.log(a); // undefined\nvar a = '1';\n```\n\n其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。\n\n只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：`暂时性死区`。\n\n> 暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。\n\n这里有一个例子：\n\n```\nvar a = 1\nif(true){\n    console.log(a) //ReferenceError\n    let a = 2\n}\n```\n\n变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：\n\n```\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n#### 四、全局对象属性\n全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。\n\n```\n(function(){\n  a = 3\n})()\nvar b = 2\nconsole.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性\n\nlet c = 123\nconst d = 456\nconsole.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩\n```\n\n#### 总结\n在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。\n","source":"_posts/2016-12-09-js变量申明解析.md","raw":"---\nlayout: post\ntitle: js变量申明解析\ndate: 2016/12/09 17:30:24\ntags: js\n---\n\n\nvar属性有多种需要注意的特性：\n1. 无块级作用域\n2. 不带申明类型默认为全局变量\n3. 变量提升\n4. 运行重新申明变量\n\n#### 一、块级作用域\n\n首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：\n\n```\nfor (var i = 0; i < 100; i++){\n  // ...\n}\nconsole.log(i); // 输入100\n```\n\n若我们使用es6的let与const，就不会出现这种问题。\n\n#### 二、影响全局\n\n若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：\n\n```\nconst obj = {\n  a: 'a',\n  b: 'b',\n};\nwith (obj) {\n  console.log(a, b); // a b\n  b = 3;\n  c = 1;\n}\nconsole.log(obj.b, c); // 3 1\n```\n\n在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:\n\n```\nconst testobj = { foo: 'bar' };\nlet value;\nlet starttime;\nlet endtime;\nconst times = 1000000;\n\nstarttime = new Date().getTime();\nfor (let n = 0; n < times; n++) {\n  value = testobj.foo;\n}\nendtime = new Date().getTime();\nconsole.log(`正常赋值操作:${endtime - starttime}ms`);\n\nstarttime = new Date().getTime();\nwith (testobj) {\n  for (let n = 0; n < times; n++) {\n    value = foo;\n  }\n}\nendtime = new Date().getTime();\nconsole.log(`with赋值操作:${endtime - starttime}ms`);\n\n*****输出结果\n正常赋值操作:25ms\nwith赋值操作:415ms\n```\n\n造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。\n\n#### 三、变量提升\n大家肯定熟悉函数提升，可将函数定义放在调用代码之后：\n\n```\na(); // haha\nfunction a() {\n    console.log('haha');\n}\n```\n\n函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。\n\n在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:\n\n```\nconsole.log(a); // undefined\nvar a = '1';\n```\n\n其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。\n\n只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：`暂时性死区`。\n\n> 暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。\n\n这里有一个例子：\n\n```\nvar a = 1\nif(true){\n    console.log(a) //ReferenceError\n    let a = 2\n}\n```\n\n变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：\n\n```\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n#### 四、全局对象属性\n全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。\n\n```\n(function(){\n  a = 3\n})()\nvar b = 2\nconsole.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性\n\nlet c = 123\nconst d = 456\nconsole.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩\n```\n\n#### 总结\n在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。\n","slug":"2016-12-09-js变量申明解析","published":1,"updated":"2017-08-08T13:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugx80003yqc31kf95rbf","content":"<p>var属性有多种需要注意的特性：</p>\n<ol>\n<li>无块级作用域</li>\n<li>不带申明类型默认为全局变量</li>\n<li>变量提升</li>\n<li>运行重新申明变量</li>\n</ol>\n<h4 id=\"一、块级作用域\"><a href=\"#一、块级作用域\" class=\"headerlink\" title=\"一、块级作用域\"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; 100; i++)&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(i); // 输入100</div></pre></td></tr></table></figure>\n<p>若我们使用es6的let与const，就不会出现这种问题。</p>\n<h4 id=\"二、影响全局\"><a href=\"#二、影响全局\" class=\"headerlink\" title=\"二、影响全局\"></a>二、影响全局</h4><p>若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const obj = &#123;</div><div class=\"line\">  a: &apos;a&apos;,</div><div class=\"line\">  b: &apos;b&apos;,</div><div class=\"line\">&#125;;</div><div class=\"line\">with (obj) &#123;</div><div class=\"line\">  console.log(a, b); // a b</div><div class=\"line\">  b = 3;</div><div class=\"line\">  c = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(obj.b, c); // 3 1</div></pre></td></tr></table></figure>\n<p>在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">const testobj = &#123; foo: &apos;bar&apos; &#125;;</div><div class=\"line\">let value;</div><div class=\"line\">let starttime;</div><div class=\"line\">let endtime;</div><div class=\"line\">const times = 1000000;</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">  value = testobj.foo;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`正常赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">with (testobj) &#123;</div><div class=\"line\">  for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">    value = foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`with赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">*****输出结果</div><div class=\"line\">正常赋值操作:25ms</div><div class=\"line\">with赋值操作:415ms</div></pre></td></tr></table></figure>\n<p>造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。</p>\n<h4 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h4><p>大家肯定熟悉函数提升，可将函数定义放在调用代码之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a(); // haha</div><div class=\"line\">function a() &#123;</div><div class=\"line\">    console.log(&apos;haha&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。</p>\n<p>在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(a); // undefined</div><div class=\"line\">var a = &apos;1&apos;;</div></pre></td></tr></table></figure>\n<p>其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。</p>\n<p>只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：<code>暂时性死区</code>。</p>\n<blockquote>\n<p>暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。</p>\n</blockquote>\n<p>这里有一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1</div><div class=\"line\">if(true)&#123;</div><div class=\"line\">    console.log(a) //ReferenceError</div><div class=\"line\">    let a = 2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var tmp = new Date();</div><div class=\"line\"></div><div class=\"line\">function f() &#123;</div><div class=\"line\">  console.log(tmp);</div><div class=\"line\">  if (false) &#123;</div><div class=\"line\">    var tmp = &quot;hello world&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); // undefined</div></pre></td></tr></table></figure>\n<h4 id=\"四、全局对象属性\"><a href=\"#四、全局对象属性\" class=\"headerlink\" title=\"四、全局对象属性\"></a>四、全局对象属性</h4><p>全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  a = 3</div><div class=\"line\">&#125;)()</div><div class=\"line\">var b = 2</div><div class=\"line\">console.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性</div><div class=\"line\"></div><div class=\"line\">let c = 123</div><div class=\"line\">const d = 456</div><div class=\"line\">console.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩</div></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>var属性有多种需要注意的特性：</p>\n<ol>\n<li>无块级作用域</li>\n<li>不带申明类型默认为全局变量</li>\n<li>变量提升</li>\n<li>运行重新申明变量</li>\n</ol>\n<h4 id=\"一、块级作用域\"><a href=\"#一、块级作用域\" class=\"headerlink\" title=\"一、块级作用域\"></a>一、块级作用域</h4><p>首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; 100; i++)&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(i); // 输入100</div></pre></td></tr></table></figure>\n<p>若我们使用es6的let与const，就不会出现这种问题。</p>\n<h4 id=\"二、影响全局\"><a href=\"#二、影响全局\" class=\"headerlink\" title=\"二、影响全局\"></a>二、影响全局</h4><p>若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const obj = &#123;</div><div class=\"line\">  a: &apos;a&apos;,</div><div class=\"line\">  b: &apos;b&apos;,</div><div class=\"line\">&#125;;</div><div class=\"line\">with (obj) &#123;</div><div class=\"line\">  console.log(a, b); // a b</div><div class=\"line\">  b = 3;</div><div class=\"line\">  c = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(obj.b, c); // 3 1</div></pre></td></tr></table></figure>\n<p>在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">const testobj = &#123; foo: &apos;bar&apos; &#125;;</div><div class=\"line\">let value;</div><div class=\"line\">let starttime;</div><div class=\"line\">let endtime;</div><div class=\"line\">const times = 1000000;</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">  value = testobj.foo;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`正常赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">starttime = new Date().getTime();</div><div class=\"line\">with (testobj) &#123;</div><div class=\"line\">  for (let n = 0; n &lt; times; n++) &#123;</div><div class=\"line\">    value = foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">endtime = new Date().getTime();</div><div class=\"line\">console.log(`with赋值操作:$&#123;endtime - starttime&#125;ms`);</div><div class=\"line\"></div><div class=\"line\">*****输出结果</div><div class=\"line\">正常赋值操作:25ms</div><div class=\"line\">with赋值操作:415ms</div></pre></td></tr></table></figure>\n<p>造成的原因是因为,在with下进行访问变量默认都是从一个对象中进行访问, 这样比直接访问多一个层级,自然速度就慢下来了，而且with语句不利于编译器进行静态分析，以此我们在代码中不要使用with。</p>\n<h4 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h4><p>大家肯定熟悉函数提升，可将函数定义放在调用代码之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a(); // haha</div><div class=\"line\">function a() &#123;</div><div class=\"line\">    console.log(&apos;haha&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数之所以会提升，还是因为编译器做静态分析时，会优先找到函数申明，再进行语法分词与解释器识别。</p>\n<p>在js脚本内，可以在变量与申明式方法定义之前访问到其变量，值为undefined，这样的概念就叫做变量提升:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(a); // undefined</div><div class=\"line\">var a = &apos;1&apos;;</div></pre></td></tr></table></figure>\n<p>其实，这种提升只是为了设计和实现上更容易，并没什么优点，只不过新手应注意到这个细节。</p>\n<p>只有var变量存在变量提示，而let与const都不会存在变量提升，并且，它们会带来一个特性：<code>暂时性死区</code>。</p>\n<blockquote>\n<p>暂时性死区：有let存在的区域，它所申明的变量就会绑定这个区域，不再受外部作用于的影响,在块级作用域中let变量声明之前的区域都称谓它的死区。</p>\n</blockquote>\n<p>这里有一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1</div><div class=\"line\">if(true)&#123;</div><div class=\"line\">    console.log(a) //ReferenceError</div><div class=\"line\">    let a = 2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>变量提升还会造成一种问题，那就是内层变量会覆盖外层变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var tmp = new Date();</div><div class=\"line\"></div><div class=\"line\">function f() &#123;</div><div class=\"line\">  console.log(tmp);</div><div class=\"line\">  if (false) &#123;</div><div class=\"line\">    var tmp = &quot;hello world&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); // undefined</div></pre></td></tr></table></figure>\n<h4 id=\"四、全局对象属性\"><a href=\"#四、全局对象属性\" class=\"headerlink\" title=\"四、全局对象属性\"></a>四、全局对象属性</h4><p>全局对象是最顶层的属性，在浏览器中指window对象，在node中指代global对象。在以往的设计中，未申明的对象自动成为全局window的属性，这样就没法再编译时报出变量未申明的错误，而es6为了改变这一点，为了保持兼容性，var和function命令声明的全局变量依旧是全局变量；另一方面，let、const、class明亮声明的全局变量，不属于全局对象的属性。也就是说，全局变量将逐步与全局对象的属性脱钩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  a = 3</div><div class=\"line\">&#125;)()</div><div class=\"line\">var b = 2</div><div class=\"line\">console.log(window.a, window.b) //打印3,2，全局变量自动成为全局对象的属性</div><div class=\"line\"></div><div class=\"line\">let c = 123</div><div class=\"line\">const d = 456</div><div class=\"line\">console.log(window.c, window.d) //undefined*2, es6的属性将与全局对象脱钩</div></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在理解传统变量的基础下，应该多使用let、const等新的属性来申明变量，这是js语言的一种进化。</p>\n"},{"layout":"post","title":"git实用命令技巧","date":"2016-12-11T15:59:21.000Z","_content":"\n> 美需要规范。\n\n#### git pull --rebase\n从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：\n\n![](/imgs/git实用命令技巧-1.png)\n\n我们期望的分支图也许时这样的：\n\n![](/imgs/git实用命令技巧-2.png)\n\n只需要将git pull -> git pull --rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:\n```\n合并前：\n        D---E master\n      /\nA---B---C---F origin/master\n\nmerge合并：\n    D--------E  \n  /           \\\nA---B---C---F---G   master, origin/master\n\nrebase合并：\nA---B---C---F---D---E   master, origin/master\n```\n\n如果遇到冲突，请将冲突解决后执行: `git rebase --continue`。它也有两面性，至于谁好谁坏，慎用就行了。\n\n#### git commit --amend\n有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。\n\n#### 获取远程库的更新\n普通的工作流程一般是先folk整个工程到本地，再添加上游分支：\n```\ngit remote add upstream https://xxx.git\n```\n\n这样一来，我们就可以获取远程的更新到当前分支：\n```\ngit pull upstream master\n```\n\n若拉取本地不存在的分支，则可以使用这条命令：\n```\ngit checkout -b new_branch upstream/new_branch\n```\n\n#### 推送多个远程库\n用法：\n\n```\n$ vim ~/.git/config\n\n[remote \"upstream\"]\n        url = git@gitlab.main.com:project.git\n        url = git@github.main.com:project.git\n\n$ git push upstream\n```\n\n解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。\n","source":"_posts/2016-12-11-git实用命令技巧.md","raw":"---\nlayout: post\ntitle: git实用命令技巧\ndate: 2016/12/11 23:59:21\ntags: tricks\n---\n\n> 美需要规范。\n\n#### git pull --rebase\n从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：\n\n![](/imgs/git实用命令技巧-1.png)\n\n我们期望的分支图也许时这样的：\n\n![](/imgs/git实用命令技巧-2.png)\n\n只需要将git pull -> git pull --rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:\n```\n合并前：\n        D---E master\n      /\nA---B---C---F origin/master\n\nmerge合并：\n    D--------E  \n  /           \\\nA---B---C---F---G   master, origin/master\n\nrebase合并：\nA---B---C---F---D---E   master, origin/master\n```\n\n如果遇到冲突，请将冲突解决后执行: `git rebase --continue`。它也有两面性，至于谁好谁坏，慎用就行了。\n\n#### git commit --amend\n有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。\n\n#### 获取远程库的更新\n普通的工作流程一般是先folk整个工程到本地，再添加上游分支：\n```\ngit remote add upstream https://xxx.git\n```\n\n这样一来，我们就可以获取远程的更新到当前分支：\n```\ngit pull upstream master\n```\n\n若拉取本地不存在的分支，则可以使用这条命令：\n```\ngit checkout -b new_branch upstream/new_branch\n```\n\n#### 推送多个远程库\n用法：\n\n```\n$ vim ~/.git/config\n\n[remote \"upstream\"]\n        url = git@gitlab.main.com:project.git\n        url = git@github.main.com:project.git\n\n$ git push upstream\n```\n\n解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。\n","slug":"2016-12-11-git实用命令技巧","published":1,"updated":"2017-08-08T13:44:23.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugx90004yqc36m00xp34","content":"<blockquote>\n<p>美需要规范。</p>\n</blockquote>\n<h4 id=\"git-pull-–rebase\"><a href=\"#git-pull-–rebase\" class=\"headerlink\" title=\"git pull –rebase\"></a>git pull –rebase</h4><p>从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：</p>\n<p><img src=\"/imgs/git实用命令技巧-1.png\" alt=\"\"></p>\n<p>我们期望的分支图也许时这样的：</p>\n<p><img src=\"/imgs/git实用命令技巧-2.png\" alt=\"\"></p>\n<p>只需要将git pull -&gt; git pull –rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">合并前：</div><div class=\"line\">        D---E master</div><div class=\"line\">      /</div><div class=\"line\">A---B---C---F origin/master</div><div class=\"line\"></div><div class=\"line\">merge合并：</div><div class=\"line\">    D--------E  </div><div class=\"line\">  /           \\</div><div class=\"line\">A---B---C---F---G   master, origin/master</div><div class=\"line\"></div><div class=\"line\">rebase合并：</div><div class=\"line\">A---B---C---F---D---E   master, origin/master</div></pre></td></tr></table></figure></p>\n<p>如果遇到冲突，请将冲突解决后执行: <code>git rebase --continue</code>。它也有两面性，至于谁好谁坏，慎用就行了。</p>\n<h4 id=\"git-commit-–amend\"><a href=\"#git-commit-–amend\" class=\"headerlink\" title=\"git commit –amend\"></a>git commit –amend</h4><p>有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。</p>\n<h4 id=\"获取远程库的更新\"><a href=\"#获取远程库的更新\" class=\"headerlink\" title=\"获取远程库的更新\"></a>获取远程库的更新</h4><p>普通的工作流程一般是先folk整个工程到本地，再添加上游分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add upstream https://xxx.git</div></pre></td></tr></table></figure></p>\n<p>这样一来，我们就可以获取远程的更新到当前分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull upstream master</div></pre></td></tr></table></figure></p>\n<p>若拉取本地不存在的分支，则可以使用这条命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b new_branch upstream/new_branch</div></pre></td></tr></table></figure></p>\n<h4 id=\"推送多个远程库\"><a href=\"#推送多个远程库\" class=\"headerlink\" title=\"推送多个远程库\"></a>推送多个远程库</h4><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim ~/.git/config</div><div class=\"line\"></div><div class=\"line\">[remote &quot;upstream&quot;]</div><div class=\"line\">        url = git@gitlab.main.com:project.git</div><div class=\"line\">        url = git@github.main.com:project.git</div><div class=\"line\"></div><div class=\"line\">$ git push upstream</div></pre></td></tr></table></figure>\n<p>解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>美需要规范。</p>\n</blockquote>\n<h4 id=\"git-pull-–rebase\"><a href=\"#git-pull-–rebase\" class=\"headerlink\" title=\"git pull –rebase\"></a>git pull –rebase</h4><p>从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：</p>\n<p><img src=\"/imgs/git实用命令技巧-1.png\" alt=\"\"></p>\n<p>我们期望的分支图也许时这样的：</p>\n<p><img src=\"/imgs/git实用命令技巧-2.png\" alt=\"\"></p>\n<p>只需要将git pull -&gt; git pull –rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">合并前：</div><div class=\"line\">        D---E master</div><div class=\"line\">      /</div><div class=\"line\">A---B---C---F origin/master</div><div class=\"line\"></div><div class=\"line\">merge合并：</div><div class=\"line\">    D--------E  </div><div class=\"line\">  /           \\</div><div class=\"line\">A---B---C---F---G   master, origin/master</div><div class=\"line\"></div><div class=\"line\">rebase合并：</div><div class=\"line\">A---B---C---F---D---E   master, origin/master</div></pre></td></tr></table></figure></p>\n<p>如果遇到冲突，请将冲突解决后执行: <code>git rebase --continue</code>。它也有两面性，至于谁好谁坏，慎用就行了。</p>\n<h4 id=\"git-commit-–amend\"><a href=\"#git-commit-–amend\" class=\"headerlink\" title=\"git commit –amend\"></a>git commit –amend</h4><p>有时候我们生成commit信息后有点小的改动，并不希望新添加一个commit，而是将其追加到上一次提交内容中，这条命令就是为了做这件事情，它还可以更改之前的提交信息。</p>\n<h4 id=\"获取远程库的更新\"><a href=\"#获取远程库的更新\" class=\"headerlink\" title=\"获取远程库的更新\"></a>获取远程库的更新</h4><p>普通的工作流程一般是先folk整个工程到本地，再添加上游分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add upstream https://xxx.git</div></pre></td></tr></table></figure></p>\n<p>这样一来，我们就可以获取远程的更新到当前分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull upstream master</div></pre></td></tr></table></figure></p>\n<p>若拉取本地不存在的分支，则可以使用这条命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b new_branch upstream/new_branch</div></pre></td></tr></table></figure></p>\n<h4 id=\"推送多个远程库\"><a href=\"#推送多个远程库\" class=\"headerlink\" title=\"推送多个远程库\"></a>推送多个远程库</h4><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim ~/.git/config</div><div class=\"line\"></div><div class=\"line\">[remote &quot;upstream&quot;]</div><div class=\"line\">        url = git@gitlab.main.com:project.git</div><div class=\"line\">        url = git@github.main.com:project.git</div><div class=\"line\"></div><div class=\"line\">$ git push upstream</div></pre></td></tr></table></figure>\n<p>解释：通过编辑config文件，给远程库多添加一个url，那么再执行push操作时，就可以同时push两个库，如上github与gitlab仓库的项目都会更新。</p>\n"},{"layout":"post","title":"BOM对象的应用","date":"2016-12-18T12:24:59.000Z","_content":"\nBOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：\n+ 跳转到新的网址：`window.location.href = 'http://www.google.com';`\n+ 打开新的窗体：`window.open('http://www.google.com');`\n+ 刷新页面：`window.location.reload();`\n+ 后退：`window.history.back();`\n+ 前进：`window.history.forward();`\n\n#### 子窗体与父窗体对象的引用\n考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：\n\n```\nfunction dealOk() {\n  window.opener.location.reload();\n  window.close();\n}\n```\n\n若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：\n\n```\n\n// showPopup会返回window对象，原理是window.open()方法的调用\nconst childrenWindow = QC.Login.showPopup({\n  appId: APPID,\n  redirectURI: REDIRECT_URI,\n});\n\nconst timer = setInterval(() => {\n\n  // 查看窗体是否被关闭\n  if (childrenWindow.closed) {\n    clearInterval(timer); // 清除轮询\n    window.location.reload(); // 刷新页面\n  }\n},500);\n```\n\n#### a标签阻止其跳转\n将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行`;`直接返回undefined：\n\n+ `<a href=\"javascript:void(0);\">点击不会进行跳转</a>`\n+ `<a href=\"javascript:;\">点击不会进行跳转</a>`\n","source":"_posts/2016-12-18-BOM对象的应用.md","raw":"---\nlayout: post\ntitle: BOM对象的应用\ndate: 2016/12/18 20:24:59\ntags: js\n---\n\nBOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：\n+ 跳转到新的网址：`window.location.href = 'http://www.google.com';`\n+ 打开新的窗体：`window.open('http://www.google.com');`\n+ 刷新页面：`window.location.reload();`\n+ 后退：`window.history.back();`\n+ 前进：`window.history.forward();`\n\n#### 子窗体与父窗体对象的引用\n考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：\n\n```\nfunction dealOk() {\n  window.opener.location.reload();\n  window.close();\n}\n```\n\n若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：\n\n```\n\n// showPopup会返回window对象，原理是window.open()方法的调用\nconst childrenWindow = QC.Login.showPopup({\n  appId: APPID,\n  redirectURI: REDIRECT_URI,\n});\n\nconst timer = setInterval(() => {\n\n  // 查看窗体是否被关闭\n  if (childrenWindow.closed) {\n    clearInterval(timer); // 清除轮询\n    window.location.reload(); // 刷新页面\n  }\n},500);\n```\n\n#### a标签阻止其跳转\n将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行`;`直接返回undefined：\n\n+ `<a href=\"javascript:void(0);\">点击不会进行跳转</a>`\n+ `<a href=\"javascript:;\">点击不会进行跳转</a>`\n","slug":"2016-12-18-BOM对象的应用","published":1,"updated":"2017-08-08T13:44:28.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxd0005yqc3j1da9s4j","content":"<p>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：</p>\n<ul>\n<li>跳转到新的网址：<code>window.location.href = &#39;http://www.google.com&#39;;</code></li>\n<li>打开新的窗体：<code>window.open(&#39;http://www.google.com&#39;);</code></li>\n<li>刷新页面：<code>window.location.reload();</code></li>\n<li>后退：<code>window.history.back();</code></li>\n<li>前进：<code>window.history.forward();</code></li>\n</ul>\n<h4 id=\"子窗体与父窗体对象的引用\"><a href=\"#子窗体与父窗体对象的引用\" class=\"headerlink\" title=\"子窗体与父窗体对象的引用\"></a>子窗体与父窗体对象的引用</h4><p>考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function dealOk() &#123;</div><div class=\"line\">  window.opener.location.reload();</div><div class=\"line\">  window.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// showPopup会返回window对象，原理是window.open()方法的调用</div><div class=\"line\">const childrenWindow = QC.Login.showPopup(&#123;</div><div class=\"line\">  appId: APPID,</div><div class=\"line\">  redirectURI: REDIRECT_URI,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">const timer = setInterval(() =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">  // 查看窗体是否被关闭</div><div class=\"line\">  if (childrenWindow.closed) &#123;</div><div class=\"line\">    clearInterval(timer); // 清除轮询</div><div class=\"line\">    window.location.reload(); // 刷新页面</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,500);</div></pre></td></tr></table></figure>\n<h4 id=\"a标签阻止其跳转\"><a href=\"#a标签阻止其跳转\" class=\"headerlink\" title=\"a标签阻止其跳转\"></a>a标签阻止其跳转</h4><p>将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行<code>;</code>直接返回undefined：</p>\n<ul>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n<li><code>&lt;a href=&quot;javascript:;&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如：</p>\n<ul>\n<li>跳转到新的网址：<code>window.location.href = &#39;http://www.google.com&#39;;</code></li>\n<li>打开新的窗体：<code>window.open(&#39;http://www.google.com&#39;);</code></li>\n<li>刷新页面：<code>window.location.reload();</code></li>\n<li>后退：<code>window.history.back();</code></li>\n<li>前进：<code>window.history.forward();</code></li>\n</ul>\n<h4 id=\"子窗体与父窗体对象的引用\"><a href=\"#子窗体与父窗体对象的引用\" class=\"headerlink\" title=\"子窗体与父窗体对象的引用\"></a>子窗体与父窗体对象的引用</h4><p>考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function dealOk() &#123;</div><div class=\"line\">  window.opener.location.reload();</div><div class=\"line\">  window.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// showPopup会返回window对象，原理是window.open()方法的调用</div><div class=\"line\">const childrenWindow = QC.Login.showPopup(&#123;</div><div class=\"line\">  appId: APPID,</div><div class=\"line\">  redirectURI: REDIRECT_URI,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">const timer = setInterval(() =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">  // 查看窗体是否被关闭</div><div class=\"line\">  if (childrenWindow.closed) &#123;</div><div class=\"line\">    clearInterval(timer); // 清除轮询</div><div class=\"line\">    window.location.reload(); // 刷新页面</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,500);</div></pre></td></tr></table></figure>\n<h4 id=\"a标签阻止其跳转\"><a href=\"#a标签阻止其跳转\" class=\"headerlink\" title=\"a标签阻止其跳转\"></a>a标签阻止其跳转</h4><p>将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行<code>;</code>直接返回undefined：</p>\n<ul>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n<li><code>&lt;a href=&quot;javascript:;&quot;&gt;点击不会进行跳转&lt;/a&gt;</code></li>\n</ul>\n"},{"layout":"post","title":"nodejs中exports与module.exports的区别","date":"2016-12-25T15:52:57.000Z","_content":"\n在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。\n\n### require()的返回值\nrequire()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：\n\ntest.js:\n\n```\nmodule.exports = function(){\n    console.log('I\\'m module.exports')\n}\nexports = function(){\n    console.log('I\\'m exports')\n}\n```\n\n通过`var a = require('./test')()`即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。\n\n### exports是module.exports的一个指针\n假设有两个变量，`var a={name:'name1}, var b = a;`，b指向a的内存区域，如果执行`b.name='name2'`，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。\n\n可如果我们执行`a = {}`或者`b = {}`之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：\n1. module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。\n2. exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。\n3. exports.xxx与module.exports.xxx等价且可以共同存在。\n","source":"_posts/2016-12-25-nodejs中exports与module-exports的区别.md","raw":"---\nlayout: post\ntitle: nodejs中exports与module.exports的区别\ndate: 2016/12/25 23:52:57\ntags: nodejs\n---\n\n在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。\n\n### require()的返回值\nrequire()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：\n\ntest.js:\n\n```\nmodule.exports = function(){\n    console.log('I\\'m module.exports')\n}\nexports = function(){\n    console.log('I\\'m exports')\n}\n```\n\n通过`var a = require('./test')()`即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。\n\n### exports是module.exports的一个指针\n假设有两个变量，`var a={name:'name1}, var b = a;`，b指向a的内存区域，如果执行`b.name='name2'`，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。\n\n可如果我们执行`a = {}`或者`b = {}`之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：\n1. module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。\n2. exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。\n3. exports.xxx与module.exports.xxx等价且可以共同存在。\n","slug":"2016-12-25-nodejs中exports与module-exports的区别","published":1,"updated":"2017-08-08T13:44:33.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxi0008yqc3ahcmdtyu","content":"<p>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。</p>\n<h3 id=\"require-的返回值\"><a href=\"#require-的返回值\" class=\"headerlink\" title=\"require()的返回值\"></a>require()的返回值</h3><p>require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：</p>\n<p>test.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m module.exports&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m exports&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>var a = require(&#39;./test&#39;)()</code>即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。</p>\n<h3 id=\"exports是module-exports的一个指针\"><a href=\"#exports是module-exports的一个指针\" class=\"headerlink\" title=\"exports是module.exports的一个指针\"></a>exports是module.exports的一个指针</h3><p>假设有两个变量，<code>var a={name:&#39;name1}, var b = a;</code>，b指向a的内存区域，如果执行<code>b.name=&#39;name2&#39;</code>，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。</p>\n<p>可如果我们执行<code>a = {}</code>或者<code>b = {}</code>之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：</p>\n<ol>\n<li>module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。</li>\n<li>exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。</li>\n<li>exports.xxx与module.exports.xxx等价且可以共同存在。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。</p>\n<h3 id=\"require-的返回值\"><a href=\"#require-的返回值\" class=\"headerlink\" title=\"require()的返回值\"></a>require()的返回值</h3><p>require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：</p>\n<p>test.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m module.exports&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">exports = function()&#123;</div><div class=\"line\">    console.log(&apos;I\\&apos;m exports&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>var a = require(&#39;./test&#39;)()</code>即可看到打印的函数为module.exports，因此可以确定exports是module.exports的一个指针，不清楚指针的具体内容的接着往下看。</p>\n<h3 id=\"exports是module-exports的一个指针\"><a href=\"#exports是module-exports的一个指针\" class=\"headerlink\" title=\"exports是module.exports的一个指针\"></a>exports是module.exports的一个指针</h3><p>假设有两个变量，<code>var a={name:&#39;name1}, var b = a;</code>，b指向a的内存区域，如果执行<code>b.name=&#39;name2&#39;</code>，我们通过打印a.name可以看到其值也为name2，这就说明两个变量共同拥有一块内存区域，并且可以共同对区域进行修改。</p>\n<p>可如果我们执行<code>a = {}</code>或者<code>b = {}</code>之后，两个变量就各自管理自己的内存空间了，不再有关联，所以在nodejs中两者一共有几种用法：</p>\n<ol>\n<li>module.exports存在的话，exports或是exports.xxx就会失效，因此此刻两者已经不是管理共同的内存区域。</li>\n<li>exports只能通过exports.xxx这种形式进行使用，否则exports={}会指向新的内存区域，不能被require()加载。</li>\n<li>exports.xxx与module.exports.xxx等价且可以共同存在。</li>\n</ol>\n"},{"layout":"post","title":"python变量作用域","date":"2016-12-25T15:43:05.000Z","_content":"\nclass比作整个屋子，def为卧室，class外面的部分就是小区环境。\n\n#### 首先测试房子(class)与公共设施变量(globals)之间的关系\n\n```\n# encoding: utf-8\n\nPUBLIC_FACILITIES = u\"公共厕所\"\n\nclass House():\n    print PUBLIC_FACILITIES\n    PUBLIC_FACILITIES = '改造'\n\nif __name__ == '__main__':\n    test = House()\n    print PUBLIC_FACILITIES\n\n```\n\n测试结果：\n\n```\n公共厕所\n公共厕所\n\n***Repl Closed***\n```\n\n房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。\n\n#### 测试房子(class)与房间(def)的关系\n\n```\n# encoding: utf-8\n\nclass House():\n    SOFA = u'真皮沙发'\n    def room(self):\n        # print SOFA # 无法直接访问外部变量，取消注释会报错\n        print self.SOFA\n        self.SOFA = '布质沙发'\n\n\nif __name__ == '__main__':\n    test = House()\n    test.room()\n    print test.SOFA, House.SOFA\n```\n\n测试结果：\n\n```\n真皮沙发\n布质沙发 真皮沙发\n\n***Repl Closed***\n```\n\n大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。\n\n#### 总结\n用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明`global variable`， 访问类变量要接上类名，如`class_name.variable`, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。\n","source":"_posts/2016-12-25python变量作用域.md","raw":"---\nlayout: post\ntitle: python变量作用域\ndate: 2016/12/25 23:43:05\ntags: python\n---\n\nclass比作整个屋子，def为卧室，class外面的部分就是小区环境。\n\n#### 首先测试房子(class)与公共设施变量(globals)之间的关系\n\n```\n# encoding: utf-8\n\nPUBLIC_FACILITIES = u\"公共厕所\"\n\nclass House():\n    print PUBLIC_FACILITIES\n    PUBLIC_FACILITIES = '改造'\n\nif __name__ == '__main__':\n    test = House()\n    print PUBLIC_FACILITIES\n\n```\n\n测试结果：\n\n```\n公共厕所\n公共厕所\n\n***Repl Closed***\n```\n\n房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。\n\n#### 测试房子(class)与房间(def)的关系\n\n```\n# encoding: utf-8\n\nclass House():\n    SOFA = u'真皮沙发'\n    def room(self):\n        # print SOFA # 无法直接访问外部变量，取消注释会报错\n        print self.SOFA\n        self.SOFA = '布质沙发'\n\n\nif __name__ == '__main__':\n    test = House()\n    test.room()\n    print test.SOFA, House.SOFA\n```\n\n测试结果：\n\n```\n真皮沙发\n布质沙发 真皮沙发\n\n***Repl Closed***\n```\n\n大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。\n\n#### 总结\n用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明`global variable`， 访问类变量要接上类名，如`class_name.variable`, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。\n","slug":"2016-12-25python变量作用域","published":1,"updated":"2017-08-08T13:44:42.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxj000ayqc3x03yv12k","content":"<p>class比作整个屋子，def为卧室，class外面的部分就是小区环境。</p>\n<h4 id=\"首先测试房子-class-与公共设施变量-globals-之间的关系\"><a href=\"#首先测试房子-class-与公共设施变量-globals-之间的关系\" class=\"headerlink\" title=\"首先测试房子(class)与公共设施变量(globals)之间的关系\"></a>首先测试房子(class)与公共设施变量(globals)之间的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">PUBLIC_FACILITIES = u&quot;公共厕所&quot;</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    print PUBLIC_FACILITIES</div><div class=\"line\">    PUBLIC_FACILITIES = &apos;改造&apos;</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    print PUBLIC_FACILITIES</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">公共厕所</div><div class=\"line\">公共厕所</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。</p>\n<h4 id=\"测试房子-class-与房间-def-的关系\"><a href=\"#测试房子-class-与房间-def-的关系\" class=\"headerlink\" title=\"测试房子(class)与房间(def)的关系\"></a>测试房子(class)与房间(def)的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    SOFA = u&apos;真皮沙发&apos;</div><div class=\"line\">    def room(self):</div><div class=\"line\">        # print SOFA # 无法直接访问外部变量，取消注释会报错</div><div class=\"line\">        print self.SOFA</div><div class=\"line\">        self.SOFA = &apos;布质沙发&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    test.room()</div><div class=\"line\">    print test.SOFA, House.SOFA</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">真皮沙发</div><div class=\"line\">布质沙发 真皮沙发</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明<code>global variable</code>， 访问类变量要接上类名，如<code>class_name.variable</code>, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>class比作整个屋子，def为卧室，class外面的部分就是小区环境。</p>\n<h4 id=\"首先测试房子-class-与公共设施变量-globals-之间的关系\"><a href=\"#首先测试房子-class-与公共设施变量-globals-之间的关系\" class=\"headerlink\" title=\"首先测试房子(class)与公共设施变量(globals)之间的关系\"></a>首先测试房子(class)与公共设施变量(globals)之间的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">PUBLIC_FACILITIES = u&quot;公共厕所&quot;</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    print PUBLIC_FACILITIES</div><div class=\"line\">    PUBLIC_FACILITIES = &apos;改造&apos;</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    print PUBLIC_FACILITIES</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">公共厕所</div><div class=\"line\">公共厕所</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>房屋的拥有者可以使用小区内的公共设施。由此可知class内部可以访问外部的变量，但不能进行修改，在class中执行改造命令的效果就是新建了一个类局部变量变量，在访问域中覆盖了全局变量的访问域。</p>\n<h4 id=\"测试房子-class-与房间-def-的关系\"><a href=\"#测试房子-class-与房间-def-的关系\" class=\"headerlink\" title=\"测试房子(class)与房间(def)的关系\"></a>测试房子(class)与房间(def)的关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># encoding: utf-8</div><div class=\"line\"></div><div class=\"line\">class House():</div><div class=\"line\">    SOFA = u&apos;真皮沙发&apos;</div><div class=\"line\">    def room(self):</div><div class=\"line\">        # print SOFA # 无法直接访问外部变量，取消注释会报错</div><div class=\"line\">        print self.SOFA</div><div class=\"line\">        self.SOFA = &apos;布质沙发&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    test = House()</div><div class=\"line\">    test.room()</div><div class=\"line\">    print test.SOFA, House.SOFA</div></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">真皮沙发</div><div class=\"line\">布质沙发 真皮沙发</div><div class=\"line\"></div><div class=\"line\">***Repl Closed***</div></pre></td></tr></table></figure>\n<p>大家可以理解这样一个现象：无法将客厅的沙发放到卧室(卧室太小)，只能重新订制一个沙发，或是在客厅里去使用。当def方法中不存在与class类相同名称的变量时，def方法体中可以通过self访问到class的类变量， 但是当执行self.SOFA = Something时，新建了一个变量实例变量，并没有修改到class中的类变量， 而变量的搜索时先从局部变量进行查找，如果没有找到再查找全局变量，所有说局部变量优先访问到。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>用python写class时务必区分类变量、实例变量、全局变量，  访问全局变量须申明<code>global variable</code>， 访问类变量要接上类名，如<code>class_name.variable</code>, 还需要注意的时while、for、try语句并不具有独立的命名空间，这与java的规则是不一样的。</p>\n"},{"layout":"post","title":"几个简单的排序-js描述","date":"2016-12-26T07:02:51.000Z","_content":"排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。\n\n\n## 冒泡\n冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-1.jpg)\n\n此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。\n\n#### 代码\n\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if ( arrs[j] > arrs[j + 1]) {\n        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];\n      }\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 选择排序\n选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。\n\n#### 原理\n![选择排序](/imgs/冒泡、选择与插入排序-2.jpg)\n\n如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  let index;\n  for (let i = 0; i < len - 1; i++) {\n    index = i;\n    for (let j = i; j < len; j++) {\n      if (arrs[index] < arrs[j]) {\n        index = j;\n      }\n    }\n    if (i !== index) {\n      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：9,6,4,3,2\n耗时：18ms\n```\n\n## 插入\n插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-3.jpg)\n\n想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7>5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 1; i < len; i++) {\n    let j = i - 1;\n    const index = arrs[i];\n    while (j >= 0 && arrs[j] > index) {\n      arrs[j + 1] = arrs[j--];\n    }\n    arrs[j + 1] = index;\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 快排\n快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。\n\n#### 原理\n1. 选取数组中最左边的数作为基准。\n2. 分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。\n3. 对左右区间重复第二步，直到各区间只有一个数。\n\n#### 代码\n```\nfunction sort(arrs, left, right) {\n  if (left > right) return;\n  const len = arrs.length;\n  const key = arrs[left];\n  let low = left;\n  let high = right;\n  while (low < high) {\n    while (low < high && arrs[high] > key) {\n      high--;\n    }\n    arrs[low] = arrs[high];\n    while (low < high && arrs[low] < key) {\n      low++;\n    }\n    arrs[high] = arrs[low];\n  }\n  arrs[low] = key;\n  sort(arrs, left, low - 1);\n  sort(arrs, low + 1, right);\n}\n\n输入：[3,6,9,4,2],0,4\n输出：[2,3,4,6,9],0,4\n耗时：15ms\n```\n","source":"_posts/2016-12-26-冒泡、选择与插入排序.markdown","raw":"---\nlayout: post\ntitle: 几个简单的排序-js描述\ndate: 2016/12/26 15:02:51\ntags: js\n---\n排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。\n\n\n## 冒泡\n冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-1.jpg)\n\n此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。\n\n#### 代码\n\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if ( arrs[j] > arrs[j + 1]) {\n        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];\n      }\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 选择排序\n选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。\n\n#### 原理\n![选择排序](/imgs/冒泡、选择与插入排序-2.jpg)\n\n如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  let index;\n  for (let i = 0; i < len - 1; i++) {\n    index = i;\n    for (let j = i; j < len; j++) {\n      if (arrs[index] < arrs[j]) {\n        index = j;\n      }\n    }\n    if (i !== index) {\n      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];\n    }\n  }\n}\n\n输入：3,6,9,4,2\n输出：9,6,4,3,2\n耗时：18ms\n```\n\n## 插入\n插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。\n\n#### 原理\n\n![](/imgs/冒泡、选择与插入排序-3.jpg)\n\n想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7>5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。\n\n#### 代码\n```\nfunction sort(arrs) {\n  const len = arrs.length;\n  for (let i = 1; i < len; i++) {\n    let j = i - 1;\n    const index = arrs[i];\n    while (j >= 0 && arrs[j] > index) {\n      arrs[j + 1] = arrs[j--];\n    }\n    arrs[j + 1] = index;\n  }\n}\n\n输入：3,6,9,4,2\n输出：2,3,4,6,9\n耗时：18ms\n```\n\n## 快排\n快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。\n\n#### 原理\n1. 选取数组中最左边的数作为基准。\n2. 分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。\n3. 对左右区间重复第二步，直到各区间只有一个数。\n\n#### 代码\n```\nfunction sort(arrs, left, right) {\n  if (left > right) return;\n  const len = arrs.length;\n  const key = arrs[left];\n  let low = left;\n  let high = right;\n  while (low < high) {\n    while (low < high && arrs[high] > key) {\n      high--;\n    }\n    arrs[low] = arrs[high];\n    while (low < high && arrs[low] < key) {\n      low++;\n    }\n    arrs[high] = arrs[low];\n  }\n  arrs[low] = key;\n  sort(arrs, left, low - 1);\n  sort(arrs, low + 1, right);\n}\n\n输入：[3,6,9,4,2],0,4\n输出：[2,3,4,6,9],0,4\n耗时：15ms\n```\n","slug":"2016-12-26-冒泡、选择与插入排序","published":1,"updated":"2017-08-08T13:44:48.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxr000dyqc3kmfva21l","content":"<p>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。</p>\n<h2 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h2><p>冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-1.jpg\" alt=\"\"></p>\n<p>此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class=\"line\">      if ( arrs[j] &gt; arrs[j + 1]) &#123;</div><div class=\"line\">        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。</p>\n<h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-2.jpg\" alt=\"选择排序\"></p>\n<p>如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  let index;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    index = i;</div><div class=\"line\">    for (let j = i; j &lt; len; j++) &#123;</div><div class=\"line\">      if (arrs[index] &lt; arrs[j]) &#123;</div><div class=\"line\">        index = j;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (i !== index) &#123;</div><div class=\"line\">      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：9,6,4,3,2</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。</p>\n<h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-3.jpg\" alt=\"\"></p>\n<p>想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7&gt;5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 1; i &lt; len; i++) &#123;</div><div class=\"line\">    let j = i - 1;</div><div class=\"line\">    const index = arrs[i];</div><div class=\"line\">    while (j &gt;= 0 &amp;&amp; arrs[j] &gt; index) &#123;</div><div class=\"line\">      arrs[j + 1] = arrs[j--];</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[j + 1] = index;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h2><p>快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。</p>\n<h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>选取数组中最左边的数作为基准。</li>\n<li>分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。</li>\n<li>对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs, left, right) &#123;</div><div class=\"line\">  if (left &gt; right) return;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  const key = arrs[left];</div><div class=\"line\">  let low = left;</div><div class=\"line\">  let high = right;</div><div class=\"line\">  while (low &lt; high) &#123;</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[high] &gt; key) &#123;</div><div class=\"line\">      high--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[low] = arrs[high];</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[low] &lt; key) &#123;</div><div class=\"line\">      low++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[high] = arrs[low];</div><div class=\"line\">  &#125;</div><div class=\"line\">  arrs[low] = key;</div><div class=\"line\">  sort(arrs, left, low - 1);</div><div class=\"line\">  sort(arrs, low + 1, right);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：[3,6,9,4,2],0,4</div><div class=\"line\">输出：[2,3,4,6,9],0,4</div><div class=\"line\">耗时：15ms</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。</p>\n<h2 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h2><p>冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-1.jpg\" alt=\"\"></p>\n<p>此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class=\"line\">      if ( arrs[j] &gt; arrs[j + 1]) &#123;</div><div class=\"line\">        [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。</p>\n<h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-2.jpg\" alt=\"选择排序\"></p>\n<p>如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  let index;</div><div class=\"line\">  for (let i = 0; i &lt; len - 1; i++) &#123;</div><div class=\"line\">    index = i;</div><div class=\"line\">    for (let j = i; j &lt; len; j++) &#123;</div><div class=\"line\">      if (arrs[index] &lt; arrs[j]) &#123;</div><div class=\"line\">        index = j;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (i !== index) &#123;</div><div class=\"line\">      [arrs[i], arrs[index]] = [arrs[index], arrs[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：9,6,4,3,2</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>插入排序即将一个数插入到一个已经有序的数字序列中，是一个稳定的排序方法，平均情况稍微比选择排序快。</p>\n<h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"/imgs/冒泡、选择与插入排序-3.jpg\" alt=\"\"></p>\n<p>想想一下你手中有4张手牌2、4、5、10，当你抽到1张7后，与10进行比较，比10小，往右挪10，与5进行比较，7&gt;5，因此将牌放于次空隙中。而插入排序就是手牌从2张到任意张手牌进行此抽排方式的过程的抽象。</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs) &#123;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  for (let i = 1; i &lt; len; i++) &#123;</div><div class=\"line\">    let j = i - 1;</div><div class=\"line\">    const index = arrs[i];</div><div class=\"line\">    while (j &gt;= 0 &amp;&amp; arrs[j] &gt; index) &#123;</div><div class=\"line\">      arrs[j + 1] = arrs[j--];</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[j + 1] = index;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：3,6,9,4,2</div><div class=\"line\">输出：2,3,4,6,9</div><div class=\"line\">耗时：18ms</div></pre></td></tr></table></figure>\n<h2 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h2><p>快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。它采用了分治法的思想，整个排序过程递归进行。</p>\n<h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>选取数组中最左边的数作为基准。</li>\n<li>分区过程，将比这个数大的放到它的右边，小于它的数放到它的左边。</li>\n<li>对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sort(arrs, left, right) &#123;</div><div class=\"line\">  if (left &gt; right) return;</div><div class=\"line\">  const len = arrs.length;</div><div class=\"line\">  const key = arrs[left];</div><div class=\"line\">  let low = left;</div><div class=\"line\">  let high = right;</div><div class=\"line\">  while (low &lt; high) &#123;</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[high] &gt; key) &#123;</div><div class=\"line\">      high--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[low] = arrs[high];</div><div class=\"line\">    while (low &lt; high &amp;&amp; arrs[low] &lt; key) &#123;</div><div class=\"line\">      low++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arrs[high] = arrs[low];</div><div class=\"line\">  &#125;</div><div class=\"line\">  arrs[low] = key;</div><div class=\"line\">  sort(arrs, left, low - 1);</div><div class=\"line\">  sort(arrs, low + 1, right);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输入：[3,6,9,4,2],0,4</div><div class=\"line\">输出：[2,3,4,6,9],0,4</div><div class=\"line\">耗时：15ms</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"python求质数的几种方法","date":"2016-12-25T16:02:23.000Z","_content":"\n今天偶然在博客上上看到有人提[求质素的几种境界](http://blog.csdn.net/program_think/article/details/7032600/),在此用python进行实现代码,并进行简单的说明.\n\n我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.\n\n### 境界1\n我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取`2~N/2`.\n代码如下:\n\n```\ndef f1(num):\n    # 2也是质数,之后程序从3开始判断\n    count = 1\n    for i in range(3, num):\n        b = True\n        for j in range(2, i/2 + 1):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时35.1589805796秒, 个数9592\n```\n\n### 境界2\n我们可以从j的范围再进行优化一下,最优的范围是`2~sqrt(N)`,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:\n\n```\ndef f1(num):\n    count = 1\n    # 优化点1:偶数不做判断\n    for i in range(3, num, 2):\n        b = True\n        sq = int(math.sqrt(i)) + 1\n        # 优化点2:缩小试除范围\n        for j in range(2, sq):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时0.264536051872秒, 个数9592\n```\n\n### 境界3\n是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.\n\n细想一下, 比如判断101是否为质数,`sqrt(101)`为10, 那我们就要依次用这个数去除以`2, 3, 5, 7, 9`,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的**质数**即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:\n\n```\ndef f2(num):\n    arrs = [2]\n    count = 1\n    # 质数数组中的索引\n    stop = 0\n    for i in range(3, num):\n        k = int(math.sqrt(i))\n        while stop < count and arrs[stop] <= k:\n            stop += 1\n        # 整除计数\n        j = 0\n        for k in range(stop):\n            if i % arrs[j] == 0:\n                break\n            j += 1\n        # 判定为质数后加入质数数组\n        if j == stop:\n            arrs.append(i)\n            count += 1\n    return count\n\nf2(100000)\n# 耗时0.199287338917秒, 个数9592\n```\n\n### 境界4\n以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg)\n\n首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!\n\n我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:\n\n+ 试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值\n+ 筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小\n+ 用加法代替乘法\n\n```\ndef f4(num):\n    # 初始化时将偶数全预筛除掉\n    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]\n    arrs[2] = 1\n    count = 0\n    for i in range(3, int(math.sqrt(num)), 2):\n        if arrs[i] == 0:\n            continue\n        # j为i的合数,此处用加法代替乘法\n        j = i + i\n        while j <= num:\n            arrs[j] = 0\n            j += i\n    # 计数\n    for k in range(2, num + 1):\n        if arrs[k] == 1:\n            count += 1\n    return count\n\nf4(100000)\n# 耗时0.03232869726秒, 个数9592\n```\n\n### 境界5\n...\n","source":"_posts/2016-12-26-求质数的几种方法.md","raw":"---\nlayout: post\ntitle: python求质数的几种方法\ndate: 2016/12/26 00:02:23\ntags: python\n---\n\n今天偶然在博客上上看到有人提[求质素的几种境界](http://blog.csdn.net/program_think/article/details/7032600/),在此用python进行实现代码,并进行简单的说明.\n\n我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.\n\n### 境界1\n我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取`2~N/2`.\n代码如下:\n\n```\ndef f1(num):\n    # 2也是质数,之后程序从3开始判断\n    count = 1\n    for i in range(3, num):\n        b = True\n        for j in range(2, i/2 + 1):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时35.1589805796秒, 个数9592\n```\n\n### 境界2\n我们可以从j的范围再进行优化一下,最优的范围是`2~sqrt(N)`,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:\n\n```\ndef f1(num):\n    count = 1\n    # 优化点1:偶数不做判断\n    for i in range(3, num, 2):\n        b = True\n        sq = int(math.sqrt(i)) + 1\n        # 优化点2:缩小试除范围\n        for j in range(2, sq):\n            if i % j == 0:\n                b = False\n                break\n        if b:\n            count += 1\n    return count\n\nf1(100000)\n# 耗时0.264536051872秒, 个数9592\n```\n\n### 境界3\n是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.\n\n细想一下, 比如判断101是否为质数,`sqrt(101)`为10, 那我们就要依次用这个数去除以`2, 3, 5, 7, 9`,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的**质数**即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:\n\n```\ndef f2(num):\n    arrs = [2]\n    count = 1\n    # 质数数组中的索引\n    stop = 0\n    for i in range(3, num):\n        k = int(math.sqrt(i))\n        while stop < count and arrs[stop] <= k:\n            stop += 1\n        # 整除计数\n        j = 0\n        for k in range(stop):\n            if i % arrs[j] == 0:\n                break\n            j += 1\n        # 判定为质数后加入质数数组\n        if j == stop:\n            arrs.append(i)\n            count += 1\n    return count\n\nf2(100000)\n# 耗时0.199287338917秒, 个数9592\n```\n\n### 境界4\n以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:\n\n![](http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg)\n\n首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!\n\n我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:\n\n+ 试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值\n+ 筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小\n+ 用加法代替乘法\n\n```\ndef f4(num):\n    # 初始化时将偶数全预筛除掉\n    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]\n    arrs[2] = 1\n    count = 0\n    for i in range(3, int(math.sqrt(num)), 2):\n        if arrs[i] == 0:\n            continue\n        # j为i的合数,此处用加法代替乘法\n        j = i + i\n        while j <= num:\n            arrs[j] = 0\n            j += i\n    # 计数\n    for k in range(2, num + 1):\n        if arrs[k] == 1:\n            count += 1\n    return count\n\nf4(100000)\n# 耗时0.03232869726秒, 个数9592\n```\n\n### 境界5\n...\n","slug":"2016-12-26-求质数的几种方法","published":1,"updated":"2017-08-08T13:44:58.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxs000eyqc3b3zcepoo","content":"<p>今天偶然在博客上上看到有人提<a href=\"http://blog.csdn.net/program_think/article/details/7032600/\" target=\"_blank\" rel=\"external\">求质素的几种境界</a>,在此用python进行实现代码,并进行简单的说明.</p>\n<p>我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.</p>\n<h3 id=\"境界1\"><a href=\"#境界1\" class=\"headerlink\" title=\"境界1\"></a>境界1</h3><p>我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取<code>2~N/2</code>.<br>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    # 2也是质数,之后程序从3开始判断</div><div class=\"line\">    count = 1</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        b = True</div><div class=\"line\">        for j in range(2, i/2 + 1):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时35.1589805796秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界2\"><a href=\"#境界2\" class=\"headerlink\" title=\"境界2\"></a>境界2</h3><p>我们可以从j的范围再进行优化一下,最优的范围是<code>2~sqrt(N)</code>,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 优化点1:偶数不做判断</div><div class=\"line\">    for i in range(3, num, 2):</div><div class=\"line\">        b = True</div><div class=\"line\">        sq = int(math.sqrt(i)) + 1</div><div class=\"line\">        # 优化点2:缩小试除范围</div><div class=\"line\">        for j in range(2, sq):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时0.264536051872秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界3\"><a href=\"#境界3\" class=\"headerlink\" title=\"境界3\"></a>境界3</h3><p>是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.</p>\n<p>细想一下, 比如判断101是否为质数,<code>sqrt(101)</code>为10, 那我们就要依次用这个数去除以<code>2, 3, 5, 7, 9</code>,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的<strong>质数</strong>即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f2(num):</div><div class=\"line\">    arrs = [2]</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 质数数组中的索引</div><div class=\"line\">    stop = 0</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        k = int(math.sqrt(i))</div><div class=\"line\">        while stop &lt; count and arrs[stop] &lt;= k:</div><div class=\"line\">            stop += 1</div><div class=\"line\">        # 整除计数</div><div class=\"line\">        j = 0</div><div class=\"line\">        for k in range(stop):</div><div class=\"line\">            if i % arrs[j] == 0:</div><div class=\"line\">                break</div><div class=\"line\">            j += 1</div><div class=\"line\">        # 判定为质数后加入质数数组</div><div class=\"line\">        if j == stop:</div><div class=\"line\">            arrs.append(i)</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f2(100000)</div><div class=\"line\"># 耗时0.199287338917秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界4\"><a href=\"#境界4\" class=\"headerlink\" title=\"境界4\"></a>境界4</h3><p>以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg\" alt=\"\"></p>\n<p>首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!</p>\n<p>我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:</p>\n<ul>\n<li>试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值</li>\n<li>筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小</li>\n<li>用加法代替乘法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f4(num):</div><div class=\"line\">    # 初始化时将偶数全预筛除掉</div><div class=\"line\">    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]</div><div class=\"line\">    arrs[2] = 1</div><div class=\"line\">    count = 0</div><div class=\"line\">    for i in range(3, int(math.sqrt(num)), 2):</div><div class=\"line\">        if arrs[i] == 0:</div><div class=\"line\">            continue</div><div class=\"line\">        # j为i的合数,此处用加法代替乘法</div><div class=\"line\">        j = i + i</div><div class=\"line\">        while j &lt;= num:</div><div class=\"line\">            arrs[j] = 0</div><div class=\"line\">            j += i</div><div class=\"line\">    # 计数</div><div class=\"line\">    for k in range(2, num + 1):</div><div class=\"line\">        if arrs[k] == 1:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f4(100000)</div><div class=\"line\"># 耗时0.03232869726秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界5\"><a href=\"#境界5\" class=\"headerlink\" title=\"境界5\"></a>境界5</h3><p>…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天偶然在博客上上看到有人提<a href=\"http://blog.csdn.net/program_think/article/details/7032600/\" target=\"_blank\" rel=\"external\">求质素的几种境界</a>,在此用python进行实现代码,并进行简单的说明.</p>\n<p>我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.</p>\n<h3 id=\"境界1\"><a href=\"#境界1\" class=\"headerlink\" title=\"境界1\"></a>境界1</h3><p>我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取<code>2~N/2</code>.<br>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    # 2也是质数,之后程序从3开始判断</div><div class=\"line\">    count = 1</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        b = True</div><div class=\"line\">        for j in range(2, i/2 + 1):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时35.1589805796秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界2\"><a href=\"#境界2\" class=\"headerlink\" title=\"境界2\"></a>境界2</h3><p>我们可以从j的范围再进行优化一下,最优的范围是<code>2~sqrt(N)</code>,这是因为因数都是成对出现,一个因子不可能超过sqrt(N).再思考一下,除了2以外所有偶数都不会是质数,因此可将偶数全部排除掉,让我们来修改并测试一下程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(num):</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 优化点1:偶数不做判断</div><div class=\"line\">    for i in range(3, num, 2):</div><div class=\"line\">        b = True</div><div class=\"line\">        sq = int(math.sqrt(i)) + 1</div><div class=\"line\">        # 优化点2:缩小试除范围</div><div class=\"line\">        for j in range(2, sq):</div><div class=\"line\">            if i % j == 0:</div><div class=\"line\">                b = False</div><div class=\"line\">                break</div><div class=\"line\">        if b:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f1(100000)</div><div class=\"line\"># 耗时0.264536051872秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界3\"><a href=\"#境界3\" class=\"headerlink\" title=\"境界3\"></a>境界3</h3><p>是否很有趣,通过一步一步的优化从35秒优化到了0.26秒,我们接着进行优化,普通程序员也许在境界2就浅尝辄止了,可是境界永远是用无止境的.</p>\n<p>细想一下, 比如判断101是否为质数,<code>sqrt(101)</code>为10, 那我们就要依次用这个数去除以<code>2, 3, 5, 7, 9</code>,大家主要到其实只要除以了3以后就不用除以9了,这样我们就找到了切入点:只要尝试小于sqrt(n) 的<strong>质数</strong>即可. 顺着这个思路,我们会将求得的质数临时保存起来,于是就有了以下方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f2(num):</div><div class=\"line\">    arrs = [2]</div><div class=\"line\">    count = 1</div><div class=\"line\">    # 质数数组中的索引</div><div class=\"line\">    stop = 0</div><div class=\"line\">    for i in range(3, num):</div><div class=\"line\">        k = int(math.sqrt(i))</div><div class=\"line\">        while stop &lt; count and arrs[stop] &lt;= k:</div><div class=\"line\">            stop += 1</div><div class=\"line\">        # 整除计数</div><div class=\"line\">        j = 0</div><div class=\"line\">        for k in range(stop):</div><div class=\"line\">            if i % arrs[j] == 0:</div><div class=\"line\">                break</div><div class=\"line\">            j += 1</div><div class=\"line\">        # 判定为质数后加入质数数组</div><div class=\"line\">        if j == stop:</div><div class=\"line\">            arrs.append(i)</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f2(100000)</div><div class=\"line\"># 耗时0.199287338917秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界4\"><a href=\"#境界4\" class=\"headerlink\" title=\"境界4\"></a>境界4</h3><p>以上都是试除法,现在让我们来尝试以下筛法.让我们先看以下维基百科上十分形象的一张筛法工作原理图:</p>\n<p><img src=\"http://7xp5r4.com1.z0.glb.clouddn.com/16-4-23/38858775.jpg\" alt=\"\"></p>\n<p>首先2是质数,因此将2的倍数全部去掉;3为质数,理应将6,9,12等去掉,同理我们只要指定一个质数范围,扩大其倍数进行筛选,将不大于N的所有倍数都筛除掉,剩下的就为质数!</p>\n<p>我们在运用筛选法的时候,当然还是得用以上总结出来的各种技巧:</p>\n<ul>\n<li>试除数的范围是为２～sqrt(N),同理质数求合数范围也取这个值</li>\n<li>筛法的初始化数组因为要占用字节空间,应尽可能的取小.在此我们用bool型来表示,1代表质数,0代表合数,这样开销会更小</li>\n<li>用加法代替乘法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f4(num):</div><div class=\"line\">    # 初始化时将偶数全预筛除掉</div><div class=\"line\">    arrs = [0 if _i % 2 == 0 else 1 for _i in range(num + 1)]</div><div class=\"line\">    arrs[2] = 1</div><div class=\"line\">    count = 0</div><div class=\"line\">    for i in range(3, int(math.sqrt(num)), 2):</div><div class=\"line\">        if arrs[i] == 0:</div><div class=\"line\">            continue</div><div class=\"line\">        # j为i的合数,此处用加法代替乘法</div><div class=\"line\">        j = i + i</div><div class=\"line\">        while j &lt;= num:</div><div class=\"line\">            arrs[j] = 0</div><div class=\"line\">            j += i</div><div class=\"line\">    # 计数</div><div class=\"line\">    for k in range(2, num + 1):</div><div class=\"line\">        if arrs[k] == 1:</div><div class=\"line\">            count += 1</div><div class=\"line\">    return count</div><div class=\"line\"></div><div class=\"line\">f4(100000)</div><div class=\"line\"># 耗时0.03232869726秒, 个数9592</div></pre></td></tr></table></figure>\n<h3 id=\"境界5\"><a href=\"#境界5\" class=\"headerlink\" title=\"境界5\"></a>境界5</h3><p>…</p>\n"},{"layout":"post","title":"BEM规范","date":"2017-01-09T14:27:27.000Z","_content":"\n## 什么是BEM？\nblock(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。\n\n\n## 语法\n```\n.block {} // 块\n.block__element {} // 块所属元素\n.block__element--modifier {} // 块所属元素的状态\n```\n\n\n## 与sass结合\n### &\n通过&会直接引用父元素，嵌套使用&可以增强可读性：\n```\n.block {\n  &__element1 {}\n  &__element2 {}\n}\n```\n\n### extend\n如下html：\n```\n<ul>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item--active\"></li> <!-- 梦想 -->\n  <li class=\"nav__item nav__item--active\"></li> <!-- 现实 -->\n</ul>\n```\n\nextend可以继承类的所有定义，于是可以这样消除冗余：\n```\n.nav {\n  ...\n  &__item {\n    ...\n    &--active {\n      @extend .nav__item;\n      ...\n    }\n  }\n}\n```\n\n## css module...\ncss module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：\n### 书写麻烦\n使用css module引入的标签：\n```\n<div className={classnames(style['class1__child'], style['class2']}></div>\n```\n\n而使用import导入bem类会是这样的：\n```\n<div className=\"class1__child class2\"></div>\n```\n\n### 测试\n写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～\n\n### 编译工具\nsass、less我是不想舍弃～\n\n\n## TODO\n1. BEM的优点\n2. 补充说明\n","source":"_posts/2017-01-09-BEM规范.md","raw":"---\nlayout: post\ntitle: BEM规范\ndate: 2017/01/09 22:27:27\ntags: tricks\n---\n\n## 什么是BEM？\nblock(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。\n\n\n## 语法\n```\n.block {} // 块\n.block__element {} // 块所属元素\n.block__element--modifier {} // 块所属元素的状态\n```\n\n\n## 与sass结合\n### &\n通过&会直接引用父元素，嵌套使用&可以增强可读性：\n```\n.block {\n  &__element1 {}\n  &__element2 {}\n}\n```\n\n### extend\n如下html：\n```\n<ul>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item\"></li>\n  <li class=\"nav__item--active\"></li> <!-- 梦想 -->\n  <li class=\"nav__item nav__item--active\"></li> <!-- 现实 -->\n</ul>\n```\n\nextend可以继承类的所有定义，于是可以这样消除冗余：\n```\n.nav {\n  ...\n  &__item {\n    ...\n    &--active {\n      @extend .nav__item;\n      ...\n    }\n  }\n}\n```\n\n## css module...\ncss module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：\n### 书写麻烦\n使用css module引入的标签：\n```\n<div className={classnames(style['class1__child'], style['class2']}></div>\n```\n\n而使用import导入bem类会是这样的：\n```\n<div className=\"class1__child class2\"></div>\n```\n\n### 测试\n写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～\n\n### 编译工具\nsass、less我是不想舍弃～\n\n\n## TODO\n1. BEM的优点\n2. 补充说明\n","slug":"2017-01-09-BEM规范","published":1,"updated":"2017-08-08T13:45:03.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxu000hyqc3gb0n76t9","content":"<h2 id=\"什么是BEM？\"><a href=\"#什么是BEM？\" class=\"headerlink\" title=\"什么是BEM？\"></a>什么是BEM？</h2><p>block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;&#125; // 块</div><div class=\"line\">.block__element &#123;&#125; // 块所属元素</div><div class=\"line\">.block__element--modifier &#123;&#125; // 块所属元素的状态</div></pre></td></tr></table></figure>\n<h2 id=\"与sass结合\"><a href=\"#与sass结合\" class=\"headerlink\" title=\"与sass结合\"></a>与sass结合</h2><h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>通过&amp;会直接引用父元素，嵌套使用&amp;可以增强可读性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;</div><div class=\"line\">  &amp;__element1 &#123;&#125;</div><div class=\"line\">  &amp;__element2 &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h3><p>如下html：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 梦想 --&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 现实 --&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>extend可以继承类的所有定义，于是可以这样消除冗余：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.nav &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &amp;__item &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    &amp;--active &#123;</div><div class=\"line\">      @extend .nav__item;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"css-module…\"><a href=\"#css-module…\" class=\"headerlink\" title=\"css module…\"></a>css module…</h2><p>css module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：</p>\n<h3 id=\"书写麻烦\"><a href=\"#书写麻烦\" class=\"headerlink\" title=\"书写麻烦\"></a>书写麻烦</h3><p>使用css module引入的标签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&#123;classnames(style[&apos;class1__child&apos;], style[&apos;class2&apos;]&#125;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>而使用import导入bem类会是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&quot;class1__child class2&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～</p>\n<h3 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h3><p>sass、less我是不想舍弃～</p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ol>\n<li>BEM的优点</li>\n<li>补充说明</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是BEM？\"><a href=\"#什么是BEM？\" class=\"headerlink\" title=\"什么是BEM？\"></a>什么是BEM？</h2><p>block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;&#125; // 块</div><div class=\"line\">.block__element &#123;&#125; // 块所属元素</div><div class=\"line\">.block__element--modifier &#123;&#125; // 块所属元素的状态</div></pre></td></tr></table></figure>\n<h2 id=\"与sass结合\"><a href=\"#与sass结合\" class=\"headerlink\" title=\"与sass结合\"></a>与sass结合</h2><h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>通过&amp;会直接引用父元素，嵌套使用&amp;可以增强可读性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.block &#123;</div><div class=\"line\">  &amp;__element1 &#123;&#125;</div><div class=\"line\">  &amp;__element2 &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h3><p>如下html：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item&quot;&gt;&lt;/li&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 梦想 --&gt;</div><div class=\"line\">  &lt;li class=&quot;nav__item nav__item--active&quot;&gt;&lt;/li&gt; &lt;!-- 现实 --&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>extend可以继承类的所有定义，于是可以这样消除冗余：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.nav &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &amp;__item &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    &amp;--active &#123;</div><div class=\"line\">      @extend .nav__item;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"css-module…\"><a href=\"#css-module…\" class=\"headerlink\" title=\"css module…\"></a>css module…</h2><p>css module确实能给react带来很好的css独立性，再也不用担心产生命名冲突，但通过实际编程，发现以下问题：</p>\n<h3 id=\"书写麻烦\"><a href=\"#书写麻烦\" class=\"headerlink\" title=\"书写麻烦\"></a>书写麻烦</h3><p>使用css module引入的标签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&#123;classnames(style[&apos;class1__child&apos;], style[&apos;class2&apos;]&#125;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>而使用import导入bem类会是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div className=&quot;class1__child class2&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>写过react测试的同学应该深有体会吧，运行测试时无法通过类名直接去选择，这样会绕了多少弯路啊～</p>\n<h3 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h3><p>sass、less我是不想舍弃～</p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ol>\n<li>BEM的优点</li>\n<li>补充说明</li>\n</ol>\n"},{"layout":"post","title":"flex布局","date":"2017-01-21T11:50:00.000Z","_content":"\n## 简介\nflex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。\n\n它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。\n\n设置容器为flex布局，只需要设置`display: flex`即可。它将具有以下特性：\n1. 子元素float、clear、vertical-align将失效。\n2. 存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。\n\n## 概念\n![](/imgs/flex布局.png)\n#### 轴线\n+ 主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。\n+ 交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。\n\n#### flex 属性：\n+ flex-direction，设置主轴的方向\n+ flex-wrap，项目是否多行显示\n+ flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap\n+ justify-content，项目在主轴上的对齐方式\n+ align-items，项目在交叉轴上的对齐方式\n+ align-content，多根轴线的对其方式，对只有一根轴线的无效\n\n#### flex item属性：\n+ order，项目的权重，数值越小排列越靠前\n+ flex-grow，项目的放大比例，默认为0不放大\n+ flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小\n+ flex-basis，项目本身的大小，和width、height类似\n+ flex，flex-grow、flex-shrink和flex-basis属性的简写\n+ align-self，设置项目自身的对其方式，覆盖align-items属性\n\n各项详细配置，请参照阮老师的[语法文章](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n## Usage\n> [vv13.cn/flex-demo](http://vv13.cn/flex-demo)\n\n文字不便描述，直接访问在线app示例吧，这里是[github地址](https://github.com/vv13/flex-demo.git)～\n","source":"_posts/2017-01-21-flex布局.md","raw":"---\nlayout: post\ntitle: flex布局\ndate: 2017/01/21 19:50:00\ntags: web\n---\n\n## 简介\nflex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。\n\n它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。\n\n设置容器为flex布局，只需要设置`display: flex`即可。它将具有以下特性：\n1. 子元素float、clear、vertical-align将失效。\n2. 存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。\n\n## 概念\n![](/imgs/flex布局.png)\n#### 轴线\n+ 主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。\n+ 交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。\n\n#### flex 属性：\n+ flex-direction，设置主轴的方向\n+ flex-wrap，项目是否多行显示\n+ flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap\n+ justify-content，项目在主轴上的对齐方式\n+ align-items，项目在交叉轴上的对齐方式\n+ align-content，多根轴线的对其方式，对只有一根轴线的无效\n\n#### flex item属性：\n+ order，项目的权重，数值越小排列越靠前\n+ flex-grow，项目的放大比例，默认为0不放大\n+ flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小\n+ flex-basis，项目本身的大小，和width、height类似\n+ flex，flex-grow、flex-shrink和flex-basis属性的简写\n+ align-self，设置项目自身的对其方式，覆盖align-items属性\n\n各项详细配置，请参照阮老师的[语法文章](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n## Usage\n> [vv13.cn/flex-demo](http://vv13.cn/flex-demo)\n\n文字不便描述，直接访问在线app示例吧，这里是[github地址](https://github.com/vv13/flex-demo.git)～\n","slug":"2017-01-21-flex布局","published":1,"updated":"2017-08-08T13:45:08.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxw000jyqc3las7pi9j","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>flex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。</p>\n<p>它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。</p>\n<p>设置容器为flex布局，只需要设置<code>display: flex</code>即可。它将具有以下特性：</p>\n<ol>\n<li>子元素float、clear、vertical-align将失效。</li>\n<li>存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。</li>\n</ol>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><img src=\"/imgs/flex布局.png\" alt=\"\"></p>\n<h4 id=\"轴线\"><a href=\"#轴线\" class=\"headerlink\" title=\"轴线\"></a>轴线</h4><ul>\n<li>主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。</li>\n<li>交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。</li>\n</ul>\n<h4 id=\"flex-属性：\"><a href=\"#flex-属性：\" class=\"headerlink\" title=\"flex 属性：\"></a>flex 属性：</h4><ul>\n<li>flex-direction，设置主轴的方向</li>\n<li>flex-wrap，项目是否多行显示</li>\n<li>flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap</li>\n<li>justify-content，项目在主轴上的对齐方式</li>\n<li>align-items，项目在交叉轴上的对齐方式</li>\n<li>align-content，多根轴线的对其方式，对只有一根轴线的无效</li>\n</ul>\n<h4 id=\"flex-item属性：\"><a href=\"#flex-item属性：\" class=\"headerlink\" title=\"flex item属性：\"></a>flex item属性：</h4><ul>\n<li>order，项目的权重，数值越小排列越靠前</li>\n<li>flex-grow，项目的放大比例，默认为0不放大</li>\n<li>flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小</li>\n<li>flex-basis，项目本身的大小，和width、height类似</li>\n<li>flex，flex-grow、flex-shrink和flex-basis属性的简写</li>\n<li>align-self，设置项目自身的对其方式，覆盖align-items属性</li>\n</ul>\n<p>各项详细配置，请参照阮老师的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"external\">语法文章</a>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p><a href=\"http://vv13.cn/flex-demo\" target=\"_blank\" rel=\"external\">vv13.cn/flex-demo</a></p>\n</blockquote>\n<p>文字不便描述，直接访问在线app示例吧，这里是<a href=\"https://github.com/vv13/flex-demo.git\" target=\"_blank\" rel=\"external\">github地址</a>～</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>flex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。</p>\n<p>它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。</p>\n<p>设置容器为flex布局，只需要设置<code>display: flex</code>即可。它将具有以下特性：</p>\n<ol>\n<li>子元素float、clear、vertical-align将失效。</li>\n<li>存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。</li>\n</ol>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><img src=\"/imgs/flex布局.png\" alt=\"\"></p>\n<h4 id=\"轴线\"><a href=\"#轴线\" class=\"headerlink\" title=\"轴线\"></a>轴线</h4><ul>\n<li>主轴: 它是flex子元素的排列方向，默认为水平向右，可根据flex-direction确定方向。</li>\n<li>交叉轴：垂直于主轴,确定子元素的垂直方向上的位置。</li>\n</ul>\n<h4 id=\"flex-属性：\"><a href=\"#flex-属性：\" class=\"headerlink\" title=\"flex 属性：\"></a>flex 属性：</h4><ul>\n<li>flex-direction，设置主轴的方向</li>\n<li>flex-wrap，项目是否多行显示</li>\n<li>flex-flow，flex-direction与flex-wrap的缩写，默认为row nowrap</li>\n<li>justify-content，项目在主轴上的对齐方式</li>\n<li>align-items，项目在交叉轴上的对齐方式</li>\n<li>align-content，多根轴线的对其方式，对只有一根轴线的无效</li>\n</ul>\n<h4 id=\"flex-item属性：\"><a href=\"#flex-item属性：\" class=\"headerlink\" title=\"flex item属性：\"></a>flex item属性：</h4><ul>\n<li>order，项目的权重，数值越小排列越靠前</li>\n<li>flex-grow，项目的放大比例，默认为0不放大</li>\n<li>flex-shrink，项目的缩小比例，默认为1等比缩小，设置为0后不缩小</li>\n<li>flex-basis，项目本身的大小，和width、height类似</li>\n<li>flex，flex-grow、flex-shrink和flex-basis属性的简写</li>\n<li>align-self，设置项目自身的对其方式，覆盖align-items属性</li>\n</ul>\n<p>各项详细配置，请参照阮老师的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"external\">语法文章</a>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p><a href=\"http://vv13.cn/flex-demo\" target=\"_blank\" rel=\"external\">vv13.cn/flex-demo</a></p>\n</blockquote>\n<p>文字不便描述，直接访问在线app示例吧，这里是<a href=\"https://github.com/vv13/flex-demo.git\" target=\"_blank\" rel=\"external\">github地址</a>～</p>\n"},{"layout":"post","title":"理解javascript线程","date":"2017-02-09T09:30:24.000Z","_content":"\n## 进程和线程\n+ 进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间\n+ 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)\n\n线程的作用：\n\n1. 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型\n1. 线程很轻量，创建与销毁消耗的资源小\n1. 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作\n\n根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：\n\n```\n最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。\n\n能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。\n\n另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。\n```\n\n## javascript单线程机制\n\njavascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：\n\n1. 在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。\n1. 再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。\n\n所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。\n\n## 任务队列\n\njavascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。\n\n同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。\n\n任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。\n\n关于定时器的用法，常见的如`setTimeout(fn, 0);`，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。\n\n## 事件循环(Event Loop)\n\n![image](http://i4.buimg.com/567571/eadf3db4bf455904.png)\nEvent Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。\n\n主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:\n\n```javascript\nwhile (queue.waitForMessage()) {\n    queue.processNextMessage()\n}\n```\n\n而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。\n\n## Web Worker\n随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。\n\nWeb Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。\n","source":"_posts/2017-03-06-深入理解javascript线程.md","raw":"---\nlayout: post\ntitle: 理解javascript线程\ndate: 2017/02/09 17:30:24\ntags: js\n---\n\n## 进程和线程\n+ 进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间\n+ 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)\n\n线程的作用：\n\n1. 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型\n1. 线程很轻量，创建与销毁消耗的资源小\n1. 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作\n\n根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：\n\n```\n最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。\n\n能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。\n\n另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。\n```\n\n## javascript单线程机制\n\njavascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：\n\n1. 在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。\n1. 再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。\n\n所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。\n\n## 任务队列\n\njavascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。\n\n同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。\n\n任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。\n\n关于定时器的用法，常见的如`setTimeout(fn, 0);`，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。\n\n## 事件循环(Event Loop)\n\n![image](http://i4.buimg.com/567571/eadf3db4bf455904.png)\nEvent Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。\n\n主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:\n\n```javascript\nwhile (queue.waitForMessage()) {\n    queue.processNextMessage()\n}\n```\n\n而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。\n\n## Web Worker\n随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。\n\nWeb Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。\n","slug":"2017-03-06-深入理解javascript线程","published":1,"updated":"2017-08-08T13:45:16.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugxz000myqc399dayhxw","content":"<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><ul>\n<li>进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间</li>\n<li>线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)</li>\n</ul>\n<p>线程的作用：</p>\n<ol>\n<li>大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型</li>\n<li>线程很轻量，创建与销毁消耗的资源小</li>\n<li>线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作</li>\n</ol>\n<p>根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。</div><div class=\"line\"></div><div class=\"line\">能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。</div><div class=\"line\"></div><div class=\"line\">另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。</div></pre></td></tr></table></figure>\n<h2 id=\"javascript单线程机制\"><a href=\"#javascript单线程机制\" class=\"headerlink\" title=\"javascript单线程机制\"></a>javascript单线程机制</h2><p>javascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：</p>\n<ol>\n<li>在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。</li>\n<li>再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。</li>\n</ol>\n<p>所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。</p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>javascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。</p>\n<p>同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。</p>\n<p>任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。</p>\n<p>关于定时器的用法，常见的如<code>setTimeout(fn, 0);</code>，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p><img src=\"http://i4.buimg.com/567571/eadf3db4bf455904.png\" alt=\"image\"><br>Event Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。</p>\n<p>主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</div><div class=\"line\">    queue.processNextMessage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。</p>\n<h2 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h2><p>随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。</p>\n<p>Web Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><ul>\n<li>进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间</li>\n<li>线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)</li>\n</ul>\n<p>线程的作用：</p>\n<ol>\n<li>大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型</li>\n<li>线程很轻量，创建与销毁消耗的资源小</li>\n<li>线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作</li>\n</ol>\n<p>根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。</div><div class=\"line\"></div><div class=\"line\">能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。</div><div class=\"line\"></div><div class=\"line\">另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。</div></pre></td></tr></table></figure>\n<h2 id=\"javascript单线程机制\"><a href=\"#javascript单线程机制\" class=\"headerlink\" title=\"javascript单线程机制\"></a>javascript单线程机制</h2><p>javascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：</p>\n<ol>\n<li>在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。</li>\n<li>再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。</li>\n</ol>\n<p>所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。</p>\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h2><p>javascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。</p>\n<p>同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。</p>\n<p>任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。</p>\n<p>关于定时器的用法，常见的如<code>setTimeout(fn, 0);</code>，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p><img src=\"http://i4.buimg.com/567571/eadf3db4bf455904.png\" alt=\"image\"><br>Event Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。</p>\n<p>主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</div><div class=\"line\">    queue.processNextMessage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。</p>\n<h2 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h2><p>随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。</p>\n<p>Web Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。</p>\n"},{"layout":"post","title":"vue中如何自定义v-model","date":"2017-03-30T17:36:00.000Z","_content":"\n## 简介\n在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。\n\n基本的v-model用法为：\n```\n<input v-model=\"something\">\n```\n\n其实它是以下用法的简写：\n```\n<input :value=\"something\" @input=\"something = $event.target.value\" />\n```\n\n因此，自己封装组件的话，可以这样来定义：\n\n\n```\n// demo.vue\n<template lang=\"html\">\n  <input :value=\"value\" @input=\"valueChange\">\n</template>\n\n<script>\nexport default {\n  props: ['value'],\n  methods: {\n    valueChange (v) {\n      this.$emit('input', v.target.value)\n    }\n  }\n}\n</script>\n\n// 引用\n<demo v-model=\"something\"></demo>\n```\n\n## 用法示例\n在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:\n\n![](http://i4.buimg.com/567571/4be2a48163ab3278.png)\n\n我们想要展示的数据格式为：\n\n![](http://i2.muimg.com/567571/22498a7d7df1a596.png)\n\n仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format => YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：\n```\n<el-time-select\n  v-model=\"value1\"\n</el-time-select>\n```\n\n因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：\n\n```\n<el-time-select\n  :value=\"time | convertToRangeTime\"\n  @input=\"e => time = e\"\n</el-time-select>\n```\n","source":"_posts/2017-03-31-vue中如何自定义v-model.md","raw":"---\nlayout: \"post\"\ntitle: \"vue中如何自定义v-model\"\ndate: \"2017/03/31 01:36\"\ntags: vue\n---\n\n## 简介\n在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。\n\n基本的v-model用法为：\n```\n<input v-model=\"something\">\n```\n\n其实它是以下用法的简写：\n```\n<input :value=\"something\" @input=\"something = $event.target.value\" />\n```\n\n因此，自己封装组件的话，可以这样来定义：\n\n\n```\n// demo.vue\n<template lang=\"html\">\n  <input :value=\"value\" @input=\"valueChange\">\n</template>\n\n<script>\nexport default {\n  props: ['value'],\n  methods: {\n    valueChange (v) {\n      this.$emit('input', v.target.value)\n    }\n  }\n}\n</script>\n\n// 引用\n<demo v-model=\"something\"></demo>\n```\n\n## 用法示例\n在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:\n\n![](http://i4.buimg.com/567571/4be2a48163ab3278.png)\n\n我们想要展示的数据格式为：\n\n![](http://i2.muimg.com/567571/22498a7d7df1a596.png)\n\n仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format => YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：\n```\n<el-time-select\n  v-model=\"value1\"\n</el-time-select>\n```\n\n因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：\n\n```\n<el-time-select\n  :value=\"time | convertToRangeTime\"\n  @input=\"e => time = e\"\n</el-time-select>\n```\n","slug":"2017-03-31-vue中如何自定义v-model","published":1,"updated":"2017-08-10T17:15:44.000Z","comments":1,"photos":[],"link":"","_id":"cj771ugy3000oyqc3qu8vk5t5","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。</p>\n<p>基本的v-model用法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其实它是以下用法的简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input :value=&quot;something&quot; @input=&quot;something = $event.target.value&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，自己封装组件的话，可以这样来定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// demo.vue</div><div class=\"line\">&lt;template lang=&quot;html&quot;&gt;</div><div class=\"line\">  &lt;input :value=&quot;value&quot; @input=&quot;valueChange&quot;&gt;</div><div class=\"line\">&lt;/template&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">export default &#123;</div><div class=\"line\">  props: [&apos;value&apos;],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    valueChange (v) &#123;</div><div class=\"line\">      this.$emit(&apos;input&apos;, v.target.value)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">// 引用</div><div class=\"line\">&lt;demo v-model=&quot;something&quot;&gt;&lt;/demo&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h2><p>在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:</p>\n<p><img src=\"http://i4.buimg.com/567571/4be2a48163ab3278.png\" alt=\"\"></p>\n<p>我们想要展示的数据格式为：</p>\n<p><img src=\"http://i2.muimg.com/567571/22498a7d7df1a596.png\" alt=\"\"></p>\n<p>仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format =&gt; YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  v-model=&quot;value1&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  :value=&quot;time | convertToRangeTime&quot;</div><div class=\"line\">  @input=&quot;e =&gt; time = e&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。</p>\n<p>基本的v-model用法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其实它是以下用法的简写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input :value=&quot;something&quot; @input=&quot;something = $event.target.value&quot; /&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，自己封装组件的话，可以这样来定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// demo.vue</div><div class=\"line\">&lt;template lang=&quot;html&quot;&gt;</div><div class=\"line\">  &lt;input :value=&quot;value&quot; @input=&quot;valueChange&quot;&gt;</div><div class=\"line\">&lt;/template&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">export default &#123;</div><div class=\"line\">  props: [&apos;value&apos;],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    valueChange (v) &#123;</div><div class=\"line\">      this.$emit(&apos;input&apos;, v.target.value)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">// 引用</div><div class=\"line\">&lt;demo v-model=&quot;something&quot;&gt;&lt;/demo&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h2><p>在使用element组件库中，有些组件需要借助拆分v-model自定义命令才能实现需要的功能，如下:</p>\n<p><img src=\"http://i4.buimg.com/567571/4be2a48163ab3278.png\" alt=\"\"></p>\n<p>我们想要展示的数据格式为：</p>\n<p><img src=\"http://i2.muimg.com/567571/22498a7d7df1a596.png\" alt=\"\"></p>\n<p>仔细查阅接口文档，并没有我们需要的格式化数据方法，只有一个format =&gt; YYMMDD的类似方法，但是看示例代码它实现了v-model的双向绑定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  v-model=&quot;value1&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure></p>\n<p>因此，我们可以通过@input事件获取到它的改变值，然后再通过:value展示时添加一个过滤器，将字符串转换以下即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;el-time-select</div><div class=\"line\">  :value=&quot;time | convertToRangeTime&quot;</div><div class=\"line\">  @input=&quot;e =&gt; time = e&quot;</div><div class=\"line\">&lt;/el-time-select&gt;</div></pre></td></tr></table></figure>\n"},{"title":"异步编程中的thunk函数","date":"2017-08-22T17:16:14.000Z","_content":"\n## 什么是Thunk\n\nThunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。\n\n写一个简单的函数，用于读取package.json的信息：\n\n```\nfs.readFile('package.json', (err, data) => {\n    if (err) throw err;\n    console.log(data.toString())\n})\n```\n\n在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：\n\n```\nconst app = new Koa()\n\napp.use(function*(next) {\n    const data = yield readFileThunk('package.json')\n    console.log(data)\n    yield next\n})\n\nfunction readFileThunk(path, cb) {\n    return function(cb) {\n        fs.readFile(path, (err, data) => {\n            if (err) throw err\n            cb(null, data.toString())\n        })\n    }\n}\napp.listen(3000)\n```\n\n通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。**Thunk函数将多参数函数替换成了单参数版本**，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：\n\n```\napp.use(async(ctx, next) => {\n    const data = await readFileWrap('package.json')\n    console.log(data)\n    await next()\n})\n\nfunction readFileWrap(path, cb) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, (err, data) => {\n            if (err) throw reject(error)\n            resolve(data.toString())\n        })\n    })\n}\n```\n\n我们接下来自己实现一个简易的thunk工具方法，思路如下：\n\n1. 一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包\n2. 第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法\n3. 第三层函数传入一个回调函数cb, 然后执行主程序\n\n```\nfunction thunkit(fn) {\n    return function() {\n        var args = Array.prototype.slice.call(arguments) \n        return function(cb) {\n            args.push(cb)\n            return fn.apply(this, args)\n        }\n    }\n}\n```\n\n在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。\n\n## thunkify源码解析\n\n```\nfunction thunkify(fn){\n  assert('function' == typeof fn, 'function required'); // 是否为函数\n\n  return function(){\n    var args = new Array(arguments.length); \n    var ctx = this; // 绑定函数的上下文对象\n\t\n\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组\n    for(var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function(done){\n      var called; // 记录是否执行回调，只允许执行一次\n\n      args.push(function(){\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args); // 调用参数列表\n      } catch (err) {\n        done(err); // 返回错误\n      }\n    }\n  }\n};\n```\n\n源代码已经够简单了，想也无需多说明，**重要的是函数本身的思想与灵活的去运用**。\n\n### 参考资料\n\n- [node-thunkify](https://github.com/tj/node-thunkify)\n\n- [阮一峰-Thunk 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/thunk.html)\n\n- [experiments-with-koa-and-javascript-generators](http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/)\n","source":"_posts/2017-08-22-异步编程中的thunk函数.md","raw":"---\ntitle: 异步编程中的thunk函数\ndate: 2017-08-23 01:16:14\ntags: js\n---\n\n## 什么是Thunk\n\nThunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。\n\n写一个简单的函数，用于读取package.json的信息：\n\n```\nfs.readFile('package.json', (err, data) => {\n    if (err) throw err;\n    console.log(data.toString())\n})\n```\n\n在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：\n\n```\nconst app = new Koa()\n\napp.use(function*(next) {\n    const data = yield readFileThunk('package.json')\n    console.log(data)\n    yield next\n})\n\nfunction readFileThunk(path, cb) {\n    return function(cb) {\n        fs.readFile(path, (err, data) => {\n            if (err) throw err\n            cb(null, data.toString())\n        })\n    }\n}\napp.listen(3000)\n```\n\n通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。**Thunk函数将多参数函数替换成了单参数版本**，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：\n\n```\napp.use(async(ctx, next) => {\n    const data = await readFileWrap('package.json')\n    console.log(data)\n    await next()\n})\n\nfunction readFileWrap(path, cb) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, (err, data) => {\n            if (err) throw reject(error)\n            resolve(data.toString())\n        })\n    })\n}\n```\n\n我们接下来自己实现一个简易的thunk工具方法，思路如下：\n\n1. 一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包\n2. 第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法\n3. 第三层函数传入一个回调函数cb, 然后执行主程序\n\n```\nfunction thunkit(fn) {\n    return function() {\n        var args = Array.prototype.slice.call(arguments) \n        return function(cb) {\n            args.push(cb)\n            return fn.apply(this, args)\n        }\n    }\n}\n```\n\n在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。\n\n## thunkify源码解析\n\n```\nfunction thunkify(fn){\n  assert('function' == typeof fn, 'function required'); // 是否为函数\n\n  return function(){\n    var args = new Array(arguments.length); \n    var ctx = this; // 绑定函数的上下文对象\n\t\n\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组\n    for(var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function(done){\n      var called; // 记录是否执行回调，只允许执行一次\n\n      args.push(function(){\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args); // 调用参数列表\n      } catch (err) {\n        done(err); // 返回错误\n      }\n    }\n  }\n};\n```\n\n源代码已经够简单了，想也无需多说明，**重要的是函数本身的思想与灵活的去运用**。\n\n### 参考资料\n\n- [node-thunkify](https://github.com/tj/node-thunkify)\n\n- [阮一峰-Thunk 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/thunk.html)\n\n- [experiments-with-koa-and-javascript-generators](http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/)\n","slug":"2017-08-22-异步编程中的thunk函数","published":1,"updated":"2017-08-22T17:24:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj771ugy7000ryqc3mnsitvix","content":"<h2 id=\"什么是Thunk\"><a href=\"#什么是Thunk\" class=\"headerlink\" title=\"什么是Thunk\"></a>什么是Thunk</h2><p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>\n<p>写一个简单的函数，用于读取package.json的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(&apos;package.json&apos;, (err, data) =&gt; &#123;</div><div class=\"line\">    if (err) throw err;</div><div class=\"line\">    console.log(data.toString())</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">const app = new Koa()</div><div class=\"line\"></div><div class=\"line\">app.use(function*(next) &#123;</div><div class=\"line\">    const data = yield readFileThunk(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    yield next</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileThunk(path, cb) &#123;</div><div class=\"line\">    return function(cb) &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw err</div><div class=\"line\">            cb(null, data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">app.listen(3000)</div></pre></td></tr></table></figure>\n<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async(ctx, next) =&gt; &#123;</div><div class=\"line\">    const data = await readFileWrap(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    await next()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileWrap(path, cb) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw reject(error)</div><div class=\"line\">            resolve(data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>\n<ol>\n<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>\n<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>\n<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkit(fn) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        var args = Array.prototype.slice.call(arguments) </div><div class=\"line\">        return function(cb) &#123;</div><div class=\"line\">            args.push(cb)</div><div class=\"line\">            return fn.apply(this, args)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>\n<h2 id=\"thunkify源码解析\"><a href=\"#thunkify源码解析\" class=\"headerlink\" title=\"thunkify源码解析\"></a>thunkify源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkify(fn)&#123;</div><div class=\"line\">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); // 是否为函数</div><div class=\"line\"></div><div class=\"line\">  return function()&#123;</div><div class=\"line\">    var args = new Array(arguments.length); </div><div class=\"line\">    var ctx = this; // 绑定函数的上下文对象</div><div class=\"line\">\t</div><div class=\"line\">\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组</div><div class=\"line\">    for(var i = 0; i &lt; args.length; ++i) &#123;</div><div class=\"line\">      args[i] = arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return function(done)&#123;</div><div class=\"line\">      var called; // 记录是否执行回调，只允许执行一次</div><div class=\"line\"></div><div class=\"line\">      args.push(function()&#123;</div><div class=\"line\">        if (called) return;</div><div class=\"line\">        called = true;</div><div class=\"line\">        done.apply(null, arguments);</div><div class=\"line\">      &#125;);</div><div class=\"line\"></div><div class=\"line\">      try &#123;</div><div class=\"line\">        fn.apply(ctx, args); // 调用参数列表</div><div class=\"line\">      &#125; catch (err) &#123;</div><div class=\"line\">        done(err); // 返回错误</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"https://github.com/tj/node-thunkify\" target=\"_blank\" rel=\"external\">node-thunkify</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/05/thunk.html\" target=\"_blank\" rel=\"external\">阮一峰-Thunk 函数的含义和用法</a></p>\n</li>\n<li><p><a href=\"http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/\" target=\"_blank\" rel=\"external\">experiments-with-koa-and-javascript-generators</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Thunk\"><a href=\"#什么是Thunk\" class=\"headerlink\" title=\"什么是Thunk\"></a>什么是Thunk</h2><p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>\n<p>写一个简单的函数，用于读取package.json的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.readFile(&apos;package.json&apos;, (err, data) =&gt; &#123;</div><div class=\"line\">    if (err) throw err;</div><div class=\"line\">    console.log(data.toString())</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">const app = new Koa()</div><div class=\"line\"></div><div class=\"line\">app.use(function*(next) &#123;</div><div class=\"line\">    const data = yield readFileThunk(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    yield next</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileThunk(path, cb) &#123;</div><div class=\"line\">    return function(cb) &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw err</div><div class=\"line\">            cb(null, data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">app.listen(3000)</div></pre></td></tr></table></figure>\n<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async(ctx, next) =&gt; &#123;</div><div class=\"line\">    const data = await readFileWrap(&apos;package.json&apos;)</div><div class=\"line\">    console.log(data)</div><div class=\"line\">    await next()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">function readFileWrap(path, cb) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class=\"line\">            if (err) throw reject(error)</div><div class=\"line\">            resolve(data.toString())</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>\n<ol>\n<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>\n<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>\n<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkit(fn) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        var args = Array.prototype.slice.call(arguments) </div><div class=\"line\">        return function(cb) &#123;</div><div class=\"line\">            args.push(cb)</div><div class=\"line\">            return fn.apply(this, args)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>\n<h2 id=\"thunkify源码解析\"><a href=\"#thunkify源码解析\" class=\"headerlink\" title=\"thunkify源码解析\"></a>thunkify源码解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function thunkify(fn)&#123;</div><div class=\"line\">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); // 是否为函数</div><div class=\"line\"></div><div class=\"line\">  return function()&#123;</div><div class=\"line\">    var args = new Array(arguments.length); </div><div class=\"line\">    var ctx = this; // 绑定函数的上下文对象</div><div class=\"line\">\t</div><div class=\"line\">\t// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组</div><div class=\"line\">    for(var i = 0; i &lt; args.length; ++i) &#123;</div><div class=\"line\">      args[i] = arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return function(done)&#123;</div><div class=\"line\">      var called; // 记录是否执行回调，只允许执行一次</div><div class=\"line\"></div><div class=\"line\">      args.push(function()&#123;</div><div class=\"line\">        if (called) return;</div><div class=\"line\">        called = true;</div><div class=\"line\">        done.apply(null, arguments);</div><div class=\"line\">      &#125;);</div><div class=\"line\"></div><div class=\"line\">      try &#123;</div><div class=\"line\">        fn.apply(ctx, args); // 调用参数列表</div><div class=\"line\">      &#125; catch (err) &#123;</div><div class=\"line\">        done(err); // 返回错误</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"https://github.com/tj/node-thunkify\" target=\"_blank\" rel=\"external\">node-thunkify</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/05/thunk.html\" target=\"_blank\" rel=\"external\">阮一峰-Thunk 函数的含义和用法</a></p>\n</li>\n<li><p><a href=\"http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/\" target=\"_blank\" rel=\"external\">experiments-with-koa-and-javascript-generators</a></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj771ugwv0000yqc352yjmc40","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugxi0007yqc3uk49dsh2"},{"post_id":"cj771ugxd0005yqc3j1da9s4j","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugxj0009yqc3evx40wwt"},{"post_id":"cj771ugx00001yqc3tcjmo46i","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugxr000cyqc34rrqpext"},{"post_id":"cj771ugxr000dyqc3kmfva21l","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugxu000gyqc3fpgsgapo"},{"post_id":"cj771ugx80003yqc31kf95rbf","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugxv000iyqc33smvznj0"},{"post_id":"cj771ugxu000hyqc3gb0n76t9","tag_id":"cj771ugxt000fyqc3d6t9878b","_id":"cj771ugxy000lyqc3edfe4704"},{"post_id":"cj771ugx90004yqc36m00xp34","tag_id":"cj771ugxt000fyqc3d6t9878b","_id":"cj771ugy2000nyqc3irqfdkzx"},{"post_id":"cj771ugxz000myqc399dayhxw","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugy6000qyqc3l5w61c5x"},{"post_id":"cj771ugxi0008yqc3ahcmdtyu","tag_id":"cj771ugxx000kyqc3pzzw2qnh","_id":"cj771ugye000syqc3ejzd5a47"},{"post_id":"cj771ugy7000ryqc3mnsitvix","tag_id":"cj771ugx30002yqc3xnnx4xij","_id":"cj771ugye000tyqc3teadblle"},{"post_id":"cj771ugxj000ayqc3x03yv12k","tag_id":"cj771ugy5000pyqc3cszxt7s5","_id":"cj771ugyf000vyqc3yyhfl896"},{"post_id":"cj771ugxs000eyqc3b3zcepoo","tag_id":"cj771ugy5000pyqc3cszxt7s5","_id":"cj771ugyg000xyqc3by8i3wvf"},{"post_id":"cj771ugxw000jyqc3las7pi9j","tag_id":"cj771ugyf000wyqc3zp11760m","_id":"cj771ugyl000zyqc3o1gyrdkn"},{"post_id":"cj771ugy3000oyqc3qu8vk5t5","tag_id":"cj771ugyl000yyqc3fv1v1p04","_id":"cj771ugym0010yqc3pr1e4ht5"}],"Tag":[{"name":"js","_id":"cj771ugx30002yqc3xnnx4xij"},{"name":"tricks","_id":"cj771ugxt000fyqc3d6t9878b"},{"name":"nodejs","_id":"cj771ugxx000kyqc3pzzw2qnh"},{"name":"python","_id":"cj771ugy5000pyqc3cszxt7s5"},{"name":"web","_id":"cj771ugyf000wyqc3zp11760m"},{"name":"vue","_id":"cj771ugyl000yyqc3fv1v1p04"}]}}