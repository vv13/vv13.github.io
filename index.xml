<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vv13&#39;s blog</title>
    <link>/</link>
    <description>Recent content on vv13&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 06 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>去他妈的适配</title>
      <link>/posts/css_adapt/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/css_adapt/</guid>
      <description>基础 屏幕尺寸 屏幕尺寸即屏幕对角线之间的距离，单位为英寸(inch)。单位换算如下：
 1 inch = 2.54 cm 1 cm = 0.</description>
    </item>
    
    <item>
      <title>d3-intro</title>
      <link>/posts/d3-intro/</link>
      <pubDate>Tue, 24 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/d3-intro/</guid>
      <description>D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。
D3允许将数据绑定到DOM中，然后基于数据驱动去变化DOM。例如可以用数字数组来生成html的表格，或者使用相同数据创建一个平滑响应的SVG条形图。
选择器 使用W3C DOM API十分繁琐，因此D3使用selections，一种声明式的方式来随意的操纵节点。
例如原dom有操作方式如下：
var paragraphs = document.</description>
    </item>
    
    <item>
      <title>css的BFC特性</title>
      <link>/posts/bfc-intro/</link>
      <pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/bfc-intro/</guid>
      <description>预备知识 毗邻元素
只要两个容器之间没有被非空内容、padding、border或clear隔开，那么就可以称作毗邻元素，父组件相对于其第一个子元素或最后一个子元素，只要没有相隔任何上述条件，也可称之为毗邻元素
普通流(normal flow)
在普通流中，元素按照其在HTML中的先后顺序至上而下布局，这个过程中，行内元素水平排列，直到当行被占满后换行，块级元素则会被渲染为一个新行，除非另外指定，否则所有元素默认都是普通流定位。
以下情况会脱离文档流而存在，分别是：float: left、position: absolute、position: fixed</description>
    </item>
    
    <item>
      <title>jenkins部署</title>
      <link>/posts/jenkins-deploy/</link>
      <pubDate>Wed, 18 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/jenkins-deploy/</guid>
      <description>Jenkins是一种由Java开发的持续集成工具，称为CI(Continuous integration)，主要功能是将代码频繁地集成到主干，可以让代码快的迭代，并提高代码质量。
典型的工作流为：开发→提交→编译→测试→发布，Jenkins可以帮你完成除了开发之后的工作，实现自动化。
Jenkins部署步骤 准备工作如下：
 服务器安装docker 拉取镜像：docker pull jenkins/jenkins 创建一个文件夹jenkins_home用于存放jenkins所有配置文件，挂载出来方便迁移，遇到权限问题可设置：chown 1000 .</description>
    </item>
    
    <item>
      <title>js事件触发机制</title>
      <link>/posts/js-event-trigger/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/js-event-trigger/</guid>
      <description>原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</description>
    </item>
    
    <item>
      <title>什么是函数节流</title>
      <link>/posts/throttle/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/throttle/</guid>
      <description>什么是函数节流 避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。
代码实现 首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：
function throttle(fn, delay, ...args) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&amp;gt; fn.</description>
    </item>
    
    <item>
      <title>简历中的STAR原则</title>
      <link>/posts/%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84star%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84star%E5%8E%9F%E5%88%99/</guid>
      <description>STAR概念  Situation：事情是在什么情况下发生的 Task：主要的任务目标是什么 Action：朝向目标的具体行动方式 Result：结果如何，有哪些成长  Star法则主要用于叙述一件事情，不仅可以用于描述简历中的项目经理，当给别人讲述一件事情时，遵从STAR法则也能让故事线更加清晰，因为他是一种表现力强的逻辑方式，能让阐述一件事情更具有：清晰性、条理性和逻辑性。
Example 1 举一个示例：获得省比赛跨栏季军。</description>
    </item>
    
    <item>
      <title>异步编程中的thunk函数</title>
      <link>/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</guid>
      <description>什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&#39;package.json&#39;, (err, data) =&amp;gt; { if (err) throw err; console.</description>
    </item>
    
    <item>
      <title>vue中如何自定义v-model</title>
      <link>/posts/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89v-model/</link>
      <pubDate>Fri, 31 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89v-model/</guid>
      <description>简介 在vue的表单中，大家都享受着v-model带来的便利性，有时候也会遇到自定义v-model的场景，其实它是一颗语法糖而已，那我们接下来就来吃糖吧。
基本的v-model用法为：
&amp;lt;input v-model=&amp;quot;something&amp;quot;&amp;gt;  其实它是以下用法的简写：
&amp;lt;input :value=&amp;quot;something&amp;quot; @input=&amp;quot;something = $event.</description>
    </item>
    
    <item>
      <title>理解javascript线程</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 09 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</guid>
      <description>进程和线程  进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)  线程的作用：
 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型 线程很轻量，创建与销毁消耗的资源小 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作  根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</description>
    </item>
    
    <item>
      <title>flex布局</title>
      <link>/posts/flex%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/flex%E5%B8%83%E5%B1%80/</guid>
      <description>简介 flex即弹性盒子布局，它比传统的布局提供更大的灵活性，w3c组织在09年提出这个概念，目前已经广泛应用于支持各个浏览器。
它最大的特性是可以使子元素充分的利用容器的空间，当空间不足时也可进行收缩，以此来适应各种各样的屏幕大小，也能根据权重排列子元素的顺序。
设置容器为flex布局，只需要设置display: flex即可。它将具有以下特性： 1. 子元素float、clear、vertical-align将失效。 2. 存在主轴(默认为水平)与交叉轴，通过flex-direction可设置主轴的方向。</description>
    </item>
    
    <item>
      <title>BEM规范</title>
      <link>/posts/bem%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/bem%E8%A7%84%E8%8C%83/</guid>
      <description>什么是BEM？ block(块)、element(元素)、modifier(修饰符)，是一种css命名方式，它让css类对开发者更加透明与易于维护。
语法 .block {} // 块 .block__element {} // 块所属元素 .</description>
    </item>
    
    <item>
      <title>python求质数的几种方法</title>
      <link>/posts/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>今天偶然在博客上上看到有人提求质素的几种境界,在此用python进行实现代码,并进行简单的说明.
我们将要实现函数的功能是输入一个数N,能把小于N的质数个数打印出来,并计算出所耗时间.
境界1 我们采用试除法,意思就是将比N小的符合要求的每一个数都除以它,若都无法整除则N为质数,这也是我们能想到的最简单的方法,我们可以从j的范围进行优化一下,很容易想到j的范围可以取2~N/2. 代码如下:
def f1(num): # 2也是质数,之后程序从3开始判断 count = 1 for i in range(3, num): b = True for j in range(2, i/2 + 1): if i % j == 0: b = False break if b: count += 1 return count f1(100000) # 耗时35.</description>
    </item>
    
    <item>
      <title>几个简单的排序-js描述</title>
      <link>/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。
冒泡 冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。
原理 此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。
代码 function sort(arrs) { const len = arrs.</description>
    </item>
    
    <item>
      <title>nodejs中exports与module.exports的区别</title>
      <link>/posts/nodejs%E4%B8%ADexports%E4%B8%8Emodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/nodejs%E4%B8%ADexports%E4%B8%8Emodule-exports%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>在nodejs中常常会使用require()加载模块，为了使得文件模块化，将其的变量与方法提供给别的模块使用，就会使用到exports与module.exports，可是如何区分它们呢？ 在此简单的记录一下。
require()的返回值 require()返回的是module.exports指向的内容而不是exports的，我们将两个变量分别赋予新的内存地址，以此来进行观察：
test.js:
module.exports = function(){ console.log(&#39;I\&#39;m module.</description>
    </item>
    
    <item>
      <title>python变量作用域</title>
      <link>/posts/python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Sun, 25 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>class比作整个屋子，def为卧室，class外面的部分就是小区环境。
首先测试房子(class)与公共设施变量(globals)之间的关系 # encoding: utf-8 PUBLIC_FACILITIES = u&amp;quot;公共厕所&amp;quot; class House(): print PUBLIC_FACILITIES PUBLIC_FACILITIES = &#39;改造&#39; if __name__ == &#39;__main__&#39;: test = House() print PUBLIC_FACILITIES  测试结果：</description>
    </item>
    
    <item>
      <title>BOM对象的应用</title>
      <link>/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如： + 跳转到新的网址：window.location.href = &#39;http://www.google.com&#39;; + 打开新的窗体：window.open(&#39;http://www.google.com&#39;); + 刷新页面：window.location.reload(); + 后退：window.</description>
    </item>
    
    <item>
      <title>git实用命令技巧</title>
      <link>/posts/git-tricks/</link>
      <pubDate>Sun, 11 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/git-tricks/</guid>
      <description>git pull &amp;ndash;rebase 从分支上拉取最新的代码时，往往会多出一条merge记录，这样有时不是我们所期望的，因为它会让整个提交线图变得难以理解：
我们期望的分支图也许时这样的：
只需要将git pull -&amp;gt; git pull &amp;ndash;rebase。rebase的好处就在于，它会将当前新的提交记录，全部追加到远程提交信息记录之后:</description>
    </item>
    
    <item>
      <title>js代理函数技巧</title>
      <link>/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</guid>
      <description>简述 有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？
示例 假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：
function splice(arrs, start, length) { arrs.</description>
    </item>
    
    <item>
      <title>js变量申明解析</title>
      <link>/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</guid>
      <description>var属性有多种需要注意的特性： 1. 无块级作用域 2. 不带申明类型默认为全局变量 3. 变量提升 4. 运行重新申明变量</description>
    </item>
    
    <item>
      <title>js变量作用域与垃圾回收</title>
      <link>/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &#39;某某某&#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj;  它们在内存中的结构如图：</description>
    </item>
    
  </channel>
</rss>