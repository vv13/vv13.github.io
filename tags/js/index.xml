<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on vv13&#39;s blog</title>
    <link>/tags/js/</link>
    <description>Recent content in Js on vv13&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 17 Oct 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js事件触发机制</title>
      <link>/posts/js-event-trigger/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/js-event-trigger/</guid>
      <description>原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</description>
    </item>
    
    <item>
      <title>什么是函数节流</title>
      <link>/posts/throttle/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/throttle/</guid>
      <description>什么是函数节流 避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。
代码实现 首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：
function throttle(fn, delay, ...args) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&amp;gt; fn.</description>
    </item>
    
    <item>
      <title>异步编程中的thunk函数</title>
      <link>/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</guid>
      <description>什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&#39;package.json&#39;, (err, data) =&amp;gt; { if (err) throw err; console.</description>
    </item>
    
    <item>
      <title>理解javascript线程</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 09 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</guid>
      <description>进程和线程  进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)  线程的作用：
 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型 线程很轻量，创建与销毁消耗的资源小 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作  根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：</description>
    </item>
    
    <item>
      <title>几个简单的排序-js描述</title>
      <link>/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。
冒泡 冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。
原理 此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。
代码 function sort(arrs) { const len = arrs.</description>
    </item>
    
    <item>
      <title>BOM对象的应用</title>
      <link>/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如： + 跳转到新的网址：window.location.href = &#39;http://www.google.com&#39;; + 打开新的窗体：window.open(&#39;http://www.google.com&#39;); + 刷新页面：window.location.reload(); + 后退：window.</description>
    </item>
    
    <item>
      <title>js代理函数技巧</title>
      <link>/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</guid>
      <description>简述 有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？
示例 假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：
function splice(arrs, start, length) { arrs.</description>
    </item>
    
    <item>
      <title>js变量申明解析</title>
      <link>/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</guid>
      <description>var属性有多种需要注意的特性： 1. 无块级作用域 2. 不带申明类型默认为全局变量 3. 变量提升 4. 运行重新申明变量</description>
    </item>
    
    <item>
      <title>js变量作用域与垃圾回收</title>
      <link>/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &#39;某某某&#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj;  它们在内存中的结构如图：</description>
    </item>
    
  </channel>
</rss>